<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Writing Data Objects</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="WritingDataObjects">Writing Data Objects</a></h1><center>&lt; <a class="el" href="BinderDataModel.html">Binder Data Model</a> | <a class="el" href="StorageKit.html">Storage Kit</a> | fini &gt;</center> <hr>
<p>
When implementing your own data model object, you should make use of the standard C++ base classes that are available. These classes are provided for two main reasons:<p>
<ul>
<li>They take care of the common types of functionality that is needed, so that differing data model implementations will provide the same level of functionality and behavior as much as possible. This also means that as these classes gain new functionality, that functionality will become available to all implementations that were based on the class.</li></ul>
<p>
<ul>
<li>They can reduce  often greatly  the amount of work required to implement a data model object.</li></ul>
<p>
There are a wide variety of classes available, so it can be daunting to figure out where to start. In general, they are designed as layers of increasingly higher-level functionality for the three core data model interfaces, <a class="el" href="classINode.html">INode</a>, <a class="el" href="classIIterable.html">IIterable</a>, and <a class="el" href="classIDatum.html">IDatum</a>.<p>
This document will start with the highest-level classes, and work down to the simpler ones. This should allow you to go down through the available classes until you find one that will do what you want, and stop there. Remember that you should <em>always</em> use one of these classes to implement the <a class="el" href="classINode.html">INode</a>, <a class="el" href="classIIterable.html">IIterable</a>, or <a class="el" href="classIDatum.html">IDatum</a> interfaces; as a very last resort, that will be <a class="el" href="classBGenericNode.html">BGenericNode</a>, <a class="el" href="classBGenericIterable.html">BGenericIterable</a>, and <a class="el" href="classBGenericDatum.html">BGenericDatum</a>, respectively.<p>
<ol type=1>
<li><a class="el" href="WritingDataObjects.html#DesignOverview">Design Overview</a></li><li><a class="el" href="WritingDataObjects.html#ImplementationHelperClasses">Implementation Helper Classes</a><ol type=a>
<li><a class="el" href="WritingDataObjects.html#Delegation">Delegation</a></li><li>DataManager</li><li><a class="el" href="WritingDataObjects.html#Tables">Tables</a></li><li><a class="el" href="WritingDataObjects.html#Arrays">Arrays</a></li><li><a class="el" href="WritingDataObjects.html#Nodes">Nodes</a></li><li><a class="el" href="WritingDataObjects.html#Iterables">Iterables</a></li><li><a class="el" href="WritingDataObjects.html#Datums">Datums</a></li></ol>
</li><li><a class="el" href="WritingDataObjects.html#Example">Example</a></li></ol>
<h2><a class="anchor" name="DesignOverview">
Design Overview</a></h2>
Before looking at the classes in detail, there are some general concepts behind their design that should be understood.<p>
In general, these classes provide an implementation of the <a class="el" href="BinderDataModel.html">Binder Data Model</a> interfaces on top of some other data structure that you will provide. Providing the data structure means implementing a subclass of the desired data model class and filling in the appropriate virtuals to give it access to your data.<p>
The implementation of the data model classes and the underlying data they access must be, however, closely related. In particular, there are many cases where the implementation will need to do a series of operations during which it is assured that the back-end data remains in a consistent state. Because of this requirement, the locking approach used for these classes is very different than what you will see elsewhere.<p>
Almost all of the data model classes explicitly expose their internal locking, so that it can be synchronized with the back-end data. This takes the form of a couple public virtuals to explicitly lock and unlock the object, and a convention for users to know when that lock is being held.<p>
<dl compact><dt><b>Note:</b></dt><dd>As mentioned, this locking policy is <em>very</em> <em>different</em> than what is used elsewhere in the <a class="el" href="BinderKit.html">Binder Kit</a>. You should generally prefer the Binder's standard locking model (as described in <a class="el" href="BinderThreading.html">Threading Conventions</a>), since that is more flexible and results in a much easier to use API.</dd></dl>
By convention, all methods in these classes that are called with the object's lock held (or put another way, must be called while holding that lock) have the suffix "Locked" in their name. A <em>new</em> method defined by one of these classes that does not have the "Locked" suffix <em>must</em> be called <em>without</em> holding the lock (since it may need to acquire the lock in its implementation).<p>
In some cases, a method without the "Locked" suffix may be safe to call with or without the lock held; this situation will be documented. It is also, of course, safe to call the <a class="el" href="classSAtom.html">SAtom</a>, <a class="el" href="classBBinder.html">BBinder</a>, and other standard Binder APIs with or without the lock being held, since these use the standard <a class="el" href="BinderThreading.html">Threading Conventions</a> model.<p>
For example, compare <a class="el" href="classBGenericNode.html#z56_6">BGenericNode::SetMimeType()</a> to <a class="el" href="classBGenericNode.html#z56_7">BGenericNode::SetMimeTypeLocked()</a>.<p>
The Lock() methods return a <a class="el" href="structlock__status__t.html">lock_status_t</a> result, making them convenient to use with the <a class="el" href="classSAutolock.html">SAutolock</a> class, like so:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> set_catalog_mime_type(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;BCatalog&gt;</a>&amp; catalog)
{
    <a class="code" href="classSAutolock.html">SAutolock</a> _l(catalog-&gt;Lock());
    catalog-&gt;StoreMimeTypeLocked(mime_type);
}
</pre></div><p>
When mixing two classes together that have their own locks, you will usually need to re-implement their Lock() and Unlock() methods so that they share the same lock:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>NodeAndIterable : <span class="keyword">public</span> <a class="code" href="classBMetaDataNode.html">BMetaDataNode</a>, <span class="keyword">public</span> <a class="code" href="classBIndexedIterable.html">BIndexedIterable</a>
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <a class="code" href="structlock__status__t.html">lock_status_t</a> Lock()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBGenericNode.html#z55_2">BMetaDataNode::Lock</a>(); }
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Unlock()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> <a class="code" href="classBGenericNode.html#z55_3">BMetaDataNode::Unlock</a>(); }
};
</pre></div><p>
This goes along with the standard mixing of the <a class="el" href="classIBinder.html#a7">IBinder::Inspect()</a> method that is done when mixing together multiple interfaces.<h2><a class="anchor" name="ImplementationHelperClasses">
Implementation Helper Classes</a></h2>
This section gives an overview and summary of the available helper classes for implementing data objects, going from highest level to lowest.<h3><a class="anchor" name="Delegation">
Delegation</a></h3>
These classes allow you to wrap an existing data model object, providing an implementation that modifies its behavior. For example, you could use them to rename all of the entries in a node from <em>X</em> to <em>foo-X</em>.<p>
<ul>
<li><a class="el" href="classBCatalogDelegate.html">BCatalogDelegate</a> is a delegate to an object implementing the full catalog API  <a class="el" href="classINode.html">INode</a>, <a class="el" href="classIIterable.html">IIterable</a>, and <a class="el" href="classICatalog.html">ICatalog</a>.</li></ul>
<p>
<ul>
<li><a class="el" href="classBNodeDelegate.html">BNodeDelegate</a> is a delagate to an object implementing <a class="el" href="classINode.html">INode</a>.</li></ul>
<h3><a class="anchor" name="Tables">
Tables</a></h3>
A common data structure is that of a table: at the top an array of rows, each of which itself contains an array of columns. This is used, for example, to provide data to a list view.<p>
<ul>
<li><a class="el" href="classBIndexedTableNode.html">BIndexedTableNode</a> is a base class for providing a table structure. Given the implementation of a few virtuals to define the rows and columns and data access for individual table cells, this class will expose that structure as a hierarchical data model layout of nodes and datums.</li></ul>
<h3><a class="anchor" name="Arrays">
Arrays</a></h3>
An array is the simplest data structure available, an ordered series of values. More complicated data structures are created arrays by nesting arrays inside of each other, such as the rows inside of a table.<p>
<ul>
<li><a class="el" href="classBStructuredNode.html">BStructuredNode</a> is an array representing a fixed structure of data, like a C structure. That is, the array has a fixed size with each index in the array corresponding to a well-defined field in the structure.</li></ul>
<p>
<ul>
<li><a class="el" href="classBCatalog.html">BCatalog</a> is a generic data container holding an array of arbitrary values. Unlike most other data classes discussed here, <a class="el" href="classBCatalog.html">BCatalog</a> has its own build-in data management. That is, it is a concrete class that you can instantiate without further specialization.</li></ul>
<p>
<ul>
<li><a class="el" href="classBIndexedDataNode.html">BIndexedDataNode</a> is a generic class for implementing an array, defining nothing about what indices into the array means or what data they may hold. This is used to implement both <a class="el" href="classBCatalog.html">BCatalog</a> and <a class="el" href="classBStructuredNode.html">BStructuredNode</a>.</li></ul>
<h3><a class="anchor" name="Nodes">
Nodes</a></h3>
These classes provide the most generic support for implementing the <a class="el" href="classINode.html">INode</a> interface.<p>
<ul>
<li><a class="el" href="classBMetaDataNode.html">BMetaDataNode</a> is a node that maintains its own basic metadata: MIME type, creation date, and modification date.</li></ul>
<p>
<ul>
<li><a class="el" href="classBGenericNode.html">BGenericNode</a> is the most generic class, when all else fails.</li></ul>
<h3><a class="anchor" name="Iterables">
Iterables</a></h3>
These classes provide the most generic support for imlementing the <a class="el" href="classIIterable.html">IIterable</a>, and thus <a class="el" href="classIIterator.html">IIterator</a> and <a class="el" href="classIRandomIterator.html">IRandomIterator</a>, interfaces.<p>
<ul>
<li><a class="el" href="classBIndexedIterable.html">BIndexedIterable</a> is an iterator over an indexed series of data items. That is, the data is in an array with indices starting at 0 and incrementing by 1 up to the last item.</li></ul>
<p>
<ul>
<li><a class="el" href="classBGenericIterable.html">BGenericIterable</a> is the most generic class, when all else fails.</li></ul>
<h3><a class="anchor" name="Datums">
Datums</a></h3>
These classes provide the most generic support for implementing the <a class="el" href="classIDatum.html">IDatum</a> interface.<p>
<ul>
<li><a class="el" href="classSDatumGeneratorInt.html">SDatumGeneratorInt</a> is a helper class for dynamically generating datum objects that provide access to a set of data items. These datum objects reference back to their corresponding data item through an integer key, making this useful for example to provide access to an array of data. Unlike the other array classes, however, there is no ordering required of the integer keys  they can be any integer value desired.</li></ul>
<p>
<ul>
<li><a class="el" href="classBValueDatum.html">BValueDatum</a> is a datum providing access to a single pieces of typed data (an <a class="el" href="classSValue.html">SValue</a>). Unlike most other classes discussed here, this is a concrete class that you can instantiate without further specialization  it maintains the data it is holding.</li></ul>
<p>
<ul>
<li><a class="el" href="classBStreamDatum.html">BStreamDatum</a> provides all of the basic <a class="el" href="classIDatum.html">IDatum</a> functionality, in particular implementing <a class="el" href="classIDatum.html#a3">IDatum::Open()</a> to generate stream objects.</li></ul>
<p>
<ul>
<li><a class="el" href="classBGenericDatum.html">BGenericDatum</a> is the most generic class. You should almost always use <a class="el" href="classBStreamDatum.html">BStreamDatum</a> instead, so that you don't have to implement your own stream management.</li></ul>
<h2><a class="anchor" name="Example">
Example</a></h2>
This example shows the implementation of a "content provider" for contact/person information. It uses <a class="el" href="classBSchemaDatabaseNode.html">BSchemaDatabaseNode</a> to expose multiple database tables in various ways. The top-level content provider is a <a class="el" href="classBStructuredNode.html">BStructuredNode</a>, used to publish a fixed set of entries at that level for selection of the various kinds of data (tables) contained inside of it.<p>
<dl compact><dt><b>Note:</b></dt><dd>The classes used here are part of an old implementation of the data model on top of Cobalt's Data Manager APIs. They are not built as part of the current OpenBinder distribution, but are included to illustration how this kind of data can be presented in the data model.</dd></dl>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Package_8h.html">support/Package.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="StructuredNode_8h.html">storage/StructuredNode.h</a>&gt;</span>
<span class="preprocessor">#include &lt;storage/SchemaDatabaseNode.h&gt;</span>
<span class="preprocessor">#include &lt;storage/SchemaRowIDJoin.h&gt;</span>

<span class="preprocessor">#include &lt;<a class="code" href="Autolock_8h.html">support/Autolock.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="Iterator_8h.html">support/Iterator.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="Node_8h.html">support/Node.h</a>&gt;</span>

<span class="preprocessor">#include &lt;DataMgr.h&gt;</span>
<span class="preprocessor">#include &lt;Loader.h&gt;</span>
<span class="preprocessor">#include &lt;SchemaDatabases.h&gt;</span>

<span class="comment">// Top-level content provider object, containing sub-directories</span>
<span class="comment">// to access the various tables of information.</span>
<span class="keyword">class </span>AddressContentProvider : <span class="keyword">public</span> <a class="code" href="classBStructuredNode.html">BStructuredNode</a>, <span class="keyword">public</span> <a class="code" href="classSPackageSptr.html">SPackageSptr</a>
{
<span class="keyword">public</span>:
                                    AddressContentProvider(<span class="keyword">const</span> <a class="code" href="classSContext.html">SContext</a>&amp; context, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; args);
            <span class="keywordtype">void</span>                    InitAtom();

    <span class="keyword">virtual</span> <a class="code" href="classSValue.html">SValue</a>                  ValueAtLocked(size_t index) <span class="keyword">const</span>;

<span class="keyword">private</span>:
            <a class="code" href="classsptr.html">sptr&lt;BSchemaDatabaseNode&gt;</a>   m_database;
            <a class="code" href="classsptr.html">sptr&lt;BSchemaTableNode&gt;</a>      m_people;
            <a class="code" href="classsptr.html">sptr&lt;BSchemaTableNode&gt;</a>      m_phones;
            <a class="code" href="classsptr.html">sptr&lt;BSchemaTableNode&gt;</a>      m_extras;
            <a class="code" href="classsptr.html">sptr&lt;BSchemaRowIDJoin&gt;</a>      m_phonesDir;
            <a class="code" href="classsptr.html">sptr&lt;BSchemaRowIDJoin&gt;</a>      m_extrasDir;
};

<span class="comment">// ---------------------------------------------------------------</span>

<span class="comment">// Various constants we will use elsewhere.</span>

<a class="code" href="group__CoreSupportUtilities.html#ga92">B_STATIC_STRING_VALUE_LARGE</a>(kPersonListMimeType, <span class="stringliteral">"application/vnd.palm.personlist"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga92">B_STATIC_STRING_VALUE_LARGE</a>(kPersonItemMimeType, <span class="stringliteral">"application/vnd.palm.personitem"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga92">B_STATIC_STRING_VALUE_LARGE</a>(kPhoneListMimeType, <span class="stringliteral">"application/vnd.palm.phonelist"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga92">B_STATIC_STRING_VALUE_LARGE</a>(kPhoneItemMimeType, <span class="stringliteral">"application/vnd.palm.phoneitem"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga92">B_STATIC_STRING_VALUE_LARGE</a>(kPersonExtrasListMimeType, <span class="stringliteral">"application/vnd.palm.personextraslist"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga92">B_STATIC_STRING_VALUE_LARGE</a>(kPersonExtrasItemMimeType, <span class="stringliteral">"application/vnd.palm.personextrasitem"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE</a>(kAddressDBName, <span class="stringliteral">"AddressDBSNu"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE</a>(kAddressMainTableName, <span class="stringliteral">"AddressBookMain"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE</a>(kAddressPhoneTableName, <span class="stringliteral">"AddressBookPhone"</span> ,);
<a class="code" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE</a>(kAddressExtraTableName, <span class="stringliteral">"AddressBookExtra"</span> ,);

<span class="comment">// ---------------------------------------------------------------</span>

<span class="comment">// This class is used to implement a custom database column</span>
<span class="comment">// based on the "FirstName" and "LastName" columns.</span>

<span class="keyword">const</span> <span class="keywordtype">char</span>* displayColumns[] = { <span class="stringliteral">"FirstName"</span>, <span class="stringliteral">"LastName"</span>, <a class="code" href="group__Core.html#ga75">NULL</a> };

<span class="keyword">class </span>DisplayName : <span class="keyword">public</span> <a class="code" href="classBSchemaTableNode.html">BSchemaTableNode</a>::CustomColumn, <span class="keyword">public</span> <a class="code" href="classSPackageSptr.html">SPackageSptr</a>
{
<span class="keyword">public</span>:
    DisplayName(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;BSchemaTableNode&gt;</a>&amp; table)
        : CustomColumn(table)
    {
    }

    <span class="keyword">virtual</span> <a class="code" href="classSValue.html">SValue</a> ValueLocked(uint32_t columnOrRowID, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>* baseValues,
                               <span class="keyword">const</span> size_t* columnsToValues)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <a class="code" href="classSString.html">SString</a> result(baseValues[columnsToValues[1]].AsString());
        <span class="keyword">const</span> <a class="code" href="classSString.html">SString</a> first(baseValues[columnsToValues[0]].AsString());
        <span class="keywordflow">if</span> (first != <span class="stringliteral">""</span>) result += <span class="stringliteral">", "</span>;
        result += first;
        <span class="keywordflow">return</span> <a class="code" href="classSValue.html#z174_14">SValue::String</a>(result);
    }
};

<span class="comment">// ---------------------------------------------------------------</span>

<span class="comment">// These are the top-level directories in the content provider.</span>
<span class="keyword">const</span> <span class="keywordtype">char</span>* kDirNames[] = {
    <span class="stringliteral">"people"</span>,
    <span class="stringliteral">"phones"</span>,
    <span class="stringliteral">"extras"</span>,
    <span class="stringliteral">"databases"</span>,
};
<span class="keyword">enum</span> {
    kPeopleDir = 0,
    kPhonesDir,
    kExtrasDir,
    kDatabasesDir,
    kDirCount
};

AddressContentProvider::AddressContentProvider(<span class="keyword">const</span> <a class="code" href="classSContext.html">SContext</a>&amp; context, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; args)
    : <a class="code" href="classBStructuredNode.html">BStructuredNode</a>(context, kDirNames, kDirCount)
{
}

<span class="comment">// Main initialization of content provider.</span>
<span class="keywordtype">void</span> <a class="code" href="classSAtom.html#z105_4">AddressContentProvider::InitAtom</a>()
{
    <a class="code" href="classSAtom.html#z105_4">BStructuredNode::InitAtom</a>();

    <span class="comment">// Try to open the database.  If it doesn't exist, create it.</span>
    <a class="code" href="classSDatabase.html">SDatabase</a> database(((<span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp;)kAddressDBName).String(), 'add2',
        dmModeReadWrite, dbShareRead);
    <span class="keywordflow">if</span> (database.StatusCheck() != <a class="code" href="CmnErrors_8h.html#a110">errNone</a>) {
        <span class="comment">// Error opening database -- try to create it in case it doesn't exist.</span>
        <a class="code" href="group__Core.html#ga19">MemHandle</a>   memh;
        <span class="keywordtype">void</span> *      memp;
        DatabaseID  dbid;
        <a class="code" href="group__Core.html#ga0">status_t</a>    err = <a class="code" href="CmnErrors_8h.html#a110">errNone</a>;

        DmOpenRef appdb;
        SysGetModuleDatabase(SysGetRefNum(), <a class="code" href="group__Core.html#ga75">NULL</a>, &amp;appdb);

        <span class="keywordflow">if</span> ((memh = DmGetResource(appdb, 'scdb', SCHEMA_DEFINITION_ID)) == <a class="code" href="group__Core.html#ga75">NULL</a>)
            <span class="keywordflow">return</span>;

        <span class="keywordflow">if</span> ((memp = MemHandleLock(memh)) == <a class="code" href="group__Core.html#ga75">NULL</a>)
        {
            DmReleaseResource(memh);
            <span class="keywordflow">return</span>;
        }

        <span class="keywordflow">if</span> ((err = DmCreateDatabaseFromImage(memp, &amp;dbid)) &lt; <a class="code" href="CmnErrors_8h.html#a110">errNone</a>)
        {
            <span class="keywordflow">return</span>;
        }

        MemHandleUnlock(memh);
        DmReleaseResource(memh);

        database = <a class="code" href="classSDatabase.html">SDatabase</a>(((<span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp;)kAddressDBName).String(), 'add2',
            dmModeReadWrite, dbShareRead);
    }

    <span class="comment">// Create the database node, and build up our content</span>
    <span class="comment">// provider's subdirectories from it.</span>
    <span class="keywordflow">if</span> (database.StatusCheck() == <a class="code" href="CmnErrors_8h.html#a110">errNone</a>) {

        <span class="comment">// Create database object and retrieve its tables.</span>
        m_database = <span class="keyword">new</span> <a class="code" href="classBSchemaDatabaseNode.html">BSchemaDatabaseNode</a>(Context(), database);
        m_database-&gt;Lock();
        m_people = m_database-&gt;TableForLocked(kAddressMainTableName);
        m_phones = m_database-&gt;TableForLocked(kAddressPhoneTableName);
        m_extras = m_database-&gt;TableForLocked(kAddressExtraTableName);
        m_database-&gt;Unlock();

        <span class="comment">// Create a join between the people and phone number tables.</span>
        <span class="keywordflow">if</span> (m_people != <a class="code" href="group__Core.html#ga75">NULL</a> &amp;&amp; m_phones != <a class="code" href="group__Core.html#ga75">NULL</a>) {
            m_phonesDir = <span class="keyword">new</span> <a class="code" href="classBSchemaRowIDJoin.html">BSchemaRowIDJoin</a>(Context(), m_people, m_phones,
                kPersonID, kperson);
            <span class="keywordflow">if</span> (m_phonesDir != <a class="code" href="group__Core.html#ga75">NULL</a>) {
                <a class="code" href="classSAutolock.html">SAutolock</a> _l(m_phonesDir-&gt;Lock());
                m_phonesDir-&gt;StoreMimeTypeLocked(kPhoneListMimeType);
                m_phonesDir-&gt;StoreRowMimeTypeLocked(kPhoneItemMimeType);
            }
        }

        <span class="comment">// Create a join between the people and extra info tables.</span>
        <span class="keywordflow">if</span> (m_people != <a class="code" href="group__Core.html#ga75">NULL</a> &amp;&amp; m_extras != <a class="code" href="group__Core.html#ga75">NULL</a>) {
            m_extrasDir = <span class="keyword">new</span> <a class="code" href="classBSchemaRowIDJoin.html">BSchemaRowIDJoin</a>(Context(), m_people, m_extras,
                kPersonID, kperson);
            <span class="keywordflow">if</span> (m_emailsDir != <a class="code" href="group__Core.html#ga75">NULL</a>) {
                <a class="code" href="classSAutolock.html">SAutolock</a> _l(m_emailsDir-&gt;Lock());
                m_extrasDir-&gt;StoreMimeTypeLocked(kPersonExtrasListMimeType);
                m_extrasDir-&gt;StoreRowMimeTypeLocked(kPersonExtrasItemMimeType);
            }
        }

        <span class="comment">// Add a custom column to the people table and set its MIME type.</span>
        <span class="keywordflow">if</span> (m_people != <a class="code" href="group__Core.html#ga75">NULL</a>) {
            <a class="code" href="classsptr.html">sptr&lt;DisplayName&gt;</a> dname = <span class="keyword">new</span> DisplayName(m_people);
            <span class="keywordflow">if</span> (dname != <a class="code" href="group__Core.html#ga75">NULL</a>)
                dname-&gt;AttachColumn(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"DisplayName"</span>), displayColumns);
            <a class="code" href="classSAutolock.html">SAutolock</a> _l(m_people-&gt;Lock());
            m_people-&gt;StoreMimeTypeLocked(kPersonListMimeType);
            m_people-&gt;StoreRowMimeTypeLocked(kPersonItemMimeType);
        }
    }
}

<span class="comment">// Provide access to our sub-directories.</span>
<a class="code" href="classSValue.html">SValue</a> <a class="code" href="classBStructuredNode.html#z100_1">AddressContentProvider::ValueAtLocked</a>(size_t index)<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span> (index) {
        <span class="keywordflow">case</span> kPeopleDir: <span class="keywordflow">return</span> <a class="code" href="classSValue.html#z174_1">SValue::Binder</a>((<a class="code" href="classBnNode.html">BnNode</a>*)m_people.ptr());
        <span class="keywordflow">case</span> kPhonesDir: <span class="keywordflow">return</span> <a class="code" href="classSValue.html#z174_1">SValue::Binder</a>((BnNode*)m_phonesDir.ptr());
        <span class="keywordflow">case</span> kExtrasDir: <span class="keywordflow">return</span> <a class="code" href="classSValue.html#z174_1">SValue::Binder</a>((BnNode*)m_extrasDir.ptr());
        <span class="keywordflow">case</span> kDatabasesDir: <span class="keywordflow">return</span> <a class="code" href="classSValue.html#z174_1">SValue::Binder</a>((BnNode*)m_database.ptr());
    }
    <span class="keywordflow">return</span> <a class="code" href="classSValue.html#z173_1">SValue::Undefined</a>();
}
</pre></div> <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:33 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
