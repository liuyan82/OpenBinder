<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder Data Model</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderDataModel">Binder Data Model</a></h1><div class="header"> <center>&lt; <a class="el" href="StorageKit.html">Storage Kit</a> | <a class="el" href="StorageKit.html">Storage Kit</a> | <a class="el" href="WritingDataObjects.html">Writing Data Objects</a> &gt;</center> <hr>
 </div><p>
The Binder defines a standard data model, which is used for things such as creating the <a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a>, providing data to the BListView widget, etc.<p>
Though the data model is documented as part of the <a class="el" href="StorageKit.html">Storage Kit</a>, it actually spans between that and the <a class="el" href="BinderKit.html">Binder Kit</a>. The core data model interfaces and client APIs (<a class="el" href="classINode.html">INode</a>, <a class="el" href="classIIterable.html">IIterable</a>, <a class="el" href="classIDatum.html">IDatum</a>, <a class="el" href="classICatalog.html">ICatalog</a>, <a class="el" href="classITable.html">ITable</a>, <a class="el" href="classSNode.html">SNode</a>, <a class="el" href="classSIterator.html">SIterator</a>, <a class="el" href="classSDatum.html">SDatum</a>) are included in the <a class="el" href="BinderKit.html">Binder Kit</a>, but all of the implementation for them is in the <a class="el" href="StorageKit.html">Storage Kit</a>.<p>
<ol type=1>
<li><a class="el" href="BinderDataModel.html#Interfaces">The Interfaces</a><ol type=a>
<li><a class="el" href="BinderDataModel.html#FileSystemMapping">The Data Model as a Filesystem</a></li><li><a class="el" href="BinderDataModel.html#DatabaseMapping">The Data Model as a Database</a></li></ol>
</li><li><a class="el" href="BinderDataModel.html#DataModelClients">Data Model Clients</a></li><li><a class="el" href="BinderDataModel.html#DetailedTopics">Detailed Topics</a><ol type=a>
<li><a class="el" href="BinderDataModel.html#NamingEntries">Naming Entries</a></li><li><a class="el" href="BinderDataModel.html#EntriesAndIdentity">Entries and Identity</a></li><li><a class="el" href="BinderDataModel.html#WhereAreTheFiles">Where Are the Files?</a></li><li><a class="el" href="BinderDataModel.html#DatumConsiderations">Datum Considerations</a></li><li><a class="el" href="BinderDataModel.html#IDatumOrSValue">IDatum or SValue?</a></li></ol>
</li></ol>
<h2><a class="anchor" name="Interfaces">
The Interfaces</a></h2>
The basic data model is simply a set of well-defined Binder interfaces, creating a hierarchical namespace of data. The most important interfaces are:<p>
<ul>
<li><a class="el" href="classINode.html">INode</a>: <em>"Walking a path (depth traversal)."</em> An entry in the namespace, with sub-entries and/or meta-data.</li><li><a class="el" href="classIDatum.html">IDatum</a>: <em>"Manipulating data."</em> A single piece of atomic data in the namespace.</li><li><a class="el" href="classIIterable.html">IIterable</a>: <em>"Collecting things (breadth traversal)."</em> API for discovering the available entries/data.</li><li><a class="el" href="classICatalog.html">ICatalog</a>: <em>"Adding and deleting."</em> API for modifying the entries in an <a class="el" href="classINode.html">INode</a>.</li><li><a class="el" href="classITable.html">ITable</a>: <em>"Manipulating 2d data structures."</em> Special API for objects that contain two-dimension data.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Clients will usually use the <a class="el" href="classSNode.html">SNode</a>, <a class="el" href="classSIterator.html">SIterator</a>, and <a class="el" href="classSDatum.html">SDatum</a> classes instead of calling these interfaces directly. These classes provide the same functionality as the interfaces, in a somewhat more convenient form.</dd></dl>
It is important to note that everything in the namespace is an object. (Or more specifically, everything is an <a class="el" href="classIBinder.html">IBinder</a>.) This is why there is a specific <a class="el" href="classIDatum.html">IDatum</a> interface: it is the protocol through which you retrieve and place data at a particular location in the namespace.<p>
Traversal in the namespace only goes from parent to child. <em>The core data model does not include access from a child back to its parent.</em> The reason for this is to support hard links in the namespace – two or more nodes that share a common child. In this situation the child has multiple parents, so it is not feasible for it to keep track of its parent.<p>
This does not mean that APIs built on top of the basic data model can't have back-pointers  an example would be exposing the view hierarchy in the namespace  it just means that it is not a requirement. For example, the entire view hierarchy is visible in the namespace, and through the view hierarchy APIs you can travel back up from a child to its parent. Similarily, some data space objects may implement the <a class="el" href="classIReferable.html">IReferable</a> interface to provide a full path back to the object.<p>
There are two major use-cases these interfaces are designed for: filesystems and databases. Instead of discussing the interfaces themselves in abstract terms, we will describe them as concrete mappings to these traditional kinds of structured data.<h3><a class="anchor" name="FileSystemMapping">
The Data Model as a Filesystem</a></h3>
A filesystem is a hierarchical organization of directories, where a directory can contain other directories as well as leaf files holding data. In addition, each file or directory has some fixed set of meta-data associated with it, often creation and modification dates and permission flags.<p>
All files and directories in a filesystem implement the <a class="el" href="classINode.html">INode</a> interface. This is to provide meta-data (such as creation and modification date) about that item, and for directories it is used to walk a path through the directory hierarchy.<p>
A file also implements the <a class="el" href="classIDatum.html">IDatum</a> interface, allowing access to that file's data. In particular, the <a class="el" href="classIDatum.html#a3">IDatum::Open()</a> method is the equivalent to opening a file, giving by byte stream interfaces through which you can read and write data in the file.<p>
A directory, in contrast, implements <a class="el" href="classIIterable.html">IIterable</a> and <a class="el" href="classICatalog.html">ICatalog</a>. The <a class="el" href="classIIterable.html">IIterable</a> interface lets you browse through the contents of the directory  this is, for example, the API that would be used to implement an "ls" command. The <a class="el" href="classICatalog.html">ICatalog</a> interface provides various methods for adding new entries (files or directories) to the directory, renaming entries, and deleting existing entries.<h3><a class="anchor" name="DatabaseMapping">
The Data Model as a Database</a></h3>
A database is a flat collection of tables. Each table is a two-dimensional structure, consisting of an arbitrary numbner of rows, each containing a set data items corresponding to from a fixed set of columns defined by the table.<p>
The table of a database revolves around the <a class="el" href="classIIterable.html">IIterable</a> interface. This allows you to create queries on the table by calling <a class="el" href="classIIterable.html#a1">IIterable::NewIterator()</a> with the appropriate options, such as "select" for the columns to include (the projection), "sort_by" to specify row ordering, and "where" to do filtering. These options correspond fairly directly to the SQL operation that must be done on the underlying database, with the returned <a class="el" href="classIIterator.html">IIterator</a> being a cursor on the query results.<p>
For each database row returned by this <a class="el" href="classIIterator.html">IIterator</a>, you get back an <a class="el" href="classINode.html">INode</a> containing data of the table's columns for that row. The <a class="el" href="classINode.html#a9">INode::Walk()</a> method is used to retrieve the desired column data by name.<p>
Each of the pieces of data associated with a row and column is provided through the <a class="el" href="classIDatum.html">IDatum</a> interface. You will usually access that data through <a class="el" href="classIDatum.html#a9">IDatum::Value()</a> to retain type information.<p>
Note that at each of these levels in the database other secondary interfaces are often implemented. For example, tables should always try to implement <a class="el" href="classITable.html">ITable</a> to provide some more efficient mechanisms for modifying and watching their contents. Tables also usually implement <a class="el" href="classINode.html">INode</a> to be able to associate a MIME type and other meta-data with the table, and if there is a known key column associated with the table the <a class="el" href="classINode.html">INode</a> may also allow you to Walk() to single rows in the table using that column as a name.<p>
Rows usually implement <a class="el" href="classIIterable.html">IIterable</a> for you to be able to step through all of the contents of a row, looking very much like a directory in a filesystem. The IDatums under the row, however, usually don't implement <a class="el" href="classINode.html">INode</a> because there is no specific meta-data associated with them.<h2><a class="anchor" name="DataModelClients">
Data Model Clients</a></h2>
Clients of the data model interfaces should work through the <a class="el" href="classSNode.html">SNode</a>, <a class="el" href="classSIterator.html">SIterator</a>, and <a class="el" href="classSDatum.html">SDatum</a> classes for ease of use.<p>
One of the most common places you come in contact with the data model interfaces is in the <a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a>, usually accessed through an <a class="el" href="classSContext.html">SContext</a> object. While this class has some conveniences for doing common operations on the namespace, you can also use <a class="el" href="classSContext.html#a19">SContext::Root()</a> to directly access the <a class="el" href="classINode.html">INode</a> that provides the root of its namespace.<h2><a class="anchor" name="DetailedTopics">
Detailed Topics</a></h2>
<h3><a class="anchor" name="NamingEntries">
Naming Entries</a></h3>
The introduction of meta-data begs the question of how you walk to those entries. The meta-data formally exists under each <a class="el" href="classINode.html">INode</a> as a separate node called ":", so you can ls that node just like any other node:<p>
<div class="fragment"><pre class="fragment">$ ls img.png/:
mimeType
creationDate
modifiedDate
</pre></div><p>
And you can get to individual pieces of meta-data simply by walking through the attributes nod:<p>
<div class="fragment"><pre class="fragment">$ cat img.png/:/mimeType
vnd.palm.catalog/vnd.palm.plain
</pre></div><p>
As a convenience, we specify that the ':' at the front of a path name is a special identifier for the attributes namespace, so you can also treat it is an entry at the same level as the <a class="el" href="classINode.html">INode</a> it is associated with:<p>
<div class="fragment"><pre class="fragment">$ cat img.png/:mimeType
vnd.palm.catalog/vnd.palm.plain
</pre></div><p>
This is how you will normally access attributes, and it is important to allow this so that these attributes can be accessed at the same level as the normal catalog entries. For example, consider accessing different pieces of data in the 'font' service:<p>
<div class="fragment"><pre class="fragment">$ cat services/font/value
Some text

$ cat services/font/:mimeType
vnd.palm.catalog/vnd.palm.plain
</pre></div><p>
However other operations besides Walk() do not expose the meta-data:<p>
<div class="fragment"><pre class="fragment">$ ls services/font
value
items

$ ls services/font/:
mimeType
creationDate
modifiedDate
</pre></div><h3><a class="anchor" name="EntriesAndIdentity">
Entries and Identity</a></h3>
The things inside of a node are called entries. Each entry consists of one or more Binder interfaces, representing the capabilities of that entry. The node will pick one of these Binder interfaces to be the identity of the entry. When the node returns that entry, it returns the <a class="el" href="classIBinder.html">IBinder</a> for that selected identity interface.<p>
Data model objects must obey the rule of identity persistence. This says that if a client requests an entry and keeps a <em>strong</em> reference on it, then later requests the same entry again, the <a class="el" href="classIBinder.html">IBinder</a> of the first and second requests will be the same. If, however, the entry in the node has changed between the first and second requests, then the interface must return a different <a class="el" href="classIBinder.html">IBinder</a> for that entry. (If the data inside the entry changes, it is still the same entry, and thus the identity must persist.) Of course, if a client releases all references on an entry, what it will receive next time is completely undefined (it must be this way since it is undefined by the underlying Binder object model as well).<p>
It is important to state this rule explicitly because many data model implementations will manage their entries in special ways. Consider, for example, a directory on a file system. In general there will not be one object created up-front for every entry in the underlying file system directory. Instead, the directory node will construct objects for individual entries in the file system on demand, destroying them later when all clients have finished using them. A node is free to manage entries however it wants – creating and destroying actual <a class="el" href="classINode.html">INode</a> and <a class="el" href="classIDatum.html">IDatum</a> objects as needed – as long as it publicly obeys entry identity persistence.<p>
One other implication to be aware of is that holding a <em>weak</em> pointer on a namespace object may not behave as you expect. For example, trying to promote that to a strong pointer may fail even though an attempt to re-retrieve the same object would still succeed. This is to allow node implementation to dynamically construct objects on demand, meaning those constructed objects may be destroyed after all strong references on them are released.<h3><a class="anchor" name="WhereAreTheFiles">
Where Are the Files?</a></h3>
A question that comes up in this namespace is "how do I know whether some entry is a file?" Because it is possible to have entries that are both a datum and a node, it isn't at all clear how you know whether a particular entry you are looking at should be considered a file. A good example to make this more concrete is implementing a file browser: if you are showing the user a list of entries in a node and they click on an entry that is both a datum and a node, do you open the datum or dig down into the node?<p>
For this purpose our definition of a file is "any entry that is a datum". Thus you will always open an entry if it allows that. This definition implies that datums will tend to appear toward the leaves of the namespace; a datum that appears closer to the root of the namespace will tend to hide any node beyond it.<p>
At some point in the future we may introduce facilities to map actions to mimeTypes, so that you could retrieve the mimeType of the object you have and determine from that whether you should open its data or dig further into its node.<h3><a class="anchor" name="DatumConsiderations">
Datum Considerations</a></h3>
It is very important that, in the formal data model, every piece of data in the namespace has an object behind it – this object serves as the identity of that data, through which you can grant access to other entities in the system, perform monitoring operations, etc. Simply enforcing this as the only way to access data, however, would have a significant performance impact: every access to a data entry would involve transferring new object to the client, followed by a second IPC to retrieve the data.<p>
To address this, a client may ask an <a class="el" href="classINode.html">INode</a> or <a class="el" href="classIIterable.html">IIterable</a> to directly return the contents of an entry's <a class="el" href="classIDatum.html">IDatum</a> as an <a class="el" href="classSValue.html">SValue</a>, skipping the intermediate <a class="el" href="classIDatum.html">IDatum</a> object altogether. This facility makes it much more practical to interact with small pieces of data (file attributes, individual items in schema databases, data in the settings catalog, etc) through the standard namespace.<p>
A node is not required to provide this direct data mechanism – any client making use of it must be able to deal with receipt of an <a class="el" href="classIDatum.html">IDatum</a> object and retrieving the actual data through that. An individual node may even have different behavior for each entry – for example, a file system may allow you to directly retrieve the data of files less than 512 bytes, but always return datums for files larger than that. This direct data access is purely an optimization hint that the client makes at the time of the request.<p>
The <a class="el" href="classSDatum.html#z118_1">SDatum::FetchValue()</a> and <a class="el" href="classSDatum.html#z118_0">SDatum::FetchTruncatedValue()</a> are very important conveniences for clients wanting to make use of this optimization.<p>
A similar facility is available for dealing with nodes. When iterating you can request that sub-nodes be collapsed into value mappings in the returned iterator. This is a very useful optimization for example when using a node to populate a list view, where the list view needs to know certain entries from each sub-node to populate the data in its rows. As with datums, this optimization is entirely optional and the caller needs to deal gracefully with situations when it doesn't happen.<p>
The <a class="el" href="classSNode.html">SNode</a> class provides conveniences for dealing with node collapsing.<h3><a class="anchor" name="IDatumOrSValue">
IDatum or SValue?</a></h3>
At their core, the <a class="el" href="classIDatum.html">IDatum</a> and <a class="el" href="classSValue.html">SValue</a> express a similar concept: a typed piece of data. Ignoring the slightly different coating, what is the difference between these? Do we really need both of them?<p>
The key thing to understand about these two APIs is their semantic usage. An <a class="el" href="classSValue.html">SValue</a> is an anonymous blob of data. You generally pass it by value (each thing effectively has its own copy of the data), and there is no dentity attached to an <a class="el" href="classSValue.html">SValue</a> beyond the very primitive concept of a C++ "pointer to an object".<p>
An <a class="el" href="classIDatum.html">IDatum</a>, in contrast, blatantly carries an identity. It is a Binder object, meaning that it has a very well-defined identity that can be carried across processes. Because of this, it is always passed by reference – if you give a <a class="el" href="classIDatum.html">IDatum</a> to someone else and they modify what they got, you will see those changes as well . This implies that the datum API must provide reasonable support for multithreaded accesses, where-as the <a class="el" href="classSValue.html">SValue</a> API is fundamentally not thread-safe.<p>
Another way to look at this is that an <a class="el" href="classSValue.html">SValue</a> is a raw piece of data, and an <a class="el" href="classIDatum.html">IDatum</a> wraps up an <a class="el" href="classSValue.html">SValue</a> in a Binder interface (plus other facilities more appropriate for dealing with larger streams of data). <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:33 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
