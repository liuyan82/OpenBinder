<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder Inspect() Details</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderInspect">Binder Inspect() Details</a></h1><center>&lt; <a class="el" href="pidgen.html">pidgen</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="StorageKit.html">Storage Kit</a> &gt;</center> <hr>
<p>
The <a class="el" href="classIBinder.html#a7">IBinder::Inspect()</a> API is the Binder's mechanism for performing interface casts. (If you are familiar with COM, this is similar to the IUnknown::QueryInterface() method found there.)<p>
Interfaces are identified by an <em>interface descriptor</em>. This is a string <a class="el" href="classSValue.html">SValue</a>, where the string is a unique name of that interface. We use Java-style naming conventions for interfaces to ensure they have unique names; all system-level interfaces are in the org.openbinder.* namespace, and all of our application-level interfaces should be in the com.palmsource.* namespace.<p>
You will not normally write these strings yourself. Instead, pidgen generates them for you from the IDL file. Given an interface IFoo, pidgen will generate a method IFoo::Descriptor() that returns the descriptor for that interface.<p>
<ul>
<li><a class="el" href="BinderInspect.html#CastingInterfaces">Casting Interfaces</a></li><li><a class="el" href="BinderInspect.html#ImplementingInterfaceCasts">Implementing Interface Casts</a></li><li><a class="el" href="BinderInspect.html#RestrictingInterfaceAccess">Restricting Interface Access</a></li></ul>
<h2><a class="anchor" name="CastingInterfaces">
Casting Interfaces</a></h2>
When working in C++, you will not normally call Inspect() yourself. Instead, you will use the template function <a class="el" href="group__CoreSupportBinder.html#ga16">interface_cast&lt;INTERFACE&gt;()</a>, which will call Inspect() for you and return the result as the requested C++ interface. For example:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classSValue.html">SValue</a> v;
<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> b;

<a class="code" href="classsptr.html">sptr&lt;IFoo&gt;</a> foo(interface_cast&lt;IFoo&gt;(v));
<a class="code" href="classsptr.html">sptr&lt;IFoo&gt;</a> foo(interface_cast&lt;IFoo&gt;(b));
</pre></div><p>
You can also call Inspect() yourself directly for special situations. The API is:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">virtual</span> <a class="code" href="classSValue.html">SValue</a>
Inspect(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a>&amp; caller,
        <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;which,
        uint32_t flags = 0);
</pre></div><p>
The <em>caller</em> is the <a class="el" href="classIBinder.html">IBinder</a> you are calling Inspect() on, <em>which</em> is the interface descriptor(s) you desire, and <em>flags</em> is currently not used (must always be 0).<p>
For example, here is a call to inspect to get the IView interface binder:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> origBinder;
<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> newBinder(origBinder-&gt;Inspect(origBinder, IView::Descriptor()));
</pre></div><p>
Like other places where we use <a class="el" href="classSValue.html">SValue</a> operations, the <em>which</em> parameter can also be a set of <a class="el" href="classSValue.html">SValue</a> mappings to retrieve multiple interfaces in one call, or B_WILD_VALUE to retrieve all interfaces. (Note that currently due to IPC limitations, in some cases B_WILD_VALUE will fail because it returns too many <a class="el" href="classIBinder.html">IBinder</a> objects.)<p>
Here is an example of retrieving two interfaces:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> origBinder;

<a class="code" href="classSValue.html">SValue</a> which(IView::Descriptor(), IView::Descriptor());
which.JoinItem(IViewManager::Descriptor(), IViewManager::Descriptor());
<a class="code" href="classSValue.html">SValue</a> result = origBinder-&gt;Inspect(origBinder, which);

<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> viewBinder(result[IView::Descriptor()].AsBinder());
<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> viewManagerBinder(result[IViewManager::Descriptor()].AsBinder());
</pre></div><p>
Note that for C++ programming this is not a very useful technique, since to get the C++ interface you still need to do <a class="el" href="group__CoreSupportBinder.html#ga16">interface_cast&lt;&gt;()</a>, which will itself do its own <a class="el" href="classIBinder.html#a7">IBinder::Inspect()</a> call. You can get around this using IFoo::AsInterfaceNoInspect(), but unless there is some very clear performance critical section for which it makes sense, you are best off just sticking with <a class="el" href="group__CoreSupportBinder.html#ga16">interface_cast&lt;&gt;()</a>.<h2><a class="anchor" name="ImplementingInterfaceCasts">
Implementing Interface Casts</a></h2>
With a binder object of only one interface, there is usually no need for you to do anything. Pidgen will generate for you a standard implementation of Inspect() in the BnFoo class, which returns the interface being implemented. By deriving from BnFoo as normal, you will get this implementation and everything will work as expected.<p>
When you implement an object with multiple interfaces, you will often need to allow the user to cast between them. By default you are not able to cast from one interface to another. To allow this, you need to re-implement Inspect() so that calling the method on one <a class="el" href="classIBinder.html">IBinder</a> will also return the information for the other interfaces.<p>
<dl compact><dt><b></b></dt><dd><em>C++ background: when writing an object with multiple interfaces, you have multiple <a class="el" href="classBBinder.html">BBinder</a> objects (via multiple inheritance), one for each of those interfaces. Each of these <a class="el" href="classBBinder.html">BBinder</a> objects has its own Inspect() method. If the deriving class does not itself implement Inspect(), then they remain separate, and a call to Inspect() on one will just use that one's original implementation.</em></dd></dl>
To implement Inspect(), all you need to do is merge the inspect result of all of your base classes. For example, here is the implementation from the Application Manager service, which implements both IApplication and IApplicationManager:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classSValue.html">SValue</a>
BApplicationManager::Inspect(
    <span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a>&amp; caller, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;which, uint32_t flags)
{
    <a class="code" href="classSValue.html">SValue</a> result(BnApplication::Inspect(caller, which, flags));
    result.<a class="code" href="classSValue.html#z177_8">Join</a>(BnApplicationManager::Inspect(caller, which, flags));
    <span class="keywordflow">return</span> result;
}
</pre></div><h2><a class="anchor" name="RestrictingInterfaceAccess">
Restricting Interface Access</a></h2>
Sometimes you want to restrict the ways the clients can cast between interfaces. For example, in the view hierarchy, a layout manager implements the interfaces IView, IViewParent, and IViewManager. We want to set these casting policies:<p>
<ul>
<li>IViewParent can only cast to itself (IViewParent).</li><li>IViewManager can cast to either itself or IViewParent.</li><li>IView can cast to itself, IViewManager, and IViewParent.</li></ul>
<p>
This essentially defines a hierarchy of capabilities  holding an IViewParent gives you no other capabilies, while an IView gives you access to all other view capabilities.<p>
In order to accomplish this, we need to look at the <em>caller</em> parameter of Inspect() to determine which interface the call is coming from, and use that to decide which of the base classes we will call. Here is an example implementation of BViewGroup::Inspect() that implements the casting policy described above:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classSValue.html">SValue</a>
BViewGroup::Inspect(
    <span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a>&amp; caller, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; v, uint32_t flags)
{
    <span class="comment">// Figure out which interfaces to inspect.</span>
    uint32_t which = 0;
    <span class="keywordflow">if</span> (caller == (BnViewParent*)<span class="keyword">this</span>) which |= 1;
    <span class="keywordflow">if</span> (caller == (BnViewManager*)<span class="keyword">this</span>) which |= 2|1;
    <span class="keywordflow">if</span> (caller == (BnView*)<span class="keyword">this</span>) which |= 4|2|1;

    <a class="code" href="classSValue.html">SValue</a> result;
    <span class="keywordflow">if</span> (which&amp;1) result.<a class="code" href="classSValue.html#z177_8">Join</a>(BnViewParent::Inspect(caller, v, flags));
    <span class="keywordflow">if</span> (which&amp;2) result.<a class="code" href="classSValue.html#z177_8">Join</a>(BnViewManager::Inspect(caller, v, flags));
    <span class="keywordflow">if</span> (which&amp;4) result.<a class="code" href="classSValue.html#z177_8">Join</a>(BnView::Inspect(caller, v, flags));

    <span class="keywordflow">return</span> result;
}
</pre></div><p>
One thing it is very important to note is that this implementation of Inspect() will only return results when the <em>caller</em> is one of the interfaces it provides. This is different than the default implementation, which will return the interface regardless of the caller  allowing casts to that interface from any other interface.<p>
Because of this difference in semantics, when you write a subclass that is implementing this kind of Inspect(), you should clearly document in the header file that you are doing and what casting rules it uses. Any subclass of your own class that wants to implement a new interface needs to know about your Inspect() implementation, so that it can call it correctly to implement its own desired casts.<p>
For example, BListView derives from BViewGroup and implements a new interface, IListView. It would like to allow casts from IListView to any of the BViewGroup interfaces. Just calling BViewGroup::Inspect() will not do this, because our implementation only allows casts from its known interfaces. Thus the implementation of BListView::Inspect() will look something like this:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classSValue.html">SValue</a>
BListView::Inspect(
    <span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a>&amp; caller, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;which, uint32_t flags)
{
    <a class="code" href="classSValue.html">SValue</a> result;

    <span class="comment">// IListView and IView get access to the IListView interface.</span>
    <span class="keywordflow">if</span> (caller == (BnListView*)<span class="keyword">this</span> || caller == (BnView*)<span class="keyword">this</span>)
        result.<a class="code" href="classSValue.html#z177_8">Join</a>(BnListView::Inspect(caller, which, flags));

    <span class="comment">// If inspecting from IListView, we give full access to the object &amp;mdash;</span>
    <span class="comment">// that is, the same permissions as if inspecting from IView.</span>
    <span class="keywordflow">if</span> (caller == (BnListView*)<span class="keyword">this</span>)
        result.<a class="code" href="classSValue.html#z177_8">Join</a>(BViewGroup::Inspect((BnView*)<span class="keyword">this</span>, which, flags));
    <span class="keywordflow">else</span>
        result.<a class="code" href="classSValue.html#z177_8">Join</a>(BViewGroup::Inspect(caller, which, flags));

    <span class="keywordflow">return</span> result;
}
</pre></div><p>
The trick here is that if the caller is inspecting from IListView, we call up to BViewGroup::Inspect() with the caller changed to the IView binder, so that it will return all interfaces. <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
