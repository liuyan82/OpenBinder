<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: BIndexedDataNode Class Reference</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1>BIndexedDataNode Class Reference<br>
<small>
[<a class="el" href="group__CoreSupportDataModel.html">Data Model</a>]</small>
</h1><!-- doxytag: class="BIndexedDataNode" --><!-- doxytag: inherits="BMetaDataNode,BIndexedIterable,SDatumGeneratorInt" --><code>#include &lt;<a class="el" href="IndexedDataNode_8h-source.html">storage/IndexedDataNode.h</a>&gt;</code>
<p>
<p>Inheritance diagram for BIndexedDataNode:
<p><center><img src="classBIndexedDataNode.png" usemap="#BIndexedDataNode_map" border="0" alt=""></center>
<map name="BIndexedDataNode_map">
<area href="classBMetaDataNode.html" alt="BMetaDataNode" shape="rect" coords="79,280,227,304">
<area href="classBIndexedIterable.html" alt="BIndexedIterable" shape="rect" coords="474,280,622,304">
<area href="classSDatumGeneratorInt.html" alt="SDatumGeneratorInt" shape="rect" coords="632,280,780,304">
<area href="classBGenericNode.html" alt="BGenericNode" shape="rect" coords="79,224,227,248">
<area href="classBGenericIterable.html" alt="BGenericIterable" shape="rect" coords="474,224,622,248">
<area href="classSAtom.html" alt="SAtom" shape="rect" coords="632,224,780,248">
<area href="classBnNode.html" alt="BnNode" shape="rect" coords="79,168,227,192">
<area href="classBnIterable.html" alt="BnIterable" shape="rect" coords="395,168,543,192">
<area href="classSSQLBuilder.html" alt="SSQLBuilder" shape="rect" coords="553,168,701,192">
<area href="classINode.html" alt="INode" shape="rect" coords="0,112,148,136">
<area href="classBBinder.html" alt="BBinder" shape="rect" coords="158,112,306,136">
<area href="classIIterable.html" alt="IIterable" shape="rect" coords="316,112,464,136">
<area href="classBBinder.html" alt="BBinder" shape="rect" coords="474,112,622,136">
<area href="classIInterface.html" alt="IInterface" shape="rect" coords="0,56,148,80">
<area href="classIBinder.html" alt="IBinder" shape="rect" coords="158,56,306,80">
<area href="classIInterface.html" alt="IInterface" shape="rect" coords="316,56,464,80">
<area href="classIBinder.html" alt="IBinder" shape="rect" coords="474,56,622,80">
<area href="classSAtom.html" alt="SAtom" shape="rect" coords="0,0,148,24">
<area href="classSAtom.html" alt="SAtom" shape="rect" coords="158,0,306,24">
<area href="classSAtom.html" alt="SAtom" shape="rect" coords="316,0,464,24">
<area href="classSAtom.html" alt="SAtom" shape="rect" coords="474,0,622,24">
<area href="classBIndexedTableNode_1_1RowNode.html" alt="BIndexedTableNode::RowNode" shape="rect" coords="237,392,385,416">
<area href="classBSchemaDatabaseNode.html" alt="BSchemaDatabaseNode" shape="rect" coords="395,392,543,416">
<area href="classBSchemaTableNode_1_1RowNode.html" alt="BSchemaTableNode::RowNode" shape="rect" coords="553,392,701,416">
<area href="classBStructuredNode.html" alt="BStructuredNode" shape="rect" coords="711,392,859,416">
</map>
<a href="classBIndexedDataNode-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
An implementation of <a class="el" href="classINode.html">INode</a> that holds an array of data, identified by index. 
<p>
The class derives from <a class="el" href="classBMetaDataNode.html">BMetaDataNode</a>, providing a more concrete implementation for nodes that hold an indexed array of simple data. It implements <a class="el" href="classBGenericNode.html#z57_3">BMetaDataNode::LookupEntry()</a> for you. It takes care of pushing the INode::NodeChanged and INode::EntryModified events, through use of <a class="el" href="classSDatumGeneratorInt.html#z39_0">SDatumGeneratorInt::ReportChangeAtLocked()</a>.<p>
The class derives from <a class="el" href="classBIndexedIterable.html">BIndexedIterable</a>, providing index-based iterators over the node data. It implements <a class="el" href="classBIndexedIterable.html#z65_3">BIndexedIterable::EntryAtLocked()</a> for you. It calls <a class="el" href="classBGenericIterable.html#z50_2">BGenericIterable::PushIteratorChangedLocked()</a> as needed when its data changes, through use of <a class="el" href="classSDatumGeneratorInt.html#z39_0">SDatumGeneratorInt::ReportChangeAtLocked()</a>.<p>
The class derives from <a class="el" href="classSDatumGeneratorInt.html">SDatumGeneratorInt</a> to assist in the implementation of <a class="el" href="classBMetaDataNode.html">BMetaDataNode</a> and <a class="el" href="classBIndexedIterable.html">BIndexedIterable</a>.<p>
You must still implement the methods <a class="el" href="classBIndexedIterable.html#z65_0">BIndexedIterable::CountEntriesLocked()</a>, <a class="el" href="classSDatumGeneratorInt.html#z39_6">SDatumGeneratorInt::ValueAtLocked()</a>, <a class="el" href="classSDatumGeneratorInt.html#z39_4">SDatumGeneratorInt::StoreValueAtLocked()</a>, and the new virtuals <a class="el" href="classBIndexedDataNode.html#z61_0">EntryIndexOfLocked()</a> and <a class="el" href="classBIndexedDataNode.html#z61_1">EntryNameAtLocked()</a>.
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Implementation</h2></td></tr>
<tr><td colspan="2">Provide default implementation based on new capabilities. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z60_0">AllowDataAtLocked</a> (size_t index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Control whether a client will receive data for <a class="el" href="classINode.html#w0w11">INode::REQUEST_DATA</a>.  <a href="#z60_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z60_1">EntryAtLocked</a> (const <a class="el" href="classsptr.html">sptr</a>&lt; IndexedIterator &gt; &amp;it, size_t index, uint32_t flags, <a class="el" href="classSValue.html">SValue</a> *<a class="el" href="TSD_8cpp.html#a1">key</a>, <a class="el" href="classSValue.html">SValue</a> *entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement using <a class="el" href="classBIndexedDataNode.html#z61_1">EntryNameAtLocked()</a> and <a class="el" href="classBIndexedDataNode.html#z60_2">FetchEntryAtLocked()</a>.  <a href="#z60_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z60_2">FetchEntryAtLocked</a> (size_t index, uint32_t flags, <a class="el" href="classSValue.html">SValue</a> *entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use <a class="el" href="classBIndexedDataNode.html#z62_2">ValueAtLocked()</a> to retrieve the entry and <a class="el" href="classSDatumGeneratorInt.html#z38_0">DatumAtLocked()</a> if <a class="el" href="classINode.html#w0w11">INode::REQUEST_DATA</a> is set.  <a href="#z60_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z60_3">LookupEntry</a> (const <a class="el" href="classSString.html">SString</a> &amp;entry, uint32_t flags, <a class="el" href="classSValue.html">SValue</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implement using <a class="el" href="classBIndexedDataNode.html#z61_0">EntryIndexOfLocked()</a> and <a class="el" href="classBIndexedDataNode.html#z60_2">FetchEntryAtLocked()</a>.  <a href="#z60_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z60_4">ReportChangeAtLocked</a> (size_t index, const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classIBinder.html">IBinder</a> &gt; &amp;editor, uint32_t changes, off_t start=-1, off_t length=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Also push INode::NodeChanged, INode::EntryModified, and IIterator::IteratorChanged events.  <a href="#z60_4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Bookkeeping</h2></td></tr>
<tr><td colspan="2">Creation, destruction, locking, etc. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z59_0">BIndexedDataNode</a> (const <a class="el" href="classSContext.html">SContext</a> &amp;context, uint32_t mode=IDatum::READ_WRITE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z59_1">BIndexedDataNode</a> (uint32_t mode=IDatum::READ_WRITE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSContext.html">SContext</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z59_2">Context</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disambiguate.  <a href="#z59_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSValue.html">SValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z59_3">Inspect</a> (const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classIBinder.html">IBinder</a> &gt; &amp;caller, const <a class="el" href="classSValue.html">SValue</a> &amp;which, uint32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make both <a class="el" href="classINode.html">INode</a> and <a class="el" href="classIIterable.html">IIterable</a> accessible.  <a href="#z59_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structlock__status__t.html">lock_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z59_4">Lock</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disambiguate.  <a href="#z59_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z59_5">Unlock</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disambiguate.  <a href="#z59_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z59_6">~BIndexedDataNode</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Other Pure Virtuals</h2></td></tr>
<tr><td colspan="2">Purely informative definition of remaining pure virtuals from the base classes. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z62_0">CountEntriesLocked</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">From <a class="el" href="classBIndexedIterable.html#z65_0">BIndexedIterable::CountEntriesLocked()</a>.  <a href="#z62_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z62_1">StoreValueAtLocked</a> (size_t index, const <a class="el" href="classSValue.html">SValue</a> &amp;value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">From <a class="el" href="classSDatumGeneratorInt.html#z39_4">SDatumGeneratorInt::StoreValueAtLocked()</a>.  <a href="#z62_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSValue.html">SValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z62_2">ValueAtLocked</a> (size_t index) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">From <a class="el" href="classSDatumGeneratorInt.html#z39_6">SDatumGeneratorInt::ValueAtLocked()</a>.  <a href="#z62_2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>New Pure Virtuals</h2></td></tr>
<tr><td colspan="2">New virtuals that must be implemented by derived classes, to associated entry names with indices. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z61_0">EntryIndexOfLocked</a> (const <a class="el" href="classSString.html">SString</a> &amp;entry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index for an entry name in the node.  <a href="#z61_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSString.html">SString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBIndexedDataNode.html#z61_1">EntryNameAtLocked</a> (size_t index) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of an entry at a given index.  <a href="#z61_1"></a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="z59_1"></a><!-- doxytag: member="BIndexedDataNode::BIndexedDataNode" ref="z59_1" args="(uint32_t mode=IDatum::READ_WRITE)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classBIndexedDataNode.html">BIndexedDataNode</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em> = <code>IDatum::READ_WRITE</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z59_0"></a><!-- doxytag: member="BIndexedDataNode::BIndexedDataNode" ref="z59_0" args="(const SContext &amp;context, uint32_t mode=IDatum::READ_WRITE)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classBIndexedDataNode.html">BIndexedDataNode</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSContext.html">SContext</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>IDatum::READ_WRITE</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z59_6"></a><!-- doxytag: member="BIndexedDataNode::~BIndexedDataNode" ref="z59_6" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">~<a class="el" href="classBIndexedDataNode.html">BIndexedDataNode</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z60_0"></a><!-- doxytag: member="BIndexedDataNode::AllowDataAtLocked" ref="z60_0" args="(size_t index) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AllowDataAtLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Control whether a client will receive data for <a class="el" href="classINode.html#w0w11">INode::REQUEST_DATA</a>. 
<p>
The default implementation calls <a class="el" href="classSDatumGeneratorInt.html#z39_2">SizeAtLocked()</a> to disable data copying if the data size &gt; 2048. <dl compact><dt><b>Note:</b></dt><dd>If your data at an index is actually an object, <a class="el" href="classBIndexedDataNode.html#z60_0">AllowDataAtLocked()</a> <b>must</b> return true so that that object will be returned, not an <a class="el" href="classIDatum.html">IDatum</a> wrapping it. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z59_2"></a><!-- doxytag: member="BIndexedDataNode::Context" ref="z59_2" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSContext.html">SContext</a> Context           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disambiguate. 
<p>

<p>
Reimplemented in <a class="el" href="classBSchemaDatabaseNode.html#z6_3">BSchemaDatabaseNode</a>, and <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z29_3">BSchemaTableNode::RowNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z62_0"></a><!-- doxytag: member="BIndexedDataNode::CountEntriesLocked" ref="z62_0" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual size_t CountEntriesLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
From <a class="el" href="classBIndexedIterable.html#z65_0">BIndexedIterable::CountEntriesLocked()</a>. 
<p>

<p>
Implements <a class="el" href="classBIndexedIterable.html#z65_0">BIndexedIterable</a>.
<p>
Implemented in <a class="el" href="classBSchemaDatabaseNode.html#z7_0">BSchemaDatabaseNode</a>, <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z30_1">BSchemaTableNode::RowNode</a>, <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z81_0">BIndexedTableNode::RowNode</a>, and <a class="el" href="classBStructuredNode.html#z99_0">BStructuredNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z60_1"></a><!-- doxytag: member="BIndexedDataNode::EntryAtLocked" ref="z60_1" args="(const sptr&lt; IndexedIterator &gt; &amp;it, size_t index, uint32_t flags, SValue *key, SValue *entry)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> EntryAtLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classsptr.html">sptr</a>&lt; IndexedIterator &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSValue.html">SValue</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSValue.html">SValue</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implement using <a class="el" href="classBIndexedDataNode.html#z61_1">EntryNameAtLocked()</a> and <a class="el" href="classBIndexedDataNode.html#z60_2">FetchEntryAtLocked()</a>. 
<p>

<p>
Implements <a class="el" href="classBIndexedIterable.html#z65_3">BIndexedIterable</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z61_0"></a><!-- doxytag: member="BIndexedDataNode::EntryIndexOfLocked" ref="z61_0" args="(const SString &amp;entry) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual ssize_t EntryIndexOfLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSString.html">SString</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>entry</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the index for an entry name in the node. 
<p>
Return an error code if the lookup failed, usually B_ENTRY_NOT_FOUND. 
<p>
Implemented in <a class="el" href="classBSchemaDatabaseNode.html#z7_2">BSchemaDatabaseNode</a>, <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z30_4">BSchemaTableNode::RowNode</a>, <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z81_1">BIndexedTableNode::RowNode</a>, and <a class="el" href="classBStructuredNode.html#z99_1">BStructuredNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z61_1"></a><!-- doxytag: member="BIndexedDataNode::EntryNameAtLocked" ref="z61_1" args="(size_t index) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classSString.html">SString</a> EntryNameAtLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the name of an entry at a given index. 
<p>
This class guarantees it will not call this function with an invalid index. 
<p>
Implemented in <a class="el" href="classBSchemaDatabaseNode.html#z7_3">BSchemaDatabaseNode</a>, <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z30_5">BSchemaTableNode::RowNode</a>, <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z81_2">BIndexedTableNode::RowNode</a>, and <a class="el" href="classBStructuredNode.html#z99_2">BStructuredNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z60_2"></a><!-- doxytag: member="BIndexedDataNode::FetchEntryAtLocked" ref="z60_2" args="(size_t index, uint32_t flags, SValue *entry)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> FetchEntryAtLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSValue.html">SValue</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Use <a class="el" href="classBIndexedDataNode.html#z62_2">ValueAtLocked()</a> to retrieve the entry and <a class="el" href="classSDatumGeneratorInt.html#z38_0">DatumAtLocked()</a> if <a class="el" href="classINode.html#w0w11">INode::REQUEST_DATA</a> is set. 
<p>
Before retrieving the value, calls <a class="el" href="classBIndexedDataNode.html#z60_0">AllowDataAtLocked()</a>, to check if it is allowed to return a copy of the data (instead of an <a class="el" href="classIDatum.html">IDatum</a>) for this entry.     </td>
  </tr>
</table>
<a class="anchor" name="z59_3"></a><!-- doxytag: member="BIndexedDataNode::Inspect" ref="z59_3" args="(const sptr&lt; IBinder &gt; &amp;caller, const SValue &amp;which, uint32_t flags)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSValue.html">SValue</a> Inspect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classIBinder.html">IBinder</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>caller</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSValue.html">SValue</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make both <a class="el" href="classINode.html">INode</a> and <a class="el" href="classIIterable.html">IIterable</a> accessible. 
<p>

<p>
Reimplemented from <a class="el" href="classBnIterable.html#a0">BnIterable</a>.
<p>
Reimplemented in <a class="el" href="classBSchemaDatabaseNode.html#z6_4">BSchemaDatabaseNode</a>, and <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z29_7">BSchemaTableNode::RowNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z59_4"></a><!-- doxytag: member="BIndexedDataNode::Lock" ref="z59_4" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structlock__status__t.html">lock_status_t</a> Lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disambiguate. 
<p>

<p>
Reimplemented from <a class="el" href="classSDatumGeneratorInt.html#z37_0">SDatumGeneratorInt</a>.
<p>
Reimplemented in <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z29_0">BSchemaTableNode::RowNode</a>, and <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z80_0">BIndexedTableNode::RowNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z60_3"></a><!-- doxytag: member="BIndexedDataNode::LookupEntry" ref="z60_3" args="(const SString &amp;entry, uint32_t flags, SValue *node)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> LookupEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSString.html">SString</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSValue.html">SValue</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>node</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Implement using <a class="el" href="classBIndexedDataNode.html#z61_0">EntryIndexOfLocked()</a> and <a class="el" href="classBIndexedDataNode.html#z60_2">FetchEntryAtLocked()</a>. 
<p>

<p>
Implements <a class="el" href="classBGenericNode.html#z57_3">BGenericNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z60_4"></a><!-- doxytag: member="BIndexedDataNode::ReportChangeAtLocked" ref="z60_4" args="(size_t index, const sptr&lt; IBinder &gt; &amp;editor, uint32_t changes, off_t start=-1, off_t length=-1)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ReportChangeAtLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classIBinder.html">IBinder</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>editor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>changes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>off_t&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>off_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Also push INode::NodeChanged, INode::EntryModified, and IIterator::IteratorChanged events. 
<p>

<p>
Reimplemented from <a class="el" href="classSDatumGeneratorInt.html#z39_0">SDatumGeneratorInt</a>.
<p>
Reimplemented in <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z30_9">BSchemaTableNode::RowNode</a>, and <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z81_6">BIndexedTableNode::RowNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z62_1"></a><!-- doxytag: member="BIndexedDataNode::StoreValueAtLocked" ref="z62_1" args="(size_t index, const SValue &amp;value)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a> StoreValueAtLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSValue.html">SValue</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
From <a class="el" href="classSDatumGeneratorInt.html#z39_4">SDatumGeneratorInt::StoreValueAtLocked()</a>. 
<p>

<p>
Implements <a class="el" href="classSDatumGeneratorInt.html#z39_4">SDatumGeneratorInt</a>.
<p>
Implemented in <a class="el" href="classBSchemaDatabaseNode.html#z7_5">BSchemaDatabaseNode</a>, <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z30_13">BSchemaTableNode::RowNode</a>, <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z81_12">BIndexedTableNode::RowNode</a>, and <a class="el" href="classBStructuredNode.html#z100_0">BStructuredNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z59_5"></a><!-- doxytag: member="BIndexedDataNode::Unlock" ref="z59_5" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disambiguate. 
<p>

<p>
Reimplemented from <a class="el" href="classSDatumGeneratorInt.html#z37_3">SDatumGeneratorInt</a>.
<p>
Reimplemented in <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z29_2">BSchemaTableNode::RowNode</a>, and <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z80_2">BIndexedTableNode::RowNode</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z62_2"></a><!-- doxytag: member="BIndexedDataNode::ValueAtLocked" ref="z62_2" args="(size_t index) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classSValue.html">SValue</a> ValueAtLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
From <a class="el" href="classSDatumGeneratorInt.html#z39_6">SDatumGeneratorInt::ValueAtLocked()</a>. 
<p>

<p>
Implements <a class="el" href="classSDatumGeneratorInt.html#z39_6">SDatumGeneratorInt</a>.
<p>
Implemented in <a class="el" href="classBSchemaDatabaseNode.html#z7_8">BSchemaDatabaseNode</a>, <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z30_15">BSchemaTableNode::RowNode</a>, <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z81_14">BIndexedTableNode::RowNode</a>, and <a class="el" href="classBStructuredNode.html#z100_1">BStructuredNode</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="IndexedDataNode_8h-source.html">IndexedDataNode.h</a><li><a class="el" href="IndexedDataNode_8cpp.html">IndexedDataNode.cpp</a></ul>
<div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:30 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
