<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder Shell Data</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderShellData">Binder Shell Data</a></h1><center>&lt; <a class="el" href="BinderShellTutorial.html">Binder Shell Tutorial</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="BinderShellSyntax.html">Binder Shell Syntax</a> &gt;</center> <hr>
<p>
An important new feature of the Binder Shell is that all of its data operations make use of <a class="el" href="classSValue.html">SValue</a>. That is, all environment variables, command arguments, and command results are actually typed data.<p>
The default type the shell uses is a string (for POSIX compatibility), as can be seen here using the standard shell syntax of assigning a value to an environment variable:<p>
<div class="fragment"><pre class="fragment">/# S=foo
Result: "foo"
</pre></div><p>
There is also an extension to the POSIX shell syntax, <code>@{ ... }</code>, that allows you to construct values of specific types using the underlying <a class="el" href="classSValue.html">SValue</a> APIs. Unless otherwise specified, the data inside of the braces will be interpreted as an integer, float, boolean, or string:<p>
<div class="fragment"><pre class="fragment">/# I=@{1}
Result: int32_t(1 or 0x1)

/# I=@{[abcd]}
Result: int32_t(1633837924 or 0x61626364)

/# F=@{1.0}
Result: float(1.0)

/# B=@{false}
Result: false

/# B=@{true}
Result: true

/# S=@{"1"}
Result: "1"

/# S=@{foo}
Result: "foo"
</pre></div><p>
You can also use conversion operators to generate some additional types or convert existing variables to another type:<p>
<div class="fragment"><pre class="fragment">/# I64=@{ (int64_t)10 }
Result: int64_t(10 or 0xa)

/# T=@{ (nsecs_t)123456 }
Result: nsecs_t(123us 456ns or 0x1e240)

/# B=@{ (bool)$I64 }
Result: true

/# I=@{ (int32_t)$B }
Result: int32_t(1 or 0x1)

/# S=@{ (string)$I }
Result: "1"

/# S=@{ (string)$B }
Result: "true"
</pre></div><p>
A value can also contain a complex mapping of other values. Such mappings (and sets) are constructed with the <code>-&gt;</code> and <code>,</code> operators:<p>
<div class="fragment"><pre class="fragment">/# M=@{ a -&gt; b }
Result: "a" -&gt; "b"

/# S=@{ a, b }
Result: {
	"a",
	"b"
}

/# M2=@{ $M, c -&gt; d }
Result: {
	"a" -&gt; "b",
	"c" -&gt; "d"
}
</pre></div><p>
There are three types of operations that can be used to build values containing multiple mappings. A join is created with the <code>,</code> or <code>+</code> operator, which you have already seen. It is non-destructive  the result contains all data supplied on both sides of the join.<p>
<div class="fragment"><pre class="fragment">/# M=@{ a-&gt;b, a-&gt;c }
Result: "a" -&gt; {
	"b",
	"c"
}
</pre></div><p>
An overlay operation is performed with the <code>+&lt;</code> operator. It is like a join, except that it selects items on the right side when the same key appears on both the left and right sides. In other words, it replaces values on the left with values on the right, leaving the left side as-is when there is nothing on the right.<p>
<div class="fragment"><pre class="fragment">/# M=@{ {a-&gt;b,c-&gt;d} +&lt; {a-&gt;e,f-&gt;g} }
Result: {
	"a" -&gt; "e",
	"c" -&gt; "d",
	"f" -&gt; "g"
}
</pre></div><p>
An inherit operation is performed with the <code>+&gt;</code> operator. It is the opposite of an overlay, selecting values on the left side instead of the right.<p>
<div class="fragment"><pre class="fragment">/# M=@{ {a-&gt;b,c-&gt;d} +&gt; {a-&gt;e,f-&gt;g} }
Result: {
	"a" -&gt; "b",
	"c" -&gt; "d",
	"f" -&gt; "g"
}
</pre></div><p>
You can use the <code>[]</code> operator to look up a value from a mapping key:<p>
<div class="fragment"><pre class="fragment">/# M=@{ a -&gt; b + c -&gt; d }
Result: {
	"a" -&gt; "b",
	"c" -&gt; "d"
}

/# V=@{ $M[c] }
Result: "d"
</pre></div><p>
There are three special types of values with different semantics than normal types, especially when used in mappings. The <code>undefined</code> value is the state of a variable that has not been set; trying to create a mapping from some value to <code>undefined</code> will result in <code>undefined:</code> <p>
<div class="fragment"><pre class="fragment">/# U=@{undef}
Result: undefined

/# M=@{ a -&gt; undef }
Result: undefined

/# M=@{ undef -&gt; a }
Result: undefined
</pre></div><p>
The <code>wild</code> value is one that means "everything." In fact, every value you build is a mapping; a value containing a single data item is really the mapping <code>{ wild -&gt; value }</code>, but the leading <code>wild</code> is dropped for convenience. This allows us to create a consistent set of mapping operations on values, which are well-defined regardless of the contents of the values.<p>
<div class="fragment"><pre class="fragment">/# W=@{wild}
Result: wild

/# M=@{ wild -&gt; a }
Result: "a"

/# M=@{ a -&gt; wild }
Result: "a" -&gt; wild
</pre></div><p>
The <code>null</code> value means "not specified" or "empty". It is different than undefined in that it has no special significance in terms of mappings, however it does have special meaning when marshalling and unmarshalling across Binder calls  it specifies that the default parameter value should be used.<p>
<div class="fragment"><pre class="fragment">/# N=@{null}
Result: null

/# M=@{ null -&gt; a }
Result: null -&gt; "a"

/# M=@{ a -&gt; null }
Result: "a" -&gt; null
</pre></div> <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
