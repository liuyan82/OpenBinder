<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Threading Conventions</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderThreading">Threading Conventions</a></h1><div class="header"> <center>&lt; <a class="el" href="APIConventions.html">API Conventions</a> | <a class="el" href="main.html#OpenBinder">OpenBinder</a> | <a class="el" href="EnvironmentVars.html">Environment Variables</a> &gt;</center> <hr>
 </div><p>
The Binder is designed to enable rich multithreaded programming. It does not, however, define a concrete threading model itself; instead, it serves as a generic framework and toolkit through which specific threading policies can be implemented. This document will look at the basic Binder threading features and how to use them to solve specific problems.<p>
<ol type=1>
<li><a class="el" href="BinderThreading.html#BinderThreadingModel">Binder Threading Model</a><ol type=a>
<li><a class="el" href="BinderThreading.html#BinderThreadingSafety">What Is Thread Safe?</a><ol type=i>
<li><a class="el" href="BinderThreading.html#BinderThreadingGlobalSafety">Global (or Class) Safety</a></li><li><a class="el" href="BinderThreading.html#BinderThreadingInstanceSafety">Instance Safety</a></li><li><a class="el" href="BinderThreading.html#BinderThreadingInterfaceSafety">Interface Safety</a></li></ol>
</li><li><a class="el" href="BinderThreading.html#BinderThreadingManaging">Managing Threads</a><ol type=i>
<li><a class="el" href="BinderThreading.html#BinderThreadingSHandler">SHandler</a></li><li><a class="el" href="BinderThreading.html#BinderThreadingSThread">SThread</a></li></ol>
</li><li><a class="el" href="BinderThreading.html#BinderThreadingSynchronization">Synchronization</a></li></ol>
</li><li><a class="el" href="BinderThreading.html#BinderThreadingSystemPolicies">System Locking Policies</a><ol type=a>
<li><a class="el" href="BinderThreading.html#BinderThreadingFineGrained">Fine-Grained Locking</a><ol type=i>
<li><a class="el" href="BinderThreading.html#BinderThreadingBasicLocking">Protect Critical Sections With Locks</a></li><li><a class="el" href="BinderThreading.html#BinderThreadingCopyTypes">Copy Types</a></li><li><a class="el" href="BinderThreading.html#BinderThreadingReferenceCounting">Use Reference Counting</a></li></ol>
</li><li><a class="el" href="BinderThreading.html#BinderThreadingRelease">Release Locks When Calling Out</a></li><li><a class="el" href="BinderThreading.html#BinderThreadingSubclass">Subclass Complications</a></li><li><a class="el" href="BinderThreading.html#BinderThreadingView">More on threading and the view hierarchy</a></li></ol>
</li></ol>
<h2><a class="anchor" name="BinderThreadingModel">
Binder Threading Model</a></h2>
The only threading model that the Binder provides is what would be called "free threading" in COM. That is, individual threads are free to call across Binder objects as needed. The threading policies are defined entirely by what thread calls where when; the Binder is simply a mechanism to allow them to do what they want.<p>
This threading model extends across processes, where the Binder makes operations on remote objects look almost exactly like a call on to a local object  as if the thread had moved into the process of the other object, executed there, and then returned with the result. For example, when you call into a remote object, the thread in the remote process executing your call will have the same priority as your own thread. (See <a class="el" href="BinderProcessModel.html">Binder Process Model</a> for more detail on how the Binder manages processes.)<p>
For the developer this means that, without any additional constraints, all Binder objects must be able to deal with any arbitrary threads calling their API at any time. You must take care of correctly locking your state and serializing operations where appropriate. In general application developers can use whatever locking policy they would like; system developers should follow the system locking policies (described below) which are designed to allow this flexibility for developers and help us avoid deadlocks in system code.<h3><a class="anchor" name="BinderThreadingSafety">
What Is Thread Safe?</a></h3>
When using an API with multiple threads, it is essential to know which parts of it are thread safe and in what way. There are three broad categories of thread safety that we use. Starting from the least thread safe to the most, here are the kinds of classes and functions you will deal with:<h4><a class="anchor" name="BinderThreadingGlobalSafety">
Global (or Class) Safety</a></h4>
This is a class or function that makes sure to protect any of its global state. For example, in the Binder, two threads can be using two <em>different</em> instances of the <a class="el" href="classSString.html">SString</a> class, and we guarantee that no normal operation of one thread will disrupt the operation of the other. The guarantee is made even though <a class="el" href="classSString.html">SString</a> uses copy-on-write, so two threads could be sharing the same data buffer  the implementation ensures that with normal use of the <a class="el" href="classSString.html">SString</a> API this sharing will not cause problems between threads.<p>
<b>Every API in the Binder is at <em>least</em> globally safe.</b> You do not need to worry about two threads using the same class, as long as they are using different instances of the class.<h4><a class="anchor" name="BinderThreadingInstanceSafety">
Instance Safety</a></h4>
There are two broad types of classes in the Binder: those that protect their instance data from multiple threads using it at the same time, and those that don't.<p>
For the most part, this aspect of a class corresponds directly to the memory management of the class  almost all classes that are reference counted are thread safe, while almost all classes that are not reference counted are not thread safe.<p>
In other words, basic types that are passed by value (such as <a class="el" href="classSString.html">SString</a>, <a class="el" href="classSValue.html">SValue</a>, <a class="el" href="classSVector.html">SVector</a>, and <a class="el" href="classSMessage.html">SMessage</a>) are not thread safe. Sharing such classes between threads will require that you either implement the thread safety yourself (through your own lock, probably protecting other member variables in your class as well), or give the threads two different copies of the same object. Note that the latter is often a quite practical solution, since for many reasons these types of classes are designed to be cheap to copy, so they will often end up simply referring to the same underlying data when you make a copy.<p>
Classes that are reference counted  usually easy to determine because they derive from <a class="el" href="classSAtom.html">SAtom</a> or occasionally <a class="el" href="classSLightAtom.html">SLightAtom</a>  are almost always thread safe. This is not surprising, because one of the reasons to do reference counting is to make it much easier to manage memory between multiple threads. Examples of such classes are <a class="el" href="classBBinder.html">BBinder</a>, <a class="el" href="classBStreamDatum.html">BStreamDatum</a>, and <a class="el" href="classSHandler.html">SHandler</a>.<p>
There are some exceptions to these rules, and when that happens the exception will be explicitly noted by the class. This means that, except were explicitly called out, any class whose prefix is "B" or "I" will be thread safe (since all such classes must be reference counted via <a class="el" href="classSAtom.html">SAtom</a>), while classes that begin with "S" may or may not be thread safe depending on the above discussion.<h4><a class="anchor" name="BinderThreadingInterfaceSafety">
Interface Safety</a></h4>
A final kind of safety is interface thread safety. It is possible to have a class that is internally thread safe, but whose interface is not thread safe. A good example of this is the <a class="el" href="classIByteInput.html">IByteInput</a>, <a class="el" href="classIByteOutput.html">IByteOutput</a>, and <a class="el" href="classIByteSeekable.html">IByteSeekable</a> interfaces. Consider the complete API that these interfaces define:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">virtual</span> ssize_t     ReadV(<span class="keyword">const</span> iovec *vector, ssize_t count, uint32_t flags = 0);
<span class="keyword">virtual</span> ssize_t     WriteV(<span class="keyword">const</span> iovec *vector, ssize_t count, uint32_t flags = 0);
<span class="keyword">virtual</span> off_t       Position() <span class="keyword">const</span>;
<span class="keyword">virtual</span> off_t       Seek(off_t position, uint32_t seek_mode);
</pre></div><p>
An implementation of this API may be entirely thread safe, such that if one thread is calling ReadV() at the same time as another thread is calling WriteV(), they will not corrupt the state of the class. Note, however, that what one thread does has unintended side-effects (by changing the current stream position) that can break the behavior of the other thread.<p>
For example, if one thread is calling the byte stream interfaces like this:<p>
<div class="fragment"><pre class="fragment">stream-&gt;Seek(0, SEEK_SET);
stream-&gt;Read(&amp;vec, 1);
</pre></div><p>
Another thread could call Seek(0, SEEK_END) between those two statements, causing the first thread to do the wrong thing.<p>
As a contrast, the <a class="el" href="classIStorage.html">IStorage</a> interface represents an alternative API that allows you to do the same thing as byte streams, but in a thread safe way:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">virtual</span> off_t       Size() <span class="keyword">const</span>;
<span class="keyword">virtual</span> <a class="code" href="group__Core.html#ga0">status_t</a>    SetSize(off_t size);

<span class="keyword">virtual</span> ssize_t     ReadAtV(off_t position, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *vector, ssize_t count);
<span class="keyword">virtual</span> ssize_t     WriteAtV(off_t position, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *vector, ssize_t count);
</pre></div><p>
In general, all Binder interfaces are designed to be thread safe, and it is important for that to be the case. There are a few exceptions to this rule (byte streams and <a class="el" href="classIIterable.html">IIterable</a> being the most significant), which will be explicitly called out.<h3><a class="anchor" name="BinderThreadingManaging">
Managing Threads</a></h3>
So what thread is your code running in? Generally, this is not something you care about. The Binder maintains a pool of threads per process, which it uses to dispatch operations. These threads will call into your object as needed; they are managed as anonymous units of execution, with no identity of their own.<p>
Some of the frameworks built on top of the Binder impose particular threading models. For example, the <a class="el" href="classBSerialObserver.html">BSerialObserver</a> object ensures that all calls to its Observed() are serialized. Even here, however, there is not a particular thread dedicated to executing these functions; instead the class uses a Binder facility called <a class="el" href="classSHandler.html">SHandler</a> to pull threads out of the thread pool in the desired way.<h4><a class="anchor" name="BinderThreadingSHandler">
SHandler</a></h4>
The page <a class="el" href="SHandlerPatterns.html">SHandler Patterns</a> describes uses of <a class="el" href="classSHandler.html">SHandler</a> in fair detail. This class is the primary mechanism used in Binder programming to manage threads. Because it uses threads from the Bindrer thread pool instead of having its own dedicated thread, it is a very light-weight threading mechanism that is useful for a wide variety of threading needs.<h4><a class="anchor" name="BinderThreadingSThread">
SThread</a></h4>
<a class="el" href="classSThread.html">SThread</a> is a more traditional threading class. It is basically an object wrapper around a traditional kernel thread. After creating an <a class="el" href="classSThread.html">SThread</a> instance and calling <a class="el" href="classSThread.html#a1">SThread::Run()</a> on it, the class will make a new dedicated thread for it. You must implement a subclass of <a class="el" href="classSThread.html">SThread</a> that implements <a class="el" href="classSThread.html#b2">SThread::ThreadEntry()</a> to provide the code its thread should run.<p>
You should rarely use <a class="el" href="classSThread.html">SThread</a>, preferring instead the much lighter-weight <a class="el" href="classSHandler.html">SHandler</a>. The main place where <a class="el" href="classSThread.html">SThread</a> is used is for creating threads that will do blocking IO operations  for example the threads that read events from the keyboard and pen devices. In this case it is better to have a dedicated thread blocked in the IO call, rather then pulling a thread out of the thread pool only to have it sit blocked for an arbitrary amount of time.<h3><a class="anchor" name="BinderThreadingSynchronization">
Synchronization</a></h3>
The two main classes the Binder provides for synchronization are <a class="el" href="classSLocker.html">SLocker</a> (a mutex) and <a class="el" href="classSConditionVariable.html">SConditionVariable</a>. These are built on top of the kernel's critical section and condition variable primitives, respectively, and inherit all of their features: a kernel call not required when no blocking happens, they very light-weight (4 bytes per instance), etc.<p>
The class you will use the most, usually to protect your own class's state variables, is <a class="el" href="classSLocker.html">SLocker</a>. The system APIs are designed to not enforce any particular locking regimen, except that in most cases you will be multithreaded and so need to use locks to protect yourself. Thus the approach you want to take to locking is mostly up to you, and can be as simple as a big global lock.<p>
One of the main difficulties of multithreaded programming is the creation of deadlocks, and this is something you must be aware of whenever using these synchronization primitives. You can read <a href="http://en.wikipedia.org/wiki/Deadlock">http://en.wikipedia.org/wiki/Deadlock</a> to learn more about deadlocks if you don't already understand what they are.<p>
To assist in dealing with deadlocks, the <a class="el" href="classSLocker.html">SLocker</a> class includes a "potention deadlock" detection mechanism, described more in the <a class="el" href="SupportKit.html#SLockerSummary">SLocker summary</a> text.<h2><a class="anchor" name="BinderThreadingSystemPolicies">
System Locking Policies</a></h2>
In order for code to be thread safe, it must acquire locks while manipulating its state or performing calls on other objects that must be correctly ordered. This must be done in a way that ensures multiple threads will not cause destructive interference with each other (modifying the same program state in a way that interfers with another thread, a.k.a. a race condition) while at the same time making sure that the way it uses locks to protect itself will not lead to deadlocks.<p>
In general the way to avoid race conditions are simple to understand: just don't let two threads touch the same state at the same time.<p>
Deadlocks, however, are more complicated, because they usually arise from unexpected interactions across independent system components. Thus we need to set some policies and techniques in place to avoid them. This section describes a lot of the techniques we use inside of the Binder to deal with locking. One of the goals of our approach is to allow clients to use whatever locking policy of their own that they would like. Thus you can ignore this if you are writing application-level code that others won't use; however, system-level code that will be supplied to other developers should try to use the locking approach described here.<p>
In the specific case we are concerned with here, a deadlock happens when different threads are acquiring <em>multiple</em> locks (usually our <a class="el" href="classSLocker.html">SLocker</a> class) in ways that can result in deadlocks. In general the best way to avoid this kind of deadlock is to carefully control the order of these nested locks: that is, if some thread acquires lock A and while holding that then acquires lock B, if no other thread will first acquire B and then while holding B acquire A, then we are guaranteed there will be no deadlock between those two specific locks.<p>
So to ensure we have no deadlocks in our system, we must ensure that there is no possible combination of any locks in the system that will be acquired in different orders. For a system as complicated as ours, it is impossible to go through and analyize all of the combination of locks and understand their acquisition order. Instead, we define a set of locking policies for when you can hold locks that, if followed, will result in a system with no deadlocks.<p>
These locking policies are also intended to allow, as much as possible, flexibility for clients of our APIs to use whatever locking policy of their own that may be most convenient.<h3><a class="anchor" name="BinderThreadingFineGrained">
Fine-Grained Locking</a></h3>
The most common locking policy we have in the system is something called fine-grained locking. What this means is that a particular lock generally protects only a few pieces of information, the goal being that the implementation only needs to hold the lock for brief periods of time and thus has a clear idea of the scope of that lock.<p>
This policy is enabled by the <a class="el" href="classSLocker.html">SLocker</a> class (or in fact the critical section kernel primitive it uses), which allows us to have extremely lightweight mutex locks: only 4 bytes per lock. In practice each time you write a new class, you will include a new <a class="el" href="classSLocker.html">SLocker</a> in it to protect your new state. (Resulting in multiple SLockers per object, matching the depth of its inheritance hierarchy.) For example, consider someone implementing this interface:<p>
<div class="fragment"><pre class="fragment">interface IPerson
{
properties:
    <a class="code" href="classSString.html">SString</a> <a class="code" href="TSD_8cpp.html#a2">name</a>;
    IPerson bestFriend;
    [readonly]int32_t age;
    [readonly]<span class="keywordtype">float</span> height;

methods:
    DoBirthday();
}
</pre></div><p>
A class implementating the interface could protect its state with a lock like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Person : <span class="keyword">public</span> BnPerson
{
<span class="keyword">public</span>:
    <a class="code" href="classSString.html">SString</a> Name()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        <span class="keywordflow">return</span> m_name;
    }

    <span class="keywordtype">void</span> SetName(<span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp; value)
    {
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        m_name = value;
    }

    <a class="code" href="classsptr.html">sptr&lt;IPerson&gt;</a> BestFriend()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        <span class="keywordflow">return</span> m_bestFriend.promote();
    }

    <span class="keywordtype">void</span> SetBestFriend(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IPerson&gt;</a>&amp; bestFriend)
    {
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        m_bestFriend = bestFriend;
    }

    int32_t Age()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        <span class="keywordflow">return</span> m_age;
    }

    <span class="keywordtype">float</span> Height()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        <span class="keywordflow">return</span> m_height;
    }

    <span class="keywordtype">void</span> DoBirthday()
    {
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        m_age++;
        <span class="keywordflow">if</span> (m_age &lt; 16) m_height += 10;
    }


<span class="keyword">private</span>:
    <span class="keyword">mutable</span> <a class="code" href="classSLocker.html">SLocker</a> m_lock;

    <a class="code" href="classSString.html">SString</a> m_name;
    <a class="code" href="classwptr.html">wptr&lt;IPerson&gt;</a> m_bestFriend;
    int32_t m_age;
    <span class="keywordtype">float</span> m_height;
};
</pre></div><p>
This implementation demonstrates a lot of very common patterns we use with the Binder to deal with threading issues.<h4><a class="anchor" name="BinderThreadingBasicLocking">
Protect Critical Sections With Locks</a></h4>
The implementation of DoBirthday() represents a fairly traditional multithreading technique, where one needs to atomically modify two variables. To make sure this is thread safe, we hold our lock while executing the code, to ensure that only one thread at a time can be accessing those variables.<p>
Also note the use of the lock when modifying and retrieving m_name  in general the implementation of classes that begin with the 'S' prefix are <em>not</em> thread safe (they do not have their own lock), so you must explicitly protect them yourself if you are using them in a Binder object or other multithreaded situation.<p>
<dl compact><dt><b>Note:</b></dt><dd>The example code here does not need to acquire m_lock in its Age() and Height() methods. This is because int32_t and float are 4-byte types, which on ARM can be read from memory atomically. This is a useful optimization to know, but in general it is best to be safe and acquire your lock whenever in doubt.</dd></dl>
<h4><a class="anchor" name="BinderThreadingCopyTypes">
Copy Types</a></h4>
The Name() method returns the current name of the object. In order to avoid exposing our lock to the public, we return a <em>copy</em> of the name. That way we only need to hold our internal lock when copying the string; once we have a copy, we know there is only one thread (our own) with access to the copy, so we can safely return it to the caller without our lock held.<p>
This locking technique requires that it be relatively cheap to make copies of type classes. For simple types (such as SPoint, SRect, or SColor32) that is naturally the case; however, more often a type object may have a significant amount of data associated with it so making a copy can become a fairly heavy-weight operation.<p>
Any type class in the Binder system that does not naturally have a cheap copy operation will use some form of "copy-on-write" semantics to provide a cheap copy. Examples of classes that do this are <a class="el" href="classSString.html">SString</a>, <a class="el" href="classSValue.html">SValue</a>, and SGlyphMap. You can easily implement your own copy-on-write class using the <a class="el" href="classSSharedBuffer.html">SSharedBuffer</a> utility object.<h4><a class="anchor" name="BinderThreadingReferenceCounting">
Use Reference Counting</a></h4>
The BestFriend() method gives us another approach to dealing with return values. Here we explicitly want to return the object itself, and not just a copy. For this kind of situation, we use reference counting on the object.<p>
Any class that derives from <a class="el" href="classSAtom.html">SAtom</a> (including all classes with the 'I' and 'B' prefix) will be reference counted. The sptr and wptr templates work like plain C++ pointers, but automatically hold a reference on the object for us. Since sptr and wptr don't have their own lock, we need to protect access to them like we did with the <a class="el" href="classSString.html">SString</a> above.<p>
In this case, however, the 'type' sptr is simply holding a reference count on some other object. Once we make a copy of that type and thus have our own sptr on the same object (here obtained with the <a class="el" href="classwptr.html#a8">wptr::promote()</a> call), we can safely return that to the caller without holding our lock.<p>
One other thing that is worth noting here is the use of a wptr member variable to hold the bestFriend property. A wptr holds a weak reference, meaning the target object is allowed to be destroyed even while there are still such references on it. This is done so that, for example, if two IPerson objects were each their own best friends, we would not create a cycle in the reference counts  if nobody else is holding on to one of those objects, we allow it to be destroyed even if the other has a bestFriend pointer to it.<h3><a class="anchor" name="BinderThreadingRelease">
Release Locks When Calling Out</a></h3>
Never hold a lock when calling into user code. This rule protects against many protential deadlocks.<p>
Here is an example that comes up frequently: it okay to hold a lock when calling AddView(), RemoveView(), etc. This is because the implementation of those methods only holds the view's lock while manipulating some internal state. Most of the work of actually adding and removing the view  such as calling its Layout() method and having it calculate its constraints and draw  is performed asynchronously from the AddView() call. This is a powerful technique to avoid the need to hold locks when calling other code, which is described in more detail in <a class="el" href="SHandlerPatterns.html">SHandler Patterns</a>.<p>
The key to this is knowing where your code sits in the layering of the system. Another way of phrasing the rule is "never hold a lock when calling in to higher-level code." Here are some examples of how the system is layered:<p>
<ul>
<li>Kits/libraries are layered on top of each other. For example, the View Kit sits on top of the Render Kit. This means that it is always okay for code in the View Kit to call any Render Kit API while it is holding one of its locks. Not allowing a lower-level kit to see the APIs of a higher-level kit is an easy way to enforce this rule.</li></ul>
<p>
<ul>
<li>Subclasses are layered on top of their base classes. For example, when MyView derives from BView, MyView is higher-level code than BView. This means it is okay for MyView to call BView APIs with locks held, while the code in BView must never be holding a lock when it calls a virtual that a derived class can override. (There is a contradiction here, that we'll talk about later.)</li></ul>
<p>
<ul>
<li>Child views are layered on top of their parents. This means the child is free to call any APIs on IViewParent while holding its locks, but a parent must not make calls to its children's IView API while it holds any of its own locks.</li></ul>
<p>
<ul>
<li>Clients are layered on top of services. Thus it is okay for clients to hold locks while calling the service, but the service must not be holding a lock when calling back to client code.</li></ul>
<h3><a class="anchor" name="BinderThreadingSubclass">
Subclass Complications</a></h3>
Recall that we mentioned there being a contradiction in the definition of when it is okay for subclasses to hold locks. This is because there are really two kinds of subclasses:<p>
<ul>
<li><em>Leaf classes</em> are generally part of an application and not a shared library. No (unknown) classes will further derive from them, so they get to define the final threading semantics to be whatever they want. If they want to have one big lock that is held whenever their code in the view is doing stuff (including calling virtuals), that is okay.</li></ul>
<p>
<ul>
<li><em>System classes</em> are generally included in a shared library, and as such need to allow any arbitrary developer to create a subclass of them. In this case calling virtual function must be considered the case of calling into user code, because a deriving class can override any of those functions. If at all possible, you must avoid holding locks while calling virtuals; if you can't avoid it, this absolutely must be documented in class's API.</li></ul>
<p>
In other words, top-level clients are still allowed to use whatever locking approach they want, as we mentioned earlier. However, if you are writing a class that other people will be using (one that is part of a system shared library), then you should follow the rule and not hold locks when calling virtuals.<h3><a class="anchor" name="BinderThreadingView">
More on threading and the view hierarchy</a></h3>
First, re-read the section <a class="el" href="BinderThreading.html#BinderThreadingRelease">Release Locks When Calling Out</a>. The view hierarchy goes to great lengths to follow these rules. When you read comments like "we can't call IView::TakeFocus() with the lock held", this is exactly because of the rules given above. (In this case, TakeFocus() is a call down to children views, which you cannot do with the lock held. However, you can make calls up to your parent view with your lock held.) Generally the view hierarchy is very much about either going up or going down, but not doing both at the same time. When going up or going down the locking rules must be followed.<h2><a class="anchor" name="BinderThreadingDesigning">
Designing For Thread Safety</a></h2>
<h3><a class="anchor" name="BinderThreadingAPISafety">
API Thread Safety</a></h3>
<dl compact><dt><b><a class="el" href="todo.html#_todo000046">Todo:</a></b></dt><dd>Talk about examples such as IViewManager and <a class="el" href="classSVector.html">SVector</a>, byte streams and <a class="el" href="classIDatum.html#a3">IDatum::Open()</a> and <a class="el" href="classIStorage.html">IStorage</a>, <a class="el" href="classIIterator.html">IIterator</a> and <a class="el" href="classIIterable.html#a1">IIterable::NewIterator()</a>. </dd></dl>
<div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
