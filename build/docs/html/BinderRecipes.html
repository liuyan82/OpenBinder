<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder Recipes</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderRecipes">Binder Recipes</a></h1><div class="header"> <center>&lt; <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="BinderShellTutorial.html">Binder Shell Tutorial</a> &gt;</center> <hr>
 </div><p>
This page provides simple recipes for common things you will do with the Binder. These serve as a good first look at what it is like to use the Binder's C++ APIs.<p>
<ol type=1>
<li><a class="el" href="BinderRecipes.html#CallBinderService">Calling a Binder Service</a></li><li><a class="el" href="BinderRecipes.html#WritingBinderObject">Writing a Binder Object</a></li><li><a class="el" href="BinderRecipes.html#GivingBinderObject">Giving a Binder Object to a Service</a></li><li><a class="el" href="BinderRecipes.html#CreatingComponent">Creating a Component</a></li></ol>
<h2><a class="anchor" name="CallBinderService">
Calling a Binder Service</a></h2>
The first thing you will usually want to do is call on to an existing Binder <a class="el" href="BinderTerminology.html#ServiceDefn">Service</a>. In this example, we will use the Informant service to broadcast a message to others who may be interested.<h3><a class="anchor" name="UsingBinderInterface">
Using a Binder Interface</a></h3>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Informant_8h.html">services/Informant.h</a>&gt;</span>
</pre></div><p>
Binder interfaces are described through IDL, and the <a class="el" href="pidgen.html">pidgen</a> tool used used to convert them to a C++ API. To use an interface, you will need to include the C++ header that pidgen generated.<p>
The Informant interface is located at "interfaces/services/IInformant.idl", so the header you need to include is "services/IInformant.h".<h3><a class="anchor" name="ContactService">
Contact the Service</a></h3>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> informantBinder
    = Context().LookupService(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"informant"</span>));
</pre></div><p>
Every Binder object is associated with an <a class="el" href="classSContext.html">SContext</a>, which is your global connection with the rest of the system. All Binder objects have <a class="el" href="classBBinder.html">BBinder</a> as a base class, so from the code inside your object you can retrieve your context through the <a class="el" href="classBBinder.html#a3">BBinder::Context()</a> API.<p>
The <a class="el" href="classSContext.html">SContext</a> class includes various methods for making use of the information in the context. Here, we use <a class="el" href="classSContext.html#a4">SContext::LookupService()</a> to retrieve, by name, a reference on a service that was previously published. The object we get back is a pointer to an <a class="el" href="classIBinder.html">IBinder</a>, which is the abstract interface to any <a class="el" href="BinderTerminology.html#BinderObjectDefn">Binder Object</a>.<p>
Note the use of <code><a class="el" href="classsptr.html">sptr&lt;IBinder&gt;</a></code> instead of a raw C++ pointer. You should always use <a class="el" href="classsptr.html">sptr</a>&lt;&gt; (or <a class="el" href="classwptr.html">wptr</a>&lt;&gt;) when working with Binder objects, because they are reference counted and these classes will automatically hold a reference on the object for you.<h3><a class="anchor" name="GetBinderInterface">
Get a Binder Interface</a></h3>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IInformant&gt;</a> informant
    = interface_cast&lt;IInformant&gt;(informantBinder);
</pre></div><p>
The <a class="el" href="group__CoreSupportBinder.html#ga17">interface_cast</a>&lt;&gt; method finds an IDL <a class="el" href="BinderTerminology.html#InterfaceDefn">Interface</a> associated with a Binder object. In this case we are looking for the <a class="el" href="classIInformant.html">IInformant</a> interface. This is conceptually the same as QueryInterface() in COM. In the Binder, it asks the object whether it supports that interface and for the <a class="el" href="classIBinder.html">IBinder</a> associated with it, and returns the C++ interface requested. If the object is not in the local process, a proxy is created for it and returned.<p>
The result of <a class="el" href="group__CoreSupportBinder.html#ga17">interface_cast</a>&lt;&gt; is a <a class="el" href="classsptr.html">sptr</a>&lt;&gt; to the requested C++ interface or NULL if the object does ot implement that interface.<h3><a class="anchor" name="CallBinderObject">
Call the Binder Object</a></h3>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (informant != <a class="code" href="group__Core.html#ga75">NULL</a>) {
    informant-&gt;Inform(  <a class="code" href="classSValue.html#z174_14">SValue::String</a>(<span class="stringliteral">"myMessage"</span>),
                        SValue::String(<span class="stringliteral">"myData"</span>) );
}
</pre></div><p>
We now have a fully functional C++ interface. It is pointing to the actual target object if this is a local C++ class, or a proxy object to the implementation if it is somewhere else.<p>
In either case, we can make calls on the interface just like on a local C++ class. The object will stay around as long as we hold a sptr&lt;&gt; referencing the interface.<p>
In this case, we will call the <a class="el" href="classIInformant.html#a0">IInformant::Inform()</a> method to broadcast a notification. The two arguments supply the information to be broadcast, which is a Binder type called an <a class="el" href="classSValue.html">SValue</a>. This is like a variant in COM or GValue in GLib: it carries a type as well as data, for dynamic typing. Here we are supplying two SValues holding string data, giving the message name and data to send.<h3><a class="anchor" name="AlternativeContactService">
Alternative to Contact the Service</a></h3>
Sometimes you are not a Binder object, but have some other code that needs to make use of the Binder. In this case, you need a way to get an <a class="el" href="classSContext.html">SContext</a> object through which you can find other Binder objects. This can be done through the <a class="el" href="classSContext.html#e3">SContext::UserContext()</a> API.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classSContext.html">SContext</a> context = <a class="code" href="classSContext.html#e3">SContext::UserContext</a>();
    
<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> informantBinder =
    context.<a class="code" href="classSContext.html#a4">LookupService</a>(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"informant"</span>));
</pre></div><p>
Note that <a class="el" href="classSContext.html#e3">SContext::UserContext()</a> should only be used when you don't otherwise have an <a class="el" href="classSContext.html">SContext</a> available through <a class="el" href="classBBinder.html">BBinder</a> or some other facility. You will normally want to use the <a class="el" href="classSContext.html">SContext</a> that was provided to you, since your caller may have customized it in some way.<h3><a class="anchor" name="CallExample">
Complete Example: Calling a Binder Service</a></h3>
To review, here is our complete example of calling a Binder service:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Informant_8h.html">services/Informant.h</a>&gt;</span>

<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> informantBinder
    = Context().LookupService(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"informant"</span>));

<a class="code" href="classsptr.html">sptr&lt;IInformant&gt;</a> informant
    = interface_cast&lt;IInformant&gt;(informantBinder);

<span class="keywordflow">if</span> (informant != <a class="code" href="group__Core.html#ga75">NULL</a>) {
    informant-&gt;Inform(  SValue::String(<span class="stringliteral">"myMessage"</span>),
                        SValue::String(<span class="stringliteral">"myData"</span>) );
}
</pre></div><h2><a class="anchor" name="WritingBinderObject">
Writing a Binder Object</a></h2>
We are now going to look at what you do to write your own Binder object that others can call.<h3><a class="anchor" name="ImplementingBinderInterface">
Implementing a Binder Interface</a></h3>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="IInformant_8h.html">services/IInformant.h</a>&gt;</span>
</pre></div><p>
The interface we are going to implement is <a class="el" href="classIInformed.html">IInformed</a>, a part of the Informant service, and so defined in the same file "services/IInformant.h" we saw above. The <a class="el" href="classIInformed.html">IInformed</a> interface is the recipient of a message broadcast through <a class="el" href="classIInformant.html">IInformant</a>.<p>
<dl compact><dt><b></b></dt><dd><em>Note that another common way to broadcast information is through a Binder <a class="el" href="BinderTerminology.html#LinkDefn">Link</a>, which allows you to declare properties and events on an interface that can be monitored by other objects. See <a class="el" href="BinderShellTutorial.html#ShellLinks">Links</a> for an example.</em></dd></dl>
<h3><a class="anchor" name="DefineObjectClass">
Define the Object Class</a></h3>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyWatcher : <span class="keyword">public</span> <a class="code" href="classBnInformed.html">BnInformed</a>, <span class="keyword">public</span> <a class="code" href="classSPackageSptr.html">SPackageSptr</a>
{
<span class="keyword">public</span>:
</pre></div><p>
MyWatcher is the class we are implementing.<p>
The <a class="el" href="classBnInformed.html">BnInformed</a> class is generated by <a class="el" href="pidgen.html">pidgen</a> from the <a class="el" href="classIInformed.html">IInformed</a> interface in the <code>IInformant.idl</code> file. <a class="el" href="classBnInformed.html">BnInformed</a> is a subclass of <a class="el" href="classIInformed.html">IInformed</a>, which provides the basic mechanism for implementing a concrete <a class="el" href="classIInformed.html">IInformed</a> class. In particular, it includes a <a class="el" href="classBBinder.html">BBinder</a> object: this gives you an <a class="el" href="classIBinder.html">IBinder</a> API that can be used by other languages and processes, and <a class="el" href="classBnInformed.html">BnInformed</a> implements the unmarshalling code to let those clients call your <a class="el" href="classIInformed.html">IInformed</a> implementation.<p>
The <a class="el" href="classSPackageSptr.html">SPackageSptr</a> class is a special part of the <a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a>. It is essentially a "strong pointer" to your code package, allowing it to monitor how your package is being used to ensure that your code stays loaded as long as it is needed. This also gives your implementation access to your associated <a class="el" href="classSPackage.html">SPackage</a> object, through which you can retrieve resources such as strings and bitmaps.<h3><a class="anchor" name="ImplementConstructor">
Implement Constructor</a></h3>
<div class="fragment"><pre class="fragment">    MyWatcher(<span class="keyword">const</span> <a class="code" href="classSContext.html">SContext</a>&amp; context)
        : <a class="code" href="classBnInformed.html">BnInformed</a>(context)
    {
    }
</pre></div><p>
This is a typical implementation of a Binder object's constructor. It takes the <a class="el" href="classSContext.html">SContext</a> that the object is being instantiated in, and hands that off to its base classes. Doing this allows it to later use <a class="el" href="classBBinder.html#a3">BBinder::Context()</a> to retrieve that context.<h3><a class="anchor" name="ImplementIInformedAPI">
Implement the IInformed API</a></h3>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> OnInform(  <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; information,
                    <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; cookie, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; <a class="code" href="TSD_8cpp.html#a1">key</a>)
    {
</pre></div><p>
<a class="el" href="classIInformed.html">IInformed</a> has a single method, <a class="el" href="classIInformed.html#a1">IInformed::OnInform()</a>. All methods and properties on an interface base class are pure virtuals, so you must implement them to have a concrete class that can be instantiated.<p>
We see <a class="el" href="classSValue.html">SValue</a>, our typed data container, here again as the arguments this method receives. In addition to simple typed data, an <a class="el" href="classSValue.html">SValue</a> can contain complex data structures and mappings of other SValues. This is a convenient facility to propagate whatever data we would like through the informant.<h3><a class="anchor" name="ImplementOnInform">
Implement OnInform() Method</a></h3>
<div class="fragment"><pre class="fragment">        <a class="code" href="group__CoreSupportDataModel.html#ga14">bout</a> &lt;&lt; <span class="stringliteral">"Got informed: "</span> &lt;&lt; information &lt;&lt; <a class="code" href="ITextStream_8h.html#a1">endl</a>;
    }
};
</pre></div><p>
Your implementation of an interface method can do whatever it wants, just like any other C++ class. In the implementation here, we are going to use a Binder formatted text output stream to print the arguments we received.<p>
The "bout" object is an <a class="el" href="classITextOutput.html">ITextOutput</a> stream that writes to the standard output stream. Most Binder objects (<a class="el" href="classSValue.html">SValue</a> here, and also <a class="el" href="classSString.html">SString</a>, <a class="el" href="classSMessage.html">SMessage</a>, etc) can be written as text to a text output stream like "bout". It is basically like the standard C++ output streams, but has some additional features for indentation, tagging lines, and managing the output of multiple concurrent threads. (See <a class="el" href="EnvironmentVars.html#TEXT_OUTPUT_FORMAT">TEXT_OUTPUT_FORMAT</a> for runtime options to control text stream output.)<h3><a class="anchor" name="WritingExample">
Complete Example: Writing a Binder Object</a></h3>
To review, here is our complete example of writing a Binder object<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Informant_8h.html">services/Informant.h</a>&gt;</span>

<span class="keyword">class </span>MyWatcher : <span class="keyword">public</span> <a class="code" href="classBnInformed.html">BnInformed</a>, <span class="keyword">public</span> <a class="code" href="classSPackageSptr.html">SPackageSptr</a>
{
<span class="keyword">public</span>:

    MyWatcher(<span class="keyword">const</span> <a class="code" href="classSContext.html">SContext</a>&amp; context)
        : <a class="code" href="classBnInformed.html">BnInformed</a>(context)
    {
    }

    <span class="keywordtype">void</span> OnInform(  <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; information,
                    <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; cookie, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; <a class="code" href="TSD_8cpp.html#a1">key</a>)
    {
        <a class="code" href="group__CoreSupportDataModel.html#ga14">bout</a> &lt;&lt; <span class="stringliteral">"Got informed: "</span> &lt;&lt; information &lt;&lt; <a class="code" href="ITextStream_8h.html#a1">endl</a>;
    }
};
</pre></div><h2><a class="anchor" name="GivingBinderObject">
Giving a Binder Object to a Service</a></h2>
A key aspect of the Binder is transfering object references between interfaces. When those interfaces are remote, this is how you set up communication paths between languages and processes  even though, to the client, all of the work necessary to do this is invisible.<h3><a class="anchor" name="GetInformantService">
Get the Informant Service</a></h3>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IInformant&gt;</a>  informant =
    interface_cast&lt;IInformant&gt;(
        Context().LookupService(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"informant"</span>)));
</pre></div><p>
Just like we saw in the first example, the first thing we need to do is retrieve the informant service. Note that error checking is only needed at the end  <a class="el" href="group__CoreSupportBinder.html#ga17">interface_cast</a>&lt;&gt; will gracefully propagate errors. Also, none of the Binder APIs currently use exceptions to propagate error conditions.<h3><a class="anchor" name="InstantiateBinderObject">
Instantiate New Binder Object</a></h3>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> informed = <span class="keyword">new</span> MyWatcher;
</pre></div><p>
Here we create a new instance of the MyWatcher class that was previously implemented.<p>
Note again the <a class="el" href="classsptr.html">sptr</a>&lt;&gt; smart pointer class. It will hold a reference on the object, and reference counting is designed so that we can directly assign a newly created object to a sptr&lt;&gt; without ever having to worry about reference counts.<p>
The pointer we have her could just as well have been a sptr&lt;MyWatcher&gt;, but all we need later on is the <a class="el" href="classIBinder.html">IBinder</a> class so that is what we decided to use.<h3><a class="anchor" name="GiveObjectInformant">
Give Object to Informant</a></h3>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (informant != <a class="code" href="group__Core.html#ga75">NULL</a> &amp;&amp; informed != <a class="code" href="group__Core.html#ga75">NULL</a>)
{
    informant-&gt;RegisterForCallback(
        SValue::String(<span class="stringliteral">"myMessage"</span>), informed,
        SValue::String(<span class="stringliteral">"OnInform"</span>));
}
</pre></div><p>
After doing the appropriate error checking, we will call the informant's <a class="el" href="classIInformant.html#a2">IInformant::RegisterForCallback()</a> API to give our object to it. At this point the informant now has a reference on MyWatcher, and if they are in different processes a remote connection has been established. The MyWatcher instance we created will remain around as long as the informant holds a reference on it.<p>
The <a class="el" href="classSValue.html#z174_14">SValue::String</a>("OnInform") parameter we pass in specifies the method for the informant to call. The informant uses the Binder's scripting protocol (which is a basic capability of any Binder object) to call any method on the <a class="el" href="classIBinder.html">IBinder</a> that was given to it. When it does this, your OnInform() method will execute just as it would if a C++ program had called it directly.<h3><a class="anchor" name="GivingExample">
Complete Example: Giving a Binder Object to a Service</a></h3>
To review, here is our complete example of giving a Binder object to a service.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="Informant_8h.html">services/Informant.h</a>&gt;</span>

<a class="code" href="classsptr.html">sptr&lt;IInformant&gt;</a>  informant =
    interface_cast&lt;IInformant&gt;(
        Context().LookupService(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"informant"</span>)));

<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> informed = <span class="keyword">new</span> MyWatcher;

<span class="keywordflow">if</span> (informant != <a class="code" href="group__Core.html#ga75">NULL</a> &amp;&amp; informed != <a class="code" href="group__Core.html#ga75">NULL</a>)
{
    informant-&gt;RegisterForCallback(
        SValue::String(<span class="stringliteral">"myMessage"</span>), informed,
        SValue::String(<span class="stringliteral">"OnInform"</span>));
}
</pre></div><h2><a class="anchor" name="CreatingComponent">
Creating a Component</a></h2>
Let's now turn the Binder object we wrote (MyWatcher) into a Binder <a class="el" href="BinderTerminology.html#ComponentDefn">Component</a>.<p>
A component is a Binder object that is published so that others can instantiate it, without having to link to its implementation. The <a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a> keeps track of all Binder components and the information needed to instantiate them.<p>
In addition to the MyWatcher implementation, there are two more things you need to add to turn it into a full Binder component:<p>
<ol type=1>
<li>A <code>Manifest.xml</code> file, an XML document that tells the package manager about your component.</li><li>An <code>InstantiateComponent()</code> function, the factory function that generates instances of your component.</li></ol>
<p>
In addition, we will need a Makefile that puts all of this stuff together into the appropriate package structure.<h3><a class="anchor" name="MyWatcherManifest">
MyWatcher's Manifest</a></h3>
The manifest for our component will be very simple:<p>
<div class="fragment"><pre class="fragment">&lt;manifest&gt;
	&lt;component&gt;
		&lt;interface name="org.openbinder.services.IInformed" /&gt;
	&lt;/component&gt;
&lt;/manifest&gt;
</pre></div><p>
This manifest says that there is a single component in the package, which implements the interface <code>org.openbinder.services.IInformed</code>. The name used to instantiate the component will simply be the package name itself, which we will define later in our Makefile.<h3><a class="anchor" name="FactoryFunction">
The Factory Function</a></h3>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="InstantiateComponent_8h.html">support/InstantiateComponent.h</a>&gt;</span>

<a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a>
InstantiateComponent(   <span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp; component,
                        <span class="keyword">const</span> <a class="code" href="classSContext.html">SContext</a>&amp; context,
                        <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;args)
{
</pre></div><p>
This is the function exported from your package, which the <a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a> calls when it needs to make a new instance of one of your components. Note that we include the "support/InstantiateComponent.h" header, which declares the <code>InstantiateComponent()</code> function so it will be properly exported.<p>
The <em>component</em> argument you receive is the <em>local</em> name of the desired component, that is the full component name with the package name at the beginning removed.<p>
The <em>context</em> argument is the Binder context the component is being instantiated in.<p>
The <em>args</em> are data to be supplied to the component constructor. That is, it will contain an <a class="el" href="classSValue.html">SValue</a> of key/value mapping pairs supplying the arguments.<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> (component == <span class="stringliteral">""</span>)
        <span class="keywordflow">return</span> static_cast&lt;BnInformed*&gt;(<span class="keyword">new</span> MyWatcher(context));
    <span class="keywordflow">return</span> <a class="code" href="group__Core.html#ga75">NULL</a>;
}
</pre></div><p>
Your implementation of <code>InstantiateComponent()</code> will need to look at the <em>component</em> argument to determine which component to instantiate. Here, we have only one component we have implemented. The component's name is the same as the package name, so the <em>component</em> argument here for that component will be ""  that is, there is no suffix beyond the base package name for the component.<p>
The standard C++ new operator is used to make a new instance of the component. Note that we pass the <em>context</em> to the MyWatcher class's constructor so it can later retrieve it through <a class="el" href="classBBinder.html#a3">BBinder::Context()</a> if needed.<p>
The cast here is used to select the default interface that is returned. In this case it is not actually needed, because we are only implementing a single interface.<p>
Note <a class="el" href="classsptr.html">sptr</a>&lt;&gt; again here, used implicitly due to the function return type, taking care of all reference counts for us.<p>
If the requested component is not one we implement (which shouldn't happen unless our manifest file is incorrect), we simply return NULL.<h3><a class="anchor" name="MyWatcherMakefile">
MyWatcher's Makefile</a></h3>
<div class="fragment"><pre class="fragment">LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)

BASE_PATH:= $(LOCAL_PATH)
PACKAGE_NAMESPACE:= org.openbinder.samples
PACKAGE_LEAF:= MyWatcher
SRC_FILES:= \
	MyWatcher.cpp

include $(BUILD_PACKAGE)
</pre></div><p>
This is an example of a Makefile that will use the OpenBinder build system to build the MyWatcher component into a Binder package. Note in particular the PACKAGE_NAMESPACE and PACKAGE_LEAF variables, which together set the base page name  in this case, <code>org.openbinder.samples.MyWatcher</code>.<p>
This Makefile will result in the creation of a directory <code>build/packages/org.openbinder.samples.MyWatcher</code> that contains:<p>
<ul>
<li><b>MyWatcher.so</b>  the code implementing the MyWatcher package.</li><li><b>Manifest.xml</b>  the Manifest.xml file described previously.</li></ul>
<p>
The Package Manager uses the directory name to infer the base name for your package.<h3><a class="anchor" name="InstantiatingMyWatcherComponent">
Instantiating a MyWatcher Component</a></h3>
Now that we have a component, we can use the <a class="el" href="classSContext.html#a6">SContext::New()</a> API to create an instance of it.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a>  informedBinder =
    Context().New(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"org.openbinder.samples.MyWatcher"</span>));
    
<a class="code" href="classsptr.html">sptr&lt;IInformed&gt;</a> informed =
    interface_cast&lt;IInformed&gt;(informedBinder);
</pre></div><p>
The result of <a class="el" href="classSContext.html#a6">SContext::New()</a> is an <a class="el" href="classIBinder.html">IBinder</a>, the Binder object of the newly instantiated component, which you can then cast to the desired interface.<p>
The above code can be done from any process. The component implementation will be loaded into the local process, if needed. In addition, the component can be implemented in another language or the system can decide it should be instantiated in a different process; in either case, proxies for IPC and/or marshalling will be created as needed, and you have no need to be aware that this has happened.<h3><a class="anchor" name="ObjectsComponents">
Objects vs. Components</a></h3>
Compare the previous code for directly instantiating a MyWatcher object:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> informed = <span class="keyword">new</span> MyWatcher;
</pre></div><p>
Using <a class="el" href="classSContext.html#a6">SContext::New()</a> gives you the same thing: it works and behaves just like a local object. However, you now don't have to know about the component implementation up-front (linking directly to a specific library implementing it), and <a class="el" href="classSContext.html#a6">SContext::New()</a> works across processes and languages.<p>
Note, however, that the following code is not possible with <a class="el" href="classSContext.html#a6">SContext::New()</a>:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;MyWatcher&gt;</a> informed = <span class="keyword">new</span> MyWatcher;
</pre></div><p>
In particular, though in some specific cases, the following may work (when the instantiated component is in the same process and language), this should not be done:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;MyWatcher&gt;</a> informed = dynamic_cast&lt;MyWatcher*&gt;(
    Context().New(<a class="code" href="SupportBuild_8h.html#a55">SString</a>(<span class="stringliteral">"org.openbinder.samples.MyWatcher"</span>)).ptr();
</pre></div> <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
