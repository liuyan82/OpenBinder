<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Missing Features</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="MissingFeatures">Missing Features</a></h1><div class="header"> <center>&lt; <a class="el" href="Authors.html">Authors</a> | <a class="el" href="main.html#OpenBinder">OpenBinder</a> | <a class="el" href="BringItOn.html">Bring It On</a> &gt;</center> <hr>
 </div><p>
This page provides information about major missing features from OpenBinder that most people will probably be interested in. For a full list of all things that need to be done, see the <a class="el" href="todo.html">cannonical to-do list</a>.<h2><a class="anchor" name="BinderShellEditing">
No Command Line Editing and History in Binder Shell</a></h2>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement command line history and editing in Binder Shell.</dd></dl>
One of the most annoying limitations right now is that the Binder shell doesn't have any support for command line editing.<p>
Unfortunately implementing this probably isn't as easy as just taking an existing package like readline, because it needs to sit on top of the binder IO streams (<a class="el" href="classIByteInput.html">IByteInput</a> and <a class="el" href="classIByteOutput.html">IByteOutput</a>) instead of raw system calls. A quick and dirty hack may be to add an API to get the tty for a stream that the package can then use if available... though there would be some nasty issues to deal with there around cross-process operation.<p>
A more complete design is probably to add a couple new interfaces:<p>
<ul>
<li>ITTY is an interface to a TTY device, providing things like information about the terminal dimensions, kind of device, etc. This would be a fairly direct mapping to a traditional tty device.</li><li>ITerminal is a higher-level interface for operating on a terminal device, with APIs like "MoveCursor()" and "DeleteLine()". This is the API the Binder Shell would use (if available) to implement command line editing. The normal output streams such as "bout" would also implement the ITTY interface, and the Binder Shell would create a standard translator object that provides an ITerminal on top of an ITTY+IByteOutput. Alternatively, a graphical terminal could supply its own ITerminal implementation without] having to deal with terminal command sequences.</li></ul>
<h2><a class="anchor" name="BinderShellHostAccess">
Binder Shell Doesn't Provide Host Access</a></h2>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement Binder Shell access to underlying host commands / filesystem.</dd></dl>
Currently the Binder Shell doesn't have facilities for directly running host commands or accessing the host filesystem.<p>
For host commands, this is mostly a matter if adding some code to SyntaxTree.cpp:SimpleCommand that, as a last resort, tries to find the command in $PATH and does a fork()/exec() to run it. The only tricky thing here is setting up the forked process's streams correctly for the current shell environment. (Ideally, we would want to have a way to get the underlying file descriptors of the current shell's IByteInput/IByteOutput to hand those off to the forked process... though it also needs to deal with the situation where those are not sitting on top of a file descriptor.)<p>
For the host filesystem, this should probably be done by implementing a <a class="el" href="BinderDataModel.html">Binder Data Model</a> layer on top of the filesystem. The main issues to deal with here are to decide how the Binder and host namespaces are merged, and an efficient way to transfer filesystem references between processes without doing an excessive amount of IPC. Ideally, it would be cool if we could transfer raw file descriptors between processes somewhere like Binder objects...<h2><a class="anchor" name="NoNetworkSupport">
No Network Support</a></h2>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement cross-network communicatiom support</dd></dl>
While the Binder is a distributed component model, communication across networks has not yet been implemented. This is because the focus of its development has been on system-level services, where communication across processes is the key feature. Adding network support should be relatively straight-forward, using the facilities such as marshalling/unmarshalling that are already present.<p>
The main issue will probably be in dealing with object identities, such as deciding how/if to deal with the case of an object reference being transfered from host A, to host B, to host C, and back to A.<h2><a class="anchor" name="NoObjectIntrospection">
No Object Introspection</a></h2>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement object introspection</dd></dl>
The Binder object API (<a class="el" href="classIBinder.html">IBinder</a>) provides a facility for finding the interfaces that an object implements, but there is currently no API to programmatically discover the methods, properties, and events on those interfaces. This should be fairly easy to add by defining a new API on <a class="el" href="classIBinder.html">IBinder</a> to retrieve this information (we want this tied to the <a class="el" href="classIBinder.html">IBinder</a> and not the interface because of the scripting nature of the binder protocol), and then with little work pidgen can use all of the information it is already generating to implement it. <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
