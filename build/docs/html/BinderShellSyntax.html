<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder Shell Syntax</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderShellSyntax">Binder Shell Syntax</a></h1><center>&lt; <a class="el" href="BinderShellData.html">Binder Shell Data</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="BinderTerminology.html">Binder Terminology</a> &gt;</center> <hr>
<p>
This page provides a more detailed reference on the syntax and capabilities of the Binder shell.<p>
The Binder Shell is a basic implementation of the POSIX shell syntax (spec at <a href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html">http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html</a>) with a few extensions. While it should be able to parse the full POSIX grammar correctly, there are a few features, most notably pipes, that aren't implemented yet.<p>
Besides these limitations, the shell provides the same general environment one expects from a POSIX shell:<p>
<div class="fragment"><pre class="fragment">variable="something"

if [ "$variable" -eq "something" ]
    echo "Variable is something"
else
    echo "Variable is something else"
fi
</pre></div><p>
For the rest of this document we will assume that you are already familiar (as much as you want to be) with POSIX shell syntax.<h2><a class="anchor" name="BinderShellExtensions">
Binder Shell Extensions</a></h2>
The Binder Shell introduces a few extensions to standard POSIX shell that make it much more useful in the Binder environment. Most of these are semantic changes, though there are a few important new grammatical constructs.<h3><a class="anchor" name="VariablesAreSValues">
All environment variables, command arguments, and return codes are SValues</a></h3>
This means that most data handled by the shell is typed, not just a simple string. The arguments to a function, its return code, and environment variables in the shell can contain strings, integers, flattened types (rect, point, etc), or even references to objects or complex mappings.<p>
As these values propagate between the command and the shell, their type is propagated as well. For example, if you have an environment variable <code>SOMETHING</code> that contains a reference to an <a class="el" href="classIBinder.html">IBinder</a> object, you can pass it to a function like a normal environment variable:<p>
<div class="fragment"><pre class="fragment">inspect $SOMETHING
</pre></div><p>
The second argument that the <code>inspect</code> command receives will be a <a class="el" href="classSValue.html">SValue</a> containing a pointer to the same binder. The command can similarly return a result <a class="el" href="classSValue.html">SValue</a> containing an object that the shell can use.<h3><a class="anchor" name="CommandResultSyntax">
New syntax $[cmd ...] for retrieving the result of a command</a></h3>
The standard POSIX shell defines the syntax <code>$(cmd ...)</code> to embed the output of a command into the place this construct appears. The Binder Shell adds a variant <code>$[cmd ...]</code>, which embeds the result of a command. Because command results are now an <a class="el" href="classSValue.html">SValue</a>, this allows you to propagate typed data through the shell.<p>
For example, there is a <code>lookup</code> command that returns the <a class="el" href="classSValue.html">SValue</a> of a particular property in the context. This can then be assigned to an environment variable:<p>
<div class="fragment"><pre class="fragment">SURFACE=$[lookup /services/surface]
</pre></div><p>
The environment variable can be passed to another command:<p>
<div class="fragment"><pre class="fragment">put $SURFACE show_updates true
</pre></div><p>
One could even write commands that take typed data as input and generate a typed result. For example, if we had two theoretical commands, rect and point, which generate SValues containing data of their respective types, we could write shell code like this:<p>
<div class="fragment"><pre class="fragment">RECT=$[rect 0 0 100 120]
POINT=$[point 10 10]

NEWRECT=$[rect_offset $RECT $POINT]
</pre></div><p>
Or even:<p>
<div class="fragment"><pre class="fragment">NEWRECT=$[rect_offset $RECT $[point 10 10]]
</pre></div><p>
This facility is used extensively by the standard commands for working with the Binder runtime, such as <code>new</code>, <code>new_process</code>, and <code>invoke</code>.<h3><a class="anchor" name="ComplexValueSyntax">
New syntax @{ key-&gt;value, ... } for building complex values</a></h3>
The Binder Shell also adds a new construct for conveniently building up basic <a class="el" href="classSValue.html">SValue</a> types. The text inside a <code>@{ ... }</code> section defines <a class="el" href="classSValue.html">SValue</a> mappings (separated by <code>-&gt;</code>) and sets (separated by <code>,</code>); a combination of both can be used to create multiple mappings. Some examples:<p>
<div class="fragment"><pre class="fragment">@{ data }                       # A simple string
@{ something, somethingelse }   # A set of strings
@{ param-&gt;value }               # A mapping
@{ {param-&gt;value}[param] }      # Lookup in a mapping
@{ param1-&gt;something,           # Multiple mappings
   param2-&gt;somethingelse }
@{ param1-&gt;{ value1, value2 } } # Mapping to a set
@{ param1-&gt;{ nested-&gt;value } }  # Mapping to a mapping
@{param1-&gt;{nested-&gt;value}}      # All spaces are optional and ignored
</pre></div><p>
Tokens inside of an <a class="el" href="classSValue.html">SValue</a> context are typed. If the token is all numbers, it is interpreted as an integer; if it is all numbers with a single period, it is a float; true and false are the corresponding boolean values; otherwise, it is a string:<p>
<div class="fragment"><pre class="fragment">@{ 1 }                          # An integer
@{ [abcd] }                     # An integer of ASCII characters
@{ 1.0 }                        # A float
@{ true }                       # Boolean truth
@{ 1-&gt;something }               # Integer mapped to string
</pre></div><p>
You can also explicitly specify the type of a token. If a token is enclosed in double quotes, it is always converted to a string. If you prefix it with (), you can force it to one of the fundamental types: (int32), (float), (string), (bool):<p>
<div class="fragment"><pre class="fragment">@{ "1" }                        # A string
@{ (string)1.0 }                # Also a string
@{ (int64_t)10 }                # A 64 bit integer
@{ (nsecs_t)123456 }            # A time
@{ (float)1 }                   # A floating point number
@{ (int32_t)$VAR }              # Cast to an integer
@{ (bool)1 }                    # Boolean truth
@{ "true" }                     # The string "true"
</pre></div><p>
Finally, environment variables and command results can be used as tokens:<p>
<div class="fragment"><pre class="fragment">$ SURFACE=$[lookup /services/surface]

$ M1=@{ 0-&gt;$SURFACE }           # Integer mapped to an object
$ M1=@{ 0-&gt;$[lookup /services/surface] }    # Equivalent
$ M2=@{ a-&gt;$M1, b-&gt;"foo" }      # Make set of mappings
$ M=@{ $M1 + $M2 }              # Combine the mappings
$ V=@{ $M[0] }                  # Look up a value in a mapping
</pre></div><p>
See <a class="el" href="BinderShellData.html">Binder Shell Data</a> for more examples.<h3><a class="anchor" name="FunctionInvocation">
Function invocation with $OBJECT.Function()</a></h3>
You can append a '.' to an environment variable name in order to perform a function invocation if that variable holds an object.<p>
<div class="fragment"><pre class="fragment">$ E=$[inspect /services/surface org.openbinder.services.IErrAlert]
$ RESULT=$E.ShowAlert("Alert text")
</pre></div><p>
The arguments are supplied as a comma-separated list, and are parsed as a normal command line: plain text will be interpreted as strings, you can use <code>$</code> for variables, <code>$[]</code> to run commands, <code>@{}</code> to build typed values, etc.<h3><a class="anchor" name="ForeachCommand">
New foreach control structure</a></h3>
In addition to the standard for control structures, the Binder Shell includes a <code>foreach</code> statement for operating on <a class="el" href="classIIterable.html">IIterable</a> and <a class="el" href="classIIterator.html">IIterator</a> objects, and <a class="el" href="classSValue.html">SValue</a> mappings. The general syntax is:<p>
<pre>
<b>foreach</b> [<em>key</em>] <em>value</em> [<b>in</b>|<b>over</b>] <em>data</em> [<em>data ...</em> ]; <b>do</b>
	<em>statements</em>
<b>done</b>
</pre><p>
If <em>key</em> is not specified, then <em>value</em> will contain <code>{key-&gt;value}</code> mappings for each item. The data items can be variables or other constructs.<p>
The <code>foreach ... in ...</code> form allows you to operate on iterators  the data you supply must be either an <a class="el" href="classIIterable.html">IIterable</a> or <a class="el" href="classIIterator.html">IIterator</a> object, or a path to an interable object in the namespace, or a mapping containing values that are iterables or paths. For example, to iterate over all items in <code>/services</code>, you would write this:<p>
<div class="fragment"><pre class="fragment">foreach key value in /services; do
    echo $key is $value
done
</pre></div><p>
Resulting in:<p>
<div class="fragment"><pre class="fragment">informant is SValue(sptr&lt;IBinder&gt;(0x80967c4 9Informant))
memory_dealer is SValue(sptr&lt;IBinder&gt;(0x8090f34 13BMemoryDealer))
tokens is SValue(sptr&lt;IBinder&gt;(0x809a13c 2TS))
</pre></div><p>
The <code>foreach ... over ...</code> form allows you to operate on value mappings  it will simply decompose the data into its separate mappings. For example:<p>
<div class="fragment"><pre class="fragment">foreach k v over @{0-&gt;1, 2-&gt;3, 1-&gt;a} string $[lookup /services/informant]; do
    echo $k is $v
done
</pre></div><p>
Results in:<p>
<div class="fragment"><pre class="fragment">0 is 1
1 is a
2 is 3
SValue(wild) is string
SValue(wild) is SValue(sptr&lt;IBinder&gt;(0x8096f74 9Informant))
</pre></div><p>
This is a good example of why <a class="el" href="classSValue.html">SValue</a> mappings are defined the way they are, where a simple value <code>V</code> is formally the mapping <code>{wild-&gt;V}</code>. Notice this coming into play for the last two items, which are not normally considered to be mappings.<p>
Also notice a special property of <a class="el" href="classSValue.html">SValue</a> ordering related to integers. The order that <a class="el" href="classSValue.html">SValue</a> holds its sets in is not defined to be anything useful, except in the case of integer keys: these will be in their natural order. This property is convenient in dealing with sets of mappings of integer keys representing arrays. <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
