<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: SHandler Patterns</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="SHandlerPatterns">SHandler Patterns</a></h1><div class="header"> <center>&lt; <a class="el" href="SAtomDebugging.html">SAtom Debugging</a> | <a class="el" href="SupportKit.html">Support Kit</a> | <a class="el" href="BinderKit.html">Binder Kit</a> &gt;</center> <hr>
 </div><p>
The Binder's <a class="el" href="classSHandler.html">SHandler</a> class is used extensively to control multithreading in the system. It is essentially a message queue, allowing you to place messages into the queue (by calling <a class="el" href="classSHandler.html#z122_3">SHandler::PostMessage()</a> et al) and to perform an action upon receiving that message (by overriding the <a class="el" href="classSHandler.html#z123_0">SHandler::HandleMessage()</a> method).<p>
Unlike a typical message queue, there is no thread dedicated to servicing a particular <a class="el" href="classSHandler.html">SHandler</a>. Instead, the Binder dispatches threads from its thread pool to <a class="el" href="classSHandler.html">SHandler</a> objects as needed. When doing this, it ensures that the SHandler's semantics are properly observed (only one message being executed at a time), but may use a different thread each time a message is processed.<p>
This design means that <a class="el" href="classSHandler.html">SHandler</a> is very light-weight  it is essentially a list of pending messages and little more. As such, it is common to just mix in a <a class="el" href="classSHandler.html">SHandler</a> object with a particular class whenever multithreading is needed. The flexible and light-weight nature of <a class="el" href="classSHandler.html">SHandler</a> make it a useful tool for solving a wide variety of multithreading and timing-related problems.<p>
<ol type=1>
<li><a class="el" href="SHandlerPatterns.html#Asynchronicity">Asynchronicity</a></li><li><a class="el" href="SHandlerPatterns.html#Serialization">Serialization</a></li><li><a class="el" href="SHandlerPatterns.html#Timeouts">Timeouts</a></li><li><a class="el" href="SHandlerPatterns.html#RepeatedEvents">Repeated Events</a></li></ol>
<h2><a class="anchor" name="Asynchronicity">
Asynchronicity</a></h2>
The basic use of <a class="el" href="classSHandler.html">SHandler</a> is to introduce asynchronicity into a code path. For example, you may be implementing a method that requires a significant amount of time to complete so want to return to the caller without waiting for the operation to be done. To solve this, you can simply mix a <a class="el" href="classSHandler.html">SHandler</a> in to your class and post a message to it. You can then immediately return to the caller, and do your work when you receive the message.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyCommand : <span class="keyword">public</span> <a class="code" href="classBCommand.html">BCommand</a>, <span class="keyword">public</span> <a class="code" href="classSHandler.html">SHandler</a>
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <a class="code" href="classSValue.html">SValue</a>          Run(<span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; args);

    <span class="keyword">virtual</span> <a class="code" href="group__Core.html#ga0">status_t</a>        HandleMessage(<span class="keyword">const</span> <a class="code" href="classSMessage.html">SMessage</a> &amp;msg);

    ...
}

<a class="code" href="classSValue.html">SValue</a> <a class="code" href="classBCommand.html#a23">MyCommand::Run</a>(<span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; args)
{
    <span class="comment">// Create a message.  The data will be set to</span>
    <span class="comment">// our incoming arguments.</span>
    <a class="code" href="classSMessage.html">SMessage</a> msg('doit');
    msg.SetData(args);

    <span class="comment">// Post the message in our handler to be processed later.</span>
    <a class="code" href="group__Core.html#ga0">status_t</a> err = PostMessage(msg);

    <span class="comment">// Nothing interesting to return to the caller.</span>
    <span class="keywordflow">return</span> <a class="code" href="classSValue.html#z174_12">SValue::Status</a>(err);
}

<a class="code" href="group__Core.html#ga0">status_t</a> <a class="code" href="classSHandler.html#z123_0">MyCommand::HandleMessage</a>(<span class="keyword">const</span> <a class="code" href="classSMessage.html">SMessage</a> &amp;msg)
{
    <span class="keywordflow">if</span> (msg.<a class="code" href="classSMessage.html#a22">What</a>() == 'doit') {
        <span class="comment">// We got our message.  Do the work.</span>

        <a class="code" href="classSValue.html">SValue</a> args = msg.<a class="code" href="classSMessage.html#a2">Data</a>();

        <span class="comment">// ... do stuff ...</span>

        <span class="keywordflow">return</span> <a class="code" href="group__CoreSupportUtilities.html#gga152a30">B_OK</a>;
    }

    <span class="keywordflow">return</span> <a class="code" href="classSHandler.html#z123_0">SHandler::HandleMessage</a>(msg);
}
</pre></div><h2><a class="anchor" name="Serialization">
Serialization</a></h2>
Very related to asynchronicity is operation serialization. This is the use of a <a class="el" href="classSHandler.html">SHandler</a> as a message queue to ensure that a set of operations are executed in a specified order (determined by the order of messages in the queue), without requiring that we hold a lock while executing them.<p>
This is a very important pattern because of our locking policies described in <a class="el" href="BinderThreading.html">Threading Conventions</a>, and in particular that we should not be holding any locks when calling out of an object. If we can't hold any locks, and have no guarantees of the orders that calls will be made on our object, how can we ensure external calls are made in the proper order?<p>
First, let's look at an example of the problem. Here is a class with a variable that clients can set, which would then like to call on to another object when the variable changes. As per our locking rules, we do not hold a lock when calling the target.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyEnabler
{
<span class="keyword">public</span>:
    MyEnabler(<a class="code" href="classsptr.html">sptr&lt;Target&gt;</a>&amp; target)
        : m_target(target)
    {
    }

    <span class="keywordtype">void</span> Enable()
    {
        m_lock.Lock();
        <span class="keywordtype">bool</span> changed = !m_enabled;
        m_enabled = <span class="keyword">true</span>;
        m_lock.Unlock();

        <span class="comment">// ###1: RACE CONDITION!</span>

        <span class="keywordflow">if</span> (changed) m_target-&gt;NewValue(<span class="keyword">true</span>);
    }

    <span class="keywordtype">void</span> Disable()
    {
        m_lock.Lock();
        <span class="keywordtype">bool</span> changed = m_enabled;
        m_enabled = <span class="keyword">false</span>;
        m_lock.Unlock();

        <span class="comment">// ###2: RACE CONDITION!</span>

        <span class="keywordflow">if</span> (changed) m_target-&gt;NewValue(<span class="keyword">false</span>);
    }

<span class="keyword">private</span>:
    <span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;Target&gt;</a> m_target;

    <a class="code" href="classSLocker.html">SLocker</a> m_lock;
    <span class="keywordtype">bool</span> m_enabled;
};
</pre></div><p>
Notice the race conditions at points ###1 and ###2: if a context switch happens at that point, after we have updated m_enabled but before we have called NewValue(), then a second thread could enter the opposite function and completely execute, leaving m_target with the wrong value.<p>
Here is a solution using <a class="el" href="classSHandler.html">SHandler</a>. The trick here is that we can safely call PostMessage() with the lock held, knowing that we can count on the handler processing the resulting messages in the same order that the were posted.<p>
<dl compact><dt><b>Attention:</b></dt><dd><em>For this specific kind of situation  the propagation of data changes  you are better off using BBinder's standard Link()/Push() facility. This uses a <a class="el" href="classSHandler.html">SHandler</a> internally to ensure correct ordering without holding locks, and has well-defined mechanisms for clients to bypass that overhead when it is not needed.</em></dd></dl>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyEnabler : <span class="keyword">public</span> <a class="code" href="classSHandler.html">SHandler</a>
{
<span class="keyword">public</span>:
    MyEnabler(<a class="code" href="classsptr.html">sptr&lt;Target&gt;</a>&amp; target)
        : m_target(target)
    {
    }

    <span class="keywordtype">void</span> Enable()
    {
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        <span class="keywordflow">if</span> (!m_enabled) {
            <a class="code" href="classSMessage.html">SMessage</a> msg('rprt');
            msg.<a class="code" href="classSMessage.html#a11">SetData</a>(<a class="code" href="classSValue.html#z174_2">SValue::Bool</a>(<span class="keyword">true</span>));
            <a class="code" href="group__Core.html#ga0">status_t</a> err = PostMessage(msg);
        }
        m_enabled = <span class="keyword">true</span>;
    }

    <span class="keywordtype">void</span> Disable()
    {
        <a class="code" href="classSLocker_1_1Autolock.html">SLocker::Autolock</a> _l(m_lock);
        <span class="keywordflow">if</span> (m_enabled) {
            <a class="code" href="classSMessage.html">SMessage</a> msg('rprt');
            msg.<a class="code" href="classSMessage.html#a11">SetData</a>(<a class="code" href="classSValue.html#z174_2">SValue::Bool</a>(<span class="keyword">false</span>));
            <a class="code" href="group__Core.html#ga0">status_t</a> err = PostMessage(msg);
        }
        m_enabled = <span class="keyword">false</span>;
    }

    <a class="code" href="group__Core.html#ga0">status_t</a> HandleMessage(<span class="keyword">const</span> <a class="code" href="classSMessage.html">SMessage</a> &amp;msg)
    {
        <span class="keywordflow">if</span> (msg.<a class="code" href="classSMessage.html#a22">What</a>() == 'rprt') {
            m_target-&gt;ValueChanged(msg.<a class="code" href="classSMessage.html#a2">Data</a>().<a class="code" href="classSValue.html#z180_2">AsBool</a>());
            <span class="keywordflow">return</span> <a class="code" href="group__CoreSupportUtilities.html#gga152a30">B_OK</a>;
        }

        <span class="keywordflow">return</span> <a class="code" href="classSHandler.html#z123_0">SHandler::HandleMessage</a>(msg);
    }

<span class="keyword">private</span>:
    <span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;Target&gt;</a> m_target;

    <a class="code" href="classSLocker.html">SLocker</a> m_lock;
    <span class="keywordtype">bool</span> m_enabled;
};
</pre></div><h2><a class="anchor" name="Timeouts">
Timeouts</a></h2>
Another feature of <a class="el" href="classSHandler.html">SHandler</a> is that the messages in its queue are time stamped, and not delivered until that time arrives. When calling PostMessage(), the time stamp is set to the time of the call, resulting in the message being processed as soon as possible, as ordered by other messages in the queue.<p>
You can use the alternative APIs <a class="el" href="classSHandler.html#z122_2">SHandler::PostDelayedMessage()</a> and <a class="el" href="classSHandler.html#z122_4">SHandler::PostMessageAtTime()</a> to place a message in the queue with a time in the future, either relative from the time it was posted or at an absolute time, respectively. In addition, the API <a class="el" href="classSHandler.html#z124_7">SHandler::RemoveMessages()</a> allows you to get rid of selected messages currently waiting in the queue, which can be used as here to cancel a pending timeout.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Timeout : <span class="keyword">public</span> <a class="code" href="classSHandler.html">SHandler</a>
{
<span class="keyword">public</span>:
    <span class="keywordtype">void</span> StartTimer(<a class="code" href="group__Core.html#ga1">nsecs_t</a> duration)
    {
        <span class="comment">// Here we place a message in the queue to be</span>
        <span class="comment">// delivered when the timeout will expire.  Note</span>
        <span class="comment">// the use of SHandler::POST_REMOVE_DUPLICATES to ensure</span>
        <span class="comment">// that any existing timeout is cancelled.</span>
        PostDelayedMessage(
            <a class="code" href="SupportBuild_8h.html#a43">SMessage</a>('time'), duration, POST_REMOVE_DUPLICATES);
    }

    <span class="keywordtype">void</span> CancelTimer()
    {
        <span class="comment">// We cancel the timer by removing a pending timeout</span>
        <span class="comment">// message from the queue.  Note that we need to use</span>
        <span class="comment">// the SHandler::FILTER_FUTURE_FLAG or else any messages</span>
        <span class="comment">// whose time stamp is in the future will not be</span>
        <span class="comment">// removed.</span>
        <span class="comment">//</span>
        <span class="comment">// There is a kind of race condition here, where the</span>
        <span class="comment">// handler may already be pulling the message out of</span>
        <span class="comment">// the queue for processing when this function is</span>
        <span class="comment">// called.  In a way this is just a natural expected</span>
        <span class="comment">// outcome of the timeout being asynchronous &amp;mdash; at</span>
        <span class="comment">// some point, it will be too late for CancelTimer()</span>
        <span class="comment">// to cancel the timeout.  There are many ways this</span>
        <span class="comment">// could be changed, for example having CancelTimer()</span>
        <span class="comment">// remove an alert if it is being shown by the timeout</span>
        <span class="comment">// handler.</span>
        RemoveMesages('time', FILTER_FUTURE_FLAG);
    }

    <a class="code" href="group__Core.html#ga0">status_t</a> HandleMessage(<span class="keyword">const</span> <a class="code" href="classSMessage.html">SMessage</a> &amp;msg)
    {
        <span class="keywordflow">if</span> (msg.<a class="code" href="classSMessage.html#a22">What</a>() == 'time') {
            <a class="code" href="ErrorMgr_8h.html#a0">ErrFatalError</a>(
                <span class="stringliteral">"The application is not responding!"</span>);
            <span class="keywordflow">return</span> <a class="code" href="group__CoreSupportUtilities.html#gga152a30">B_OK</a>;
        }

        <span class="keywordflow">return</span> <a class="code" href="classSHandler.html#z123_0">SHandler::HandleMessage</a>(msg);
    }
}
</pre></div><h2><a class="anchor" name="RepeatedEvents">
Repeated Events</a></h2>
Often you want to do something over and over again at a regular interval. For example, this is useful when displaying an animation on the screen. You can use a <a class="el" href="classSHandler.html">SHandler</a> to accomplish this by posting a timed message to the handler and, upon receiving that message, posting a new message for a later time. For example, here we can see an <a class="el" href="classSHandler.html">SHandler</a> being mixed in with a BView to run an animation at 20 frames/sec.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyView : <span class="keyword">public</span> BView, <span class="keyword">public</span> <a class="code" href="classSHandler.html">SHandler</a>
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span>        AttachedToGraphicPlane(<span class="keyword">const</span> SGraphicPlane&amp; plane, uint32_t flags);

    <span class="keyword">virtual</span> <a class="code" href="group__Core.html#ga0">status_t</a>    HandleMessage(<span class="keyword">const</span> <a class="code" href="classSMessage.html">SMessage</a> &amp;msg);

    ...
}

<span class="keywordtype">void</span> MyView::AttachedToGraphicPlane(<span class="keyword">const</span> SGraphicPlane&amp; plane, 
uint32_t flags)
{
    BView::AttachedToGraphicPlane(plane, flags);

    <span class="keywordflow">if</span> ((flags&amp;B_FIRST_GRAPHIC_PLANE) != 0) {
        <span class="comment">// Now attached to screen, start the update messages</span>
        PostMessage(<a class="code" href="SupportBuild_8h.html#a43">SMessage</a>('updt', <a class="code" href="group__CoreThread.html#gga1a19">sysThreadPriorityUrgentDisplay</a>),
            POST_REMOVE_DUPLICATES);
    }
}

<a class="code" href="group__Core.html#ga0">status_t</a> <a class="code" href="classSHandler.html#z123_0">MyView::HandleMessage</a>(<span class="keyword">const</span> <a class="code" href="classSMessage.html">SMessage</a> &amp;msg)
{
    <span class="keywordflow">if</span> (msg.<a class="code" href="classSMessage.html#a22">What</a>() == 'updt') {
        <span class="comment">// We got our update message.  Invalidate the view.</span>
        Invalidate();

        <span class="comment">// If still attached to the screen, enqueue a new update</span>
        <span class="comment">// message to execute 1/20 second from now.</span>
        <span class="keywordflow">if</span> (GraphicPlane().InitCheck() == <a class="code" href="group__CoreSupportUtilities.html#gga152a30">B_OK</a>) {
            PostDelayedMessage(<a class="code" href="SupportBuild_8h.html#a43">SMessage</a>('updt', <a class="code" href="group__CoreThread.html#gga1a19">sysThreadPriorityUrgentDisplay</a>),
                <a class="code" href="group__Core.html#ga59">B_MS2NS</a>(20), POST_REMOVE_DUPLICATES);
        }
        <span class="keywordflow">return</span> <a class="code" href="group__CoreSupportUtilities.html#gga152a30">B_OK</a>;
    }

    <span class="keywordflow">return</span> <a class="code" href="classSHandler.html#z123_0">SHandler::HandleMessage</a>(msg);
}
</pre></div> <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:33 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
