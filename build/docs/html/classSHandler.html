<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: SHandler Class Reference</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1>SHandler Class Reference<br>
<small>
[<a class="el" href="group__CoreSupportUtilities.html">Utility Classes and Functions</a>]</small>
</h1><!-- doxytag: class="SHandler" --><!-- doxytag: inherits="SAtom" --><code>#include &lt;<a class="el" href="Handler_8h-source.html">support/Handler.h</a>&gt;</code>
<p>
<p>Inheritance diagram for SHandler:
<p><center><img src="classSHandler.png" usemap="#SHandler_map" border="0" alt=""></center>
<map name="SHandler_map">
<area href="classSAtom.html" alt="SAtom" shape="rect" coords="117,0,224,24">
<area href="classBInformant.html" alt="BInformant" shape="rect" coords="0,112,107,136">
<area href="classBSerialObserver.html" alt="BSerialObserver" shape="rect" coords="117,112,224,136">
<area href="classBTokenSource.html" alt="BTokenSource" shape="rect" coords="234,112,341,136">
</map>
<a href="classSHandler-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
SHandler is an event queue to deliver and process <a class="el" href="classSMessage.html">SMessage</a> objects. 
<p>
The SHandler is a base class for executing asynchronous operations and/or performing serialization of those operations. It is a mechanism for implementing concurrency.<p>
SHandler provides a set of posting methods for placing <a class="el" href="classSMessage.html">SMessage</a> data into an execution queue. Each message in the queue is timestamped, and the messages in the queue are consecutively processed by SHandler in their timestamped order.<p>
Message delivery is asynchronous: your thread can return from delivering a message before the message has even started execution. However, to ensure the correct delivery order of the messages, the handler only processes one at a time.<p>
Messages are sent to a SHandler by calling one of <a class="el" href="classSHandler.html#z122_3">PostMessage()</a>, <a class="el" href="classSHandler.html#z122_4">PostMessageAtTime()</a>, <a class="el" href="classSHandler.html#z122_2">PostDelayedMessage()</a>, or <a class="el" href="classSHandler.html#z122_1">EnqueueMessage()</a>. You subclass from SHandler and override <a class="el" href="classSHandler.html#z123_0">HandleMessage()</a> to process messages that have been posted to the handler.<p>
SHandler can also be used to serialize with external operations. To do this, pass in an external lock to the constructor. This lock will then be acquired when calling HandleMessage. In this way, the serialization of SHandler message handling can be also synchronized with external operations.<p>
See <a class="el" href="SHandlerPatterns.html">SHandler Patterns</a> for many examples of threading techniques you can use with SHandler.
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Posting</h2></td></tr>
<tr><td colspan="2">APIs to place messages into the handler's message queue. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classSHandler.html#z122_0w6">POST_REMOVE_DUPLICATES</a> =  0x0001, 
<a class="el" href="classSHandler.html#z122_0w5">POST_KEEP_UNIQUE</a> =  0x0002
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags for <a class="el" href="classSHandler.html#z122_3">PostMessage()</a>, <a class="el" href="classSHandler.html#z122_2">PostDelayedMessage()</a>, <a class="el" href="classSHandler.html#z122_4">PostMessageAtTime()</a>, <a class="el" href="classSHandler.html#z122_1">EnqueueMessage()</a>.  <a href="classSHandler.html#z122_0">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z122_1">EnqueueMessage</a> (const <a class="el" href="classSMessage.html">SMessage</a> &amp;message, <a class="el" href="group__Core.html#ga1">nsecs_t</a> time, uint32_t flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deposit a message a message into the handler's queue.  <a href="#z122_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z122_2">PostDelayedMessage</a> (const <a class="el" href="classSMessage.html">SMessage</a> &amp;message, <a class="el" href="group__Core.html#ga1">nsecs_t</a> delay, uint32_t flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post a message to the handler, with a timestamp set to the current time plus <em>delay</em>.  <a href="#z122_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z122_3">PostMessage</a> (const <a class="el" href="classSMessage.html">SMessage</a> &amp;message, uint32_t flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post a message to the handler, with its timestamp set to the current time.  <a href="#z122_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z122_4">PostMessageAtTime</a> (const <a class="el" href="classSMessage.html">SMessage</a> &amp;message, <a class="el" href="group__Core.html#ga1">nsecs_t</a> absoluteTime, uint32_t flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post a message to the handler, which is expected to arrive at the time <em>absoluteTime</em>.  <a href="#z122_4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Queue Manipulation</h2></td></tr>
<tr><td colspan="2">APIs to manipulate message in the queue queue. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classSHandler.html#z124_0w3">FILTER_REVERSE_FLAG</a> =  0x0001, 
<a class="el" href="classSHandler.html#z124_0w0">FILTER_FUTURE_FLAG</a> =  0x0002
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags for <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> and <a class="el" href="classSHandler.html#z124_7">RemoveMessages()</a>.  <a href="classSHandler.html#z124_0">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z124_1">filter_action</a> { <a class="el" href="classSHandler.html#z124_1w2">FILTER_REMOVE</a> =  0, 
<a class="el" href="classSHandler.html#z124_1w1">FILTER_KEEP</a> =  1, 
<a class="el" href="classSHandler.html#z124_1w4">FILTER_STOP</a> =  2
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actions you can return to <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> from your filter_func.  <a href="classSHandler.html#z124_1">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSHandler.html#z124_1">filter_action</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z124_2">filter_func</a> )(const <a class="el" href="classSMessage.html">SMessage</a> *message, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function callback for <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a>.  <a href="#z124_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z124_3">CountMessages</a> (uint32_t what=B_ANY_WHAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of pending message that match <em>what</em>.  <a href="#z124_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z124_4">FilterMessages</a> (const <a class="el" href="classSHandler_1_1filter__functor__base.html">filter_functor_base</a> &amp;functor, uint32_t flags, void *data, <a class="el" href="classSMessageList.html">SMessageList</a> *outRemoved=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags for <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> and <a class="el" href="classSHandler.html#z124_7">RemoveMessages()</a>.  <a href="#z124_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z124_5">FilterMessages</a> (<a class="el" href="classSHandler.html#z124_2">filter_func</a> func, uint32_t flags, void *data, <a class="el" href="classSMessageList.html">SMessageList</a> *outRemoved=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate through this handler's message queueue, selecting whether to keep or remove messages.  <a href="#z124_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z124_6">RemoveAllMessages</a> (<a class="el" href="classSMessageList.html">SMessageList</a> *outRemoved=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> where all messages are deleted.  <a href="#z124_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z124_7">RemoveMessages</a> (uint32_t what, uint32_t flags, <a class="el" href="classSMessageList.html">SMessageList</a> *outRemoved=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> where all messages that match <em>what</em> are deleted.  <a href="#z124_7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Dispatching Primitives</h2></td></tr>
<tr><td colspan="2">Low-level manipulation of the handler's message dispatching. <dl compact><dt><b>Note:</b></dt><dd>These should not be used unless you absolutely know what you are doing. </dd></dl>
<br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSMessage.html">SMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z125_0">DequeueMessage</a> (uint32_t what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove next pending message with code <em>what</em> from the handler's message queue.  <a href="#z125_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z125_1">DispatchAllMessages</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Immediately handle all messages currently in the queue.  <a href="#z125_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Core.html#ga1">nsecs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z125_2">NextMessageTime</a> (int32_t *out_priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the time of the next message in the queue.  <a href="#z125_2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Handling</h2></td></tr>
<tr><td colspan="2">APIs used to handle messages that are delivered to the handler. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z123_0">HandleMessage</a> (const <a class="el" href="classSMessage.html">SMessage</a> &amp;msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses override this to receive messages.  <a href="#z123_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z123_1">ResumeScheduling</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make handler ready to process the next message in its queue.  <a href="#z123_1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Bookkeeping</h2></td></tr>
<tr><td colspan="2">Creation, destruction, locking, etc. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z121_0">SHandler</a> (const <a class="el" href="classSContext.html">SContext</a> &amp;context)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z121_1">SHandler</a> (<a class="el" href="classSLocker.html">SLocker</a> *externalLock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supply an external lock to be held when dispatching messages.  <a href="#z121_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z121_2">SHandler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#z121_3">~SHandler</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler.html#n0">BProcess</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler_1_1filter__functor.html">filter_functor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSHandler_1_1filter__functor__base.html">filter_functor_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor callback for <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a>.  <a href="classSHandler_1_1filter__functor__base.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="z124_2"></a><!-- doxytag: member="SHandler::filter_func" ref="z124_2" args=")(const SMessage *message, void *data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="classSHandler.html#z124_1">filter_action</a>(* <a class="el" href="classSHandler.html#z124_2">filter_func</a>)(const <a class="el" href="classSMessage.html">SMessage</a> *message, void *data)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Function callback for <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a>. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="z122_0"></a><!-- doxytag: member="SHandler::@2" ref="z122_0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">anonymous enum          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flags for <a class="el" href="classSHandler.html#z122_3">PostMessage()</a>, <a class="el" href="classSHandler.html#z122_2">PostDelayedMessage()</a>, <a class="el" href="classSHandler.html#z122_4">PostMessageAtTime()</a>, <a class="el" href="classSHandler.html#z122_1">EnqueueMessage()</a>. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="z122_0w6"></a><!-- doxytag: member="POST_REMOVE_DUPLICATES" ref="z122_0w6" args="" -->POST_REMOVE_DUPLICATES</em>&nbsp;</td><td>
Remove any pending message with the same What() code. 
<p>
Using this flag is a semantically the same as first calling RemoveMessages(msgCode) before posting the message, but more efficient. This is as opposed to POST_KEEP_UNIQUE. <dl compact><dt><b>Note:</b></dt><dd>be careful with POST_REMOVE_DUPLICATES, as the data for any existing messages in the queue will be released inside of the call. That means, if you aren't absolutely sure about what that data is, you MUST NOT do this while holding a lock. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="z122_0w5"></a><!-- doxytag: member="POST_KEEP_UNIQUE" ref="z122_0w5" args="" -->POST_KEEP_UNIQUE</em>&nbsp;</td><td>
Ensure this message's event code is unique in the queue. 
<p>
This flag ensures that only one message with the given message code exists in the queue. If, at the time of posting, there are already messages with the same code, the first such message will be kept with its data changed (moving it up earlier in the queue if needed for the new timestamp), and all other messages removed. Unlike POST_REMOVE_DUPLICATES, posting a new message when there is already a pending message with the same code will not cause that message code to be moved later in the queue. <dl compact><dt><b>Note:</b></dt><dd>be careful with POST_KEEP_UNIQUE, as the data for any existing messages in the queue will be released inside of the call. That means, if you aren't absolutely sure about what that data is, you MUST NOT do this while holding a lock. </dd></dl>
</td></tr>
</table>
</dl>

<p>
Reimplemented from <a class="el" href="classSAtom.html">SAtom</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z124_0"></a><!-- doxytag: member="SHandler::@3" ref="z124_0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">anonymous enum          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flags for <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> and <a class="el" href="classSHandler.html#z124_7">RemoveMessages()</a>. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="z124_0w3"></a><!-- doxytag: member="FILTER_REVERSE_FLAG" ref="z124_0w3" args="" -->FILTER_REVERSE_FLAG</em>&nbsp;</td><td>
Filter in reverse time order. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="z124_0w0"></a><!-- doxytag: member="FILTER_FUTURE_FLAG" ref="z124_0w0" args="" -->FILTER_FUTURE_FLAG</em>&nbsp;</td><td>
Include messages after current time. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z124_1"></a><!-- doxytag: member="SHandler::filter_action" ref="z124_1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="classSHandler.html#z124_1">filter_action</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Actions you can return to <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> from your filter_func. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="z124_1w2"></a><!-- doxytag: member="FILTER_REMOVE" ref="z124_1w2" args="" -->FILTER_REMOVE</em>&nbsp;</td><td>
Remove message from queue. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="z124_1w1"></a><!-- doxytag: member="FILTER_KEEP" ref="z124_1w1" args="" -->FILTER_KEEP</em>&nbsp;</td><td>
Keep message in queue. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="z124_1w4"></a><!-- doxytag: member="FILTER_STOP" ref="z124_1w4" args="" -->FILTER_STOP</em>&nbsp;</td><td>
Do not filter any more messages. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="z121_2"></a><!-- doxytag: member="SHandler::SHandler" ref="z121_2" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSHandler.html">SHandler</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>SHandler is no longer a <a class="el" href="classBBinder.html">BBinder</a> object.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z121_1"></a><!-- doxytag: member="SHandler::SHandler" ref="z121_1" args="(SLocker *externalLock)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSHandler.html">SHandler</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSLocker.html">SLocker</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>externalLock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Supply an external lock to be held when dispatching messages. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z121_0"></a><!-- doxytag: member="SHandler::SHandler" ref="z121_0" args="(const SContext &amp;context)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSHandler.html">SHandler</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSContext.html">SContext</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>context</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>SHandler is no longer a <a class="el" href="classBBinder.html">BBinder</a> object.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z121_3"></a><!-- doxytag: member="SHandler::~SHandler" ref="z121_3" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">~<a class="el" href="classSHandler.html">SHandler</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>SHandler is no longer a <a class="el" href="classBBinder.html">BBinder</a> object.</dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z124_3"></a><!-- doxytag: member="SHandler::CountMessages" ref="z124_3" args="(uint32_t what=B_ANY_WHAT)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t CountMessages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>what</em> = <code>B_ANY_WHAT</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of pending message that match <em>what</em>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z125_0"></a><!-- doxytag: member="SHandler::DequeueMessage" ref="z125_0" args="(uint32_t what)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSMessage.html">SMessage</a> * DequeueMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>what</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove next pending message with code <em>what</em> from the handler's message queue. 
<p>
You are responsible for deleting the returned message. If there are no matching pending message, NULL is returned.    </td>
  </tr>
</table>
<a class="anchor" name="z125_1"></a><!-- doxytag: member="SHandler::DispatchAllMessages" ref="z125_1" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DispatchAllMessages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Immediately handle all messages currently in the queue. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z122_1"></a><!-- doxytag: member="SHandler::EnqueueMessage" ref="z122_1" args="(const SMessage &amp;message, nsecs_t time, uint32_t flags=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> EnqueueMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSMessage.html">SMessage</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__Core.html#ga1">nsecs_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deposit a message a message into the handler's queue. 
<p>
The message will be delivered at the given absolute time. <dl compact><dt><b>Note:</b></dt><dd>Unlike <a class="el" href="classSHandler.html#z122_4">PostMessageAtTime()</a>, this function does not try to prevent starvation by ensuring the time is later than now.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z124_4"></a><!-- doxytag: member="SHandler::FilterMessages" ref="z124_4" args="(const filter_functor_base &amp;functor, uint32_t flags, void *data, SMessageList *outRemoved=NULL)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void FilterMessages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSHandler_1_1filter__functor__base.html">filter_functor_base</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>functor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSMessageList.html">SMessageList</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>outRemoved</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flags for <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> and <a class="el" href="classSHandler.html#z124_7">RemoveMessages()</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z124_5"></a><!-- doxytag: member="SHandler::FilterMessages" ref="z124_5" args="(filter_func func, uint32_t flags, void *data, SMessageList *outRemoved=NULL)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void FilterMessages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSHandler.html#z124_2">filter_func</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSMessageList.html">SMessageList</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>outRemoved</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Iterate through this handler's message queueue, selecting whether to keep or remove messages. 
<p>
Your filter_func selects the action to perform for each message by the result it turns. If it selects to remove a message, the message will either be placed into <em>outRemoved</em> if that is non-NULL, or immediately deleted. <dl compact><dt><b>Note:</b></dt><dd>filter_func is called WITH THE HANDLER LOCKED. You can not call back into the handler from it, and must be very careful about what other locks you acquire.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z123_0"></a><!-- doxytag: member="SHandler::HandleMessage" ref="z123_0" args="(const SMessage &amp;msg)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> HandleMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSMessage.html">SMessage</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>msg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Subclasses override this to receive messages. 
<p>

<p>
Reimplemented in <a class="el" href="classBInformant.html#a2">BInformant</a>, <a class="el" href="classBSerialObserver.html#a1">BSerialObserver</a>, and <a class="el" href="classBTokenSource.html#a2">BTokenSource</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z125_2"></a><!-- doxytag: member="SHandler::NextMessageTime" ref="z125_2" args="(int32_t *out_priority)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga1">nsecs_t</a> NextMessageTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out_priority</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the time of the next message in the queue. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z122_2"></a><!-- doxytag: member="SHandler::PostDelayedMessage" ref="z122_2" args="(const SMessage &amp;message, nsecs_t delay, uint32_t flags=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> PostDelayedMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSMessage.html">SMessage</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__Core.html#ga1">nsecs_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Post a message to the handler, with a timestamp set to the current time plus <em>delay</em>. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSHandler.html#z122_4">PostMessageAtTime()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z122_3"></a><!-- doxytag: member="SHandler::PostMessage" ref="z122_3" args="(const SMessage &amp;message, uint32_t flags=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> PostMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSMessage.html">SMessage</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Post a message to the handler, with its timestamp set to the current time. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSHandler.html#z122_4">PostMessageAtTime()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z122_4"></a><!-- doxytag: member="SHandler::PostMessageAtTime" ref="z122_4" args="(const SMessage &amp;message, nsecs_t absoluteTime, uint32_t flags=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> PostMessageAtTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSMessage.html">SMessage</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__Core.html#ga1">nsecs_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>absoluteTime</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Post a message to the handler, which is expected to arrive at the time <em>absoluteTime</em>. 
<p>
The handler will enqueue this message, but not deliver it until after the selected time. If the timestamp is set to the current time, the message will be delivered as soon as possible, but not before any older pending messages have been handled. Normally, a handler executes only one message at a time, in their timestamp order.<p>
This method ensures that <em>absoluteTime</em> is later than the current time, to protect against livelocks. You can use <a class="el" href="classSHandler.html#z122_1">EnqueueMessage()</a> to avoid this constraint.<p>
The optional <em>flags</em> may be POST_REMOVE_DUPLICATES or POST_KEEP_UNIQUE.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSHandler.html#z122_3">PostMessage()</a>, <a class="el" href="classSHandler.html#z122_2">PostDelayedMessage()</a>, <a class="el" href="classSHandler.html#z122_1">EnqueueMessage()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z124_6"></a><!-- doxytag: member="SHandler::RemoveAllMessages" ref="z124_6" args="(SMessageList *outRemoved=NULL)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RemoveAllMessages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSMessageList.html">SMessageList</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>outRemoved</em> = <code>NULL</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> where all messages are deleted. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z124_7"></a><!-- doxytag: member="SHandler::RemoveMessages" ref="z124_7" args="(uint32_t what, uint32_t flags, SMessageList *outRemoved=NULL)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RemoveMessages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>what</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSMessageList.html">SMessageList</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>outRemoved</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform <a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> where all messages that match <em>what</em> are deleted. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSHandler.html#z124_5">FilterMessages()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z123_1"></a><!-- doxytag: member="SHandler::ResumeScheduling" ref="z123_1" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ResumeScheduling           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make handler ready to process the next message in its queue. 
<p>
You can call this function while in your <a class="el" href="classSHandler.html#z123_0">HandleMessage()</a> method to let the handler schedule itself for the next message in its queue, allowing it to continue processing even before you have returned from <a class="el" href="classSHandler.html#z123_0">HandleMessage()</a>.    </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="n0"></a><!-- doxytag: member="SHandler::BProcess" ref="n0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class <a class="el" href="classBProcess.html">BProcess</a><code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Handler_8h-source.html">Handler.h</a><li><a class="el" href="Handler_8cpp.html">Handler.cpp</a></ul>
<div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
