<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: API Conventions</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="APIConventions">API Conventions</a></h1><div class="header"> <center>&lt; <a class="el" href="BinderOverview.html">Binder Overview</a> | <a class="el" href="main.html#OpenBinder">OpenBinder</a> | <a class="el" href="BinderThreading.html">Threading Conventions</a> &gt;</center> <hr>
 </div><p>
This is a description of the various programming conventions we use. It is based on conventions from the Binder, but is applicable to C++ programming in general. It covers both C++ language features and styles as well as conventions specific to the Binder itself.<p>
These conventions are intended to be very minimal  the focus is almost entirely on the public API that is exposed to developers, and not on detailing where every brace and tab goes in the actual implementation.<p>
Code implemented on top of the Binder should follow these conventions. Other parts of the system may or may not follow the various conventions described here, as desired by those authors; however, if your code will be seen by third party developers it is highly encouraged that you adopt these conventions to ensure a consistent developer experience.<p>
<ol type=1>
<li><a class="el" href="APIConventions.html#GeneralNamespaces">General Namespaces</a></li><li><a class="el" href="APIConventions.html#CppConventions">C++ Language Conventions</a><ol type=a>
<li><a class="el" href="APIConventions.html#CppNamespaces">Namespaces</a></li><li><a class="el" href="APIConventions.html#CppExceptions">Exceptions</a></li><li><a class="el" href="APIConventions.html#CppTemplates">Templates</a></li></ol>
</li><li><a class="el" href="APIConventions.html#ClassConventions">Class Conventions</a><ol type=a>
<li><a class="el" href="APIConventions.html#ClassNames">Class Names</a></li><li><a class="el" href="APIConventions.html#ClassPublicProtectedMethods">Public/Protected Method Names</a><ol type=i>
<li><a class="el" href="APIConventions.html#ClassProperties">Properties</a></li><li><a class="el" href="APIConventions.html#ClassCallbacks">Call-backs</a></li><li><a class="el" href="APIConventions.html#ClassDataGeneration">Data Generation</a></li><li><a class="el" href="APIConventions.html#ClassConversions">Conversions</a></li><li><a class="el" href="APIConventions.html#ClassStatus">Status</a></li><li><a class="el" href="APIConventions.html#ClassLocking">Locking</a></li></ol>
</li><li><a class="el" href="APIConventions.html#ClassPrivateMethods">Private Method Names</a></li><li><a class="el" href="APIConventions.html#ClassMemberVariables">Member Variables</a></li><li><a class="el" href="APIConventions.html#ClassTypeMarshalling">Type Marshalling</a></li><li><a class="el" href="APIConventions.html#ClassMemoryManagement">Memory Management</a></li></ol>
</li><li><a class="el" href="APIConventions.html#OtherCpp">Other C++ Conventions</a><ol type=a>
<li><a class="el" href="APIConventions.html#CppHeaderFiles">Header Files</a></li><li><a class="el" href="APIConventions.html#CppConstants">Constants</a><ol type=i>
<li><a class="el" href="APIConventions.html#CppIntegers">Integers</a></li><li><a class="el" href="APIConventions.html#CppErrorCodes">Error Codes</a></li><li><a class="el" href="APIConventions.html#CppStringsValues">Strings and Values</a></li></ol>
</li><li><a class="el" href="APIConventions.html#CppGlobalFunctions">Global Functions</a></li><li><a class="el" href="APIConventions.html#CppComments">Comments</a></li></ol>
</li><li><a class="el" href="APIConventions.html#InterfaceConventions">Interface Conventions</a><ol type=a>
<li><a class="el" href="APIConventions.html#InterfaceNamespaces">Namespaces</a></li><li><a class="el" href="APIConventions.html#InterfaceProperties">Properties</a></li><li><a class="el" href="APIConventions.html#InterfaceMethods">Methods</a><ol type=i>
<li><a class="el" href="APIConventions.html#InterfaceFactories">Factories</a></li></ol>
</li><li><a class="el" href="APIConventions.html#InterfaceEvents">Events</a></li><li><a class="el" href="APIConventions.html#InterfaceConstants">Constants</a></li><li><a class="el" href="APIConventions.html#InterfaceComments">Comments</a></li></ol>
</li></ol>
<h2><a class="anchor" name="GeneralNamespaces">
General Namespaces</a></h2>
We use a Java-style convention for component, interface, and other names. These are also reflected in C++ namespaces, where each segment of the name is a part of a nested namespace. There are two namespaces you will typically use.<p>
<dl compact><dt><b>org.openbinder.*</b></dt><dd>These are components, interfaces, and other things that are considered to be a part of the platform. As such, there are a part of the platform API and must maintain compatibility as the platform develops.</dd></dl>
<dl compact><dt><b>com.palmsource.*</b></dt><dd>These things are not a part of the platform API, and will change in incompatible ways between releases.</dd></dl>
For example, the Address Book may have a org.openbinder.apps.Address.Database component, which is the IDatabaseTable for accessing the Address Book data. This is a component that everyone should use for working with that database, and so it is a part of the platform APIs and given the org.openbinder.* prefix.<p>
At the same time the Address Book may have a com.palmsource.apps.Address.Supermenu component, which it uses to show a super-menu for opening an address entry. This component is part of the Adddress Book's private implementation and should not be used by others, so is in the com.palmsource.* namespace.<p>
Note that something being in the org.openbinder.* namespace is probably not completely a guarantee of compatibility. For example, there are various private system interfaces (such as org.openbinder.app.IApplicationManager) that are not part of the SDK and developers should not use; this is enforced by controlling which IDL files are included in the SDK. In general (and especially for component names), however, these rules should be followed.<h2><a class="anchor" name="CppConventions">
C++ Language Conventions</a></h2>
<h3><a class="anchor" name="CppNamespaces">
Namespaces</a></h3>
We intend to use namespaces in C++, however they aren't currently enabled. You will see a lot of stuff around that purports to use namespaces, however it is all currently commented out and thus probably broken. (When the Binder was originally being implemented it did use namespaces, however that had to be removed when we ported to ADS and Visual Studio 6, neither of which supported namespaces. At some point we need to go through all of the code and fix its use of namespaces so that we can re-enable them, but this hasn't been a high priority.)<p>
All of our OS APIs are placed into the platform-level namespace as described above, and then into a second-level namespace within that for the kit to which it belongs. For example:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>support {

<span class="keyword">class </span><a class="code" href="classSConditionVariable.html">SConditionVariable</a>
{
    ...
};

} } <span class="comment">// namespace palmos::support</span>
</pre></div><p>
A namespace can have public "using" statements with it, if that namespace's API physically depends on another:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>render {

<span class="keyword">using</span> <span class="keyword">namespace </span>support;

<span class="keyword">class </span>SRect
{
    <span class="comment">// Need the Support Kit's SValue class for this.</span>
    SRect(<span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; value, <a class="code" href="group__Core.html#ga0">status_t</a>* outError);
    ...
};

} } <span class="comment">// namespace palmos::render</span>
</pre></div><p>
Note that given the above code (saying <code>palmos::render</code> builds on top of <code><a class="el" href="namespacepalmos_1_1support.html">palmos::support</a></code>), it would be invalid within the <code><a class="el" href="namespacepalmos_1_1support.html">palmos::support</a></code> namespace to write "&lt;tt&gt;using render&lt;/tt&gt;". That is, there should be no circular dependencies between kits/namespaces.<p>
It is <em>never</em> okay to have a "&lt;tt&gt;using&lt;/tt&gt;" statement in the global namespace in a public header. You must only place them within other namespaces. (This is because it is impossible to automatically disambiguate symbols once they are in the global namespace.) However, you can do whatever you want as part of your implementation. Thus most <code>.cpp</code> files do something like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;render/Rect.h&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace </span>palmos::render;

SRect::SRect()
{
}

...
</pre></div><h3><a class="anchor" name="CppExceptions">
Exceptions</a></h3>
We don't use exceptions in the Binder. This is primarily because our ARM compiler (ADS) doesn't support them. In addition, for them to be useful we would probably need to be able to trasparently propagate them across IPC calls, and it's not clear how we would go about doing that.<h3><a class="anchor" name="CppTemplates">
Templates</a></h3>
There is some careful use of templates in our APIs. In general you should feel free to use templates where it makes sense (to the extent that our compilers actually support them), however you do have to be careful.<p>
The main thing to watch out for is that we ultimately need to support binary compatibility with our APIs, and this is very problematic with templates because by their nature they expose their implementation. Thus you can never export template functions from a library, because you will end up with multiple (potentially different) implementations of the template compiled in to the library and its clients. (Not to mention the fact as our shared library tools currently exist you will be unable to link to the library due to duplicate symbol errors.)<p>
There are two basic approaches we take to templates. The first is to just make the template very simple, so that the implementation is trivial (and thus won't change) and can be safely compiled in to every client. A good example of this is the sptr&lt;&gt; and wptr&lt;&gt; templates in support/Atom.h.<p>
For more complicated templates, we take an approach that is a variation on the above. The template class is divided into two parts, a base class containing the interesting implementation and a set of pure virtual methods, and then a template class deriving from the base class that implements the pure virtuals based on the type it is templatized over. In this way the template class is again a very simple implementation that doesn't need to be exported from the library. The <a class="el" href="classSAbstractVector.html">SAbstractVector</a> and <a class="el" href="classSVector.html">SVector</a> classes in support/Vector.h are a good example of this approach.<h2><a class="anchor" name="ClassConventions">
Class Conventions</a></h2>
<h3><a class="anchor" name="ClassNames">
Class Names</a></h3>
C++ class names are MixedCase with one of three prefixes indicating the type of class:<p>
<ul>
<li>
<b>I</b> is used for Binder interfaces. For example, IView. These classes have as a base the class <a class="el" href="classIInterface.html">IInterface</a> (with the single exception of <a class="el" href="classIBinder.html">IBinder</a>). They are pure virtual classes, providing no actual implementation. </li>
<li>
<b>B</b> is used for Binder classes. This is any class that derives directly or indirectly from <a class="el" href="classBBinder.html">BBinder</a>. For example, BView. These classes are usually concrete (they can be instantiated), though that is not always the case. </li>
<li>
<b>S</b> is used for all other classes. Most often these are type classes, such as <a class="el" href="classSValue.html">SValue</a> or <a class="el" href="classSMessage.html">SMessage</a>, but they may be other things as well such as <a class="el" href="classSAtom.html">SAtom</a> or <a class="el" href="classSHandler.html">SHandler</a>. </li>
</ul>
<p>
Note there are currently many places in the source tree that don't follow these conventions. For example, you will often see classes with a "P" prefix, which is from an old iteration of the conventions. People will be cleaning up the code as they get a chance.<h3><a class="anchor" name="ClassPublicProtectedMethods">
Public/Protected Method Names</a></h3>
Public methods should be written in MixedCase(). In addition, we have some developing conventions for constructing method names. Note that from an API compatibility perspective, protected APIs are no different than public ones.<h4><a class="anchor" name="ClassProperties">
Properties</a></h4>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> SetProperty(int32_t property); <span class="comment">// setter function</span>
    int32_t Property() <span class="keyword">const</span>;           <span class="comment">// getter function</span>
</pre></div><p>
Never directly expose member variables in the public/protected sections. If performance is an issue, simply make inline getter/setter methods (and clearly comment the method variable that it must stay the same for binary compatibility).<h4><a class="anchor" name="ClassCallbacks">
Call-backs</a></h4>
<div class="fragment"><pre class="fragment">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnKeyDown(<span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp; <a class="code" href="TSD_8cpp.html#a1">key</a>, <span class="keyword">const</span> <a class="code" href="classSMessage.html">SMessage</a>&amp; msg);
</pre></div><p>
A hook function that subclasses override should use the "On" prefix. Note that Binder interfaces will rarely if ever use "On", because they define an external protocol into the class. "On" here is used for an internal protocol of the class making calls on itself for more derived classes to override.<h4><a class="anchor" name="ClassDataGeneration">
Data Generation</a></h4>
<div class="fragment"><pre class="fragment">    IView GenerateCell(<a class="code" href="classSValue.html">SValue</a> <a class="code" href="TSD_8cpp.html#a2">name</a>, size_t row, <a class="code" href="classSValue.html">SValue</a> cellData, [inout]<span class="keywordtype">float</span> itemHeight);

    <span class="keyword">virtual</span> <a class="code" href="classSString.html">SString</a> GenerateTitle() = 0;
    <span class="keyword">virtual</span> <a class="code" href="classSString.html">SString</a> GenerateTitleIcon();  <span class="comment">//!&lt; defaults to none</span>
</pre></div><p>
We have started using a convention in the activity classes for the word "Generate" at the front of virtual functions that create some piece of data to return to the caller. This is used in both interfaces (for example IColumn::GenerateCell() creates a new IView object for a cell in the column) and call-backs in classes (for example BInteractiveActivity::GenerateTitle() creates a string for the window's title).<h4><a class="anchor" name="ClassConversions">
Conversions</a></h4>
<div class="fragment"><pre class="fragment">    <a class="code" href="classSValue.html">SValue</a> AsValue() <span class="keyword">const</span>;
    SRect AsRect(<a class="code" href="group__Core.html#ga0">status_t</a>* out_err = <a class="code" href="group__Core.html#ga75">NULL</a>) <span class="keyword">const</span>;
</pre></div><p>
A method that converts a given object into another type should use the "As" prefix. If the conversion can fail you should include an optional output parameter of an error result, though it should still generate a well-defined value in case of error, such as an empty string or undefined <a class="el" href="classSValue.html">SValue</a>.<h4><a class="anchor" name="ClassStatus">
Status</a></h4>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__Core.html#ga0">status_t</a> StatusCheck() <span class="keyword">const</span>;
</pre></div><p>
Classes that can have an error state  such as due to memory or other error during constructor, being constructed without being initialized, becoming invalid while being used  should have a StatusCheck() method that returns the current status of the object.<h4><a class="anchor" name="ClassLocking">
Locking</a></h4>
<div class="fragment"><pre class="fragment">    <a class="code" href="structlock__status__t.html">lock_status_t</a>       Lock() <span class="keyword">const</span>;
    <span class="keywordtype">void</span>                Unlock() <span class="keyword">const</span>;

    <span class="keyword">virtual</span> <a class="code" href="group__Core.html#ga0">status_t</a>    SetSizeLocked(off_t size);
</pre></div><p>
In some rare occasions (most significantly the generic Data Model class implementations), we must expose locking in the public API. This should be done by including Lock() and Unlock() methods, where the Lock() method returns a standard <a class="el" href="structlock__status__t.html">lock_status_t</a> type. Any other methods that are called with the lock held must have the "Locked" suffix. This is very useful to clearly document the locking policies of the class.<p>
Note that you should <em>very rarely</em> use this approach in public APIs, because it almost always makes the API more complicated to use and rigid.<h3><a class="anchor" name="ClassPrivateMethods">
Private Method Names</a></h3>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> private_method();
    <span class="keywordtype">void</span> do_something_l();
</pre></div><p>
Private methods should be written in lower_case(). This way the default settings of MakeSLD will not export these symbols.<p>
A private method that must be called with a lock held should use a "_l" suffix. For example, do_something_l(). This is very useful to document internal locking policies in the implementation.<h3><a class="anchor" name="ClassMemberVariables">
Member Variables</a></h3>
<div class="fragment"><pre class="fragment">    int32_t m_someInt;
</pre></div><p>
All member variables should have a "m_" prefix and then used mixedCase starting with a lower-case letter.<h3><a class="anchor" name="ClassTypeMarshalling">
Type Marshalling</a></h3>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span><a class="code" href="classSUrl.html">SUrl</a>
{
<span class="keyword">public</span>:
    ...
                    <a class="code" href="SupportBuild_8h.html#a61">SUrl</a>(<span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;value, <a class="code" href="group__Core.html#ga0">status_t</a>* out_err=<a class="code" href="group__Core.html#ga75">NULL</a>);

           <a class="code" href="classSValue.html">SValue</a>   AsValue(int32_t form = <a class="code" href="group__CoreSupportUtilities.html#gga157a0">B_FLATTEN_FORM_ACTIVE</a>) <span class="keyword">const</span>;
    <span class="keyword">inline</span> operator SValue()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> AsValue(); }
</pre></div><p>
If you are writing a stack class that is to be marshalled by pidgen (so it can be used in Binder interfaces), you must provide the above constructor and methods.<p>
Note that if AsValue() fails, it should return a status <a class="el" href="classSValue.html">SValue</a> using <a class="el" href="classSValue.html#z174_12">SValue::Status()</a>. (If it fails due to running out of memory or other exception cases, use SetError().)<p>
To support custom marshalling, you need in addition to implement the following functions:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>SPoint
{
<span class="keyword">public</span>:
    ...

    <span class="keyword">static</span> ssize_t  MarshalParcel(<a class="code" href="classSParcel.html">SParcel</a>&amp; dest, <span class="keyword">const</span> <span class="keywordtype">void</span>* var);
    <span class="keyword">static</span> <a class="code" href="group__Core.html#ga0">status_t</a> UnmarshalParcel(<a class="code" href="classSParcel.html">SParcel</a>&amp; src, <span class="keywordtype">void</span>* var);
    <span class="keyword">static</span> <a class="code" href="group__Core.html#ga0">status_t</a> MarshalValue(<a class="code" href="classSValue.html">SValue</a>* dest, <span class="keyword">const</span> <span class="keywordtype">void</span>* var);
    <span class="keyword">static</span> <a class="code" href="group__Core.html#ga0">status_t</a> UnmarshalValue(<span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a>&amp; src, <span class="keywordtype">void</span>* var);
};
</pre></div><h3><a class="anchor" name="ClassMemoryManagement">
Memory Management</a></h3>
In general there are two kinds of classes we use: stack-based and reference counted.<p>
Reference counted classes derive from <a class="el" href="classSAtom.html">SAtom</a>, <a class="el" href="classSLightAtom.html">SLightAtom</a> or <a class="el" href="classSLimAtom.html">SLimAtom</a>. All I- and B-prefix classes are reference counted. Instances of these classes are always created with new, and pointed to with sptr&lt;&gt; or wptr&lt;&gt;; the reference counting mechanism will take care of calling delete for you at the appropriate time. These classes are always passed by reference.<p>
The "atom" reference counting classes are described in SupportFAQ.<p>
Stack-based classes generally correspond to types, for example SRect, <a class="el" href="classSValue.html">SValue</a>, SLayoutConstraints, etc. You should never use 'new' to instantiate them, instead constructing them on the stack or in a container such as SVector&lt;&gt;. These classes are always passed by value (an out or in/out parameter might seem like an exception, but conceptually you should think of this as copying the value back and forth).<p>
Stack-based classes should be efficient to copy, so that they can always be passed by value. This is important in a multithreaded system where returning a copy of an object can make thread safety much easier to deal with. If your class can't be efficiently copied, you can use copy-on-write semantics. <a class="el" href="classSString.html">SString</a>, <a class="el" href="classSValue.html">SValue</a>, and SGlyphMap are all examples of this; they all use the convenient <a class="el" href="classSSharedBuffer.html">SSharedBuffer</a> class for their implementation.<p>
Note that <a class="el" href="classSSharedBuffer.html">SSharedBuffer</a> and implementations using it are an exception to our rule about not manually managing memory... but that's okay, because <a class="el" href="classSSharedBuffer.html">SSharedBuffer</a> is there to help us implement other classes in the normal API that hide their memory management.<h2><a class="anchor" name="OtherCpp">
Other C++ Conventions</a></h2>
<h3><a class="anchor" name="CppHeaderFiles">
Header Files</a></h3>
All C++ header files are placed in sub-directories named by the kit they belong to. Generally a particular class in the API will be placed into its own header file, with that header having the same name as the class <em>without</em> its prefix. For sample, the SFont class is in the Render Kit, so its header file is "render/Font.h".<p>
Sometimes you will have a set of related class that make sense to go together in one header file. In this case the header name will be representative of the kinds of classes it contains. For example, "support/Atom.h" includes <a class="el" href="classSAtom.html">SAtom</a>, <a class="el" href="classSLightAtom.html">SLightAtom</a>, <a class="el" href="classSLimAtom.html">SLimAtom</a>, as well as sptr and wptr.<p>
You are encouraged to include multiple classes in a header, when it helps developers to understand the header files: it is basically a balancing act between a few headers with so many classes in them you can find the class, vs each header having one class but there being so many headers you are overwhelmed by them. Use your judgement.<p>
Every kit should have a header file in it called "kit/KitDefs.h" that includes global constants and other definitions for that kit. For example see view/ViewDefs.h.<h3><a class="anchor" name="CppConstants">
Constants</a></h3>
Constant values are written in <code>UPPER_CASE</code>. If the constant is not in the namespace of a specific class/interface, then it must have a B_ prefix. Usually for constants outside of a class the first word in the constant will be a common specification of the category of constants it belongs to (i.e., <code>B_VIEW_*</code>).<h4><a class="anchor" name="CppIntegers">
Integers</a></h4>
Integer constants should be declared as an enumeration (often anonymous). Constants that represent a mask of bits in a larger constant should use the suffix <code>_MASK</code>. Some examples:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">enum</span> {
    B_JUSTIFY_MASK      = 0x0000000F,
    B_JUSTIFY_LEFT      = 0x00000001,
    B_JUSTIFY_RIGHT     = 0x00000002,
    B_JUSTIFY_FULL      = 0x00000003,
    B_JUSTIFY_CENTER    = 0x00000004,

    B_VALIGN_MASK       = 0x000000F0,
    B_VALIGN_BASELINE   = 0x00000010,
    B_VALIGN_TOP        = 0x00000020,
    B_VALIGN_BOTTOM     = 0x00000030,
    B_VALIGN_CENTER     = 0x00000040
};
</pre></div><p>
<div class="fragment"><pre class="fragment">interface <a class="code" href="classIDatum.html">IDatum</a>
{
    <span class="keyword">enum</span>
    {   
        READ_ONLY           = 0x0000,
        WRITE_ONLY          = 0x0001,
        READ_WRITE          = 0x0002,
        READ_WRITE_MASK     = 0x0003,

        ERASE_DATUM         = 0x0200,
        OPEN_AT_END         = 0x0400
    };

methods:
    ...
}
</pre></div><h4><a class="anchor" name="CppErrorCodes">
Error Codes</a></h4>
We currently treat error codes exactly like integer constants:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">enum</span> {
    <a class="code" href="group__CoreSupportUtilities.html#gga152a1">B_NO_MEMORY</a> = <a class="code" href="CmnErrors_8h.html#a114">sysErrNoFreeRAM</a>,
    <a class="code" href="group__CoreSupportUtilities.html#gga152a2">B_BAD_VALUE</a> = <a class="code" href="CmnErrors_8h.html#a112">sysErrParamErr</a>,
    <a class="code" href="group__CoreSupportUtilities.html#gga152a3">B_NOT_ALLOWED</a> = <a class="code" href="CmnErrors_8h.html#a115">sysErrNotAllowed</a>,
    <a class="code" href="group__CoreSupportUtilities.html#gga152a4">B_TIMED_OUT</a> = <a class="code" href="CmnErrors_8h.html#a111">sysErrTimeout</a>
};
</pre></div><h4><a class="anchor" name="CppStringsValues">
Strings and Values</a></h4>
<a class="el" href="classSString.html">SString</a> and <a class="el" href="classSValue.html">SValue</a> string constants can be constructed with the <a class="el" href="group__CoreSupportUtilities.html#ga89">B_CONST_STRING_VALUE_SMALL()</a> and <a class="el" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE()</a> macros. The constants these create can be both an <a class="el" href="classSString.html">SString</a> and an <a class="el" href="classSValue.html">SValue</a>. These constants can not be placed inside a class namespace, so they will always have the prefix BV_*. Some examples:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE</a>  (BV_VIEW_BYTES,         <span class="stringliteral">"bytes"</span>,);
<a class="code" href="group__CoreSupportUtilities.html#ga89">B_CONST_STRING_VALUE_SMALL</a>  (BV_VIEW_KEY,           <span class="stringliteral">"key"</span>,);
<a class="code" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE</a>  (BV_VIEW_MODIFIERS,     <span class="stringliteral">"modifiers"</span>,);
<a class="code" href="group__CoreSupportUtilities.html#ga91">B_CONST_STRING_VALUE_LARGE</a>  (BV_VIEW_REPEAT,        <span class="stringliteral">"repeat"</span>,);
</pre></div><p>
There are other macros for building SValues of other types: <a class="el" href="group__CoreSupportUtilities.html#ga93">B_CONST_INT32_VALUE()</a> and <a class="el" href="group__CoreSupportUtilities.html#ga95">B_CONST_FLOAT_VALUE()</a>.<h3><a class="anchor" name="CppGlobalFunctions">
Global Functions</a></h3>
Global functions use MixedCase, without a prefix. This distinguishes them from posix functions (which are lower_case) and is similar to the C convention for functions. Note that unlike the C convention, C++ functions do not require a manager prefix  they should instead be in the namespace of the C++ framework they are a part of.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__Core.html#ga0">status_t</a> <a class="code" href="support_2StringUtils_8h.html#a0">StringSplit</a>(<span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp; srcStr, <span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp; splitOn, <a class="code" href="classSVector.html">SVector&lt;SString&gt;</a>* strList);
<a class="code" href="group__Core.html#ga0">status_t</a> <a class="code" href="support_2StringUtils_8h.html#a0">StringSplit</a>(<span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp; srcStr, <span class="keyword">const</span> <span class="keywordtype">char</span>* splitOn, <a class="code" href="classSVector.html">SVector&lt;SString&gt;</a>* strList);

<a class="code" href="group__Core.html#ga0">status_t</a> ExecuteEffect( <span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IInterface&gt;</a>&amp; target,
                        <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;in, <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;inBindings,
                        <span class="keyword">const</span> <a class="code" href="classSValue.html">SValue</a> &amp;outBindings, <a class="code" href="classSValue.html">SValue</a> *out,
                        <span class="keyword">const</span> <a class="code" href="structeffect__action__def.html">effect_action_def</a>* actions, size_t num_actions,
                        uint32_t flags = 0);

<span class="keyword">template</span>&lt;<span class="keyword">class</span> TYPE&gt; <span class="keywordtype">void</span> Construct(TYPE* base, size_t count = 1);
<span class="keyword">template</span>&lt;<span class="keyword">class</span> TYPE&gt; <span class="keywordtype">void</span> MoveAfter(TYPE* to, TYPE* from, size_t count = 1);
<span class="keyword">template</span>&lt;<span class="keyword">class</span> TYPE&gt; <span class="keywordtype">void</span> Assign(TYPE* to, <span class="keyword">const</span> TYPE* from, size_t count = 1);
<span class="keyword">template</span>&lt;<span class="keyword">class</span> TYPE&gt; <span class="keywordtype">void</span> Swap(TYPE&amp; v1, TYPE&amp; v2);
</pre></div><h3><a class="anchor" name="CppComments">
Comments</a></h3>
We use <a class="el" href="">Doxygen </a> to automatically generate internal documentation from our source tree. For good documentation, you must correctly comment and mark up your header files as described in the <a class="el" href="">Doxygen manual. </a><p>
In general header files should have brief comments for all APIs, enough that someone browsing the file can get a basic grasp of how the API works without having so much detail that it is hard to get the overall view of what is there. The BView header file (view/View.h) serves as a good example, such as:<p>
<div class="fragment"><pre class="fragment">!	@name Utilities
	Convenience functions to retrieve general information about the view and
	perform interactions with the view hierarchy. 
//@{

! Return the Graphic plane that was given in SetGraphicPlane() 
		SGraphicPlane			GraphicPlane() const;

//!	A not-necessarily-unique identifier for your view, supplied by the parent.
virtual	SString					ViewName() const;
//!	Called by the parent to supply a name.
virtual	void					SetViewName(const SString&amp; value);

//!	Returns the parent or NULL if the view doesn't have a parent.
!	This function is potentially slow, use carefully.  It is not valid
	to call this during Draw(); this is for transaction and current state only. 
virtual	sptr&lt;IViewParent&gt;		Parent() const;

//!	Invalidate the view.
!	Use this functions preferrably over IViewParent::InvalidateChild().  If the view
	doesn't have a parent, the function returns without doing anything. 
		void					Invalidate();
//!	Invalidate() a specific rectangle in the view.
		void					Invalidate(const SRect&amp; rect);
//!	Invalidate() a specific shape in the view.
		void					Invalidate(const SRegion&amp; shape);


//! For implementation, don't use.
virtual void					Invalidate(BUpdate* update);

//!	Calls @c MarkTraversalPath() with @e constrain and @e layout flags.
!	This will eventually trigger an update as MarkTraversalPath() walks
	up in the hierarchy and encounters a @c ViewLayoutRoot object. 
virtual	status_t				InvalidateConstraints(uint32_t execFlags = 0);

//!	Request that a transaction start, if one hasn't already.
virtual	void					RequestTransaction(uint32_t execFlags = 0);

//@}
</pre></div><h2><a class="anchor" name="InterfaceConventions">
Interface Conventions</a></h2>
Interfaces describe abstract contracts that others can implement and use. They create the key APIs in the system, and as such particular care should be taken when creating them.<p>
For the most part, a more general interface is a more powerful interface: the more general it is, the more places it can be used, and thus all code written to implement or use that interface is itself more reusable.<p>
Before writing a new interface, you should first make sure there isn't an existing interface that will serve your needs. Even if there is an existing interface that is close but doesn't quite do what you want, it may make sense to modify the existing interface so it is more general instead of designing a new one.<h3><a class="anchor" name="InterfaceNamespaces">
Namespaces</a></h3>
You should place interfaces in to namespaces like the C++ namespaces described previously. Note that interfaces ultimately end up in C++ kits, so they should be named in the same way.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>support {

interface <a class="code" href="classINode.html">INode</a>
{
    ...
}

} } <span class="comment">// namespace palmos::support</span>
</pre></div><p>
This creates an interface called "org.openbinder.support.INode".<h3><a class="anchor" name="InterfaceProperties">
Properties</a></h3>
<div class="fragment"><pre class="fragment">    [readonly]<a class="code" href="classINode.html">INode</a> attributes;
    <a class="code" href="classSString.html">SString</a> mimeType;
</pre></div><p>
Property names should be mixedCase, with their first letter being lower-case.<p>
By following this convention, pidgen will automatically generate for you C++ methods following the correct convention:<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classsptr.html">sptr&lt;INode&gt;</a> Attributes() <span class="keyword">const</span>;

    <a class="code" href="classSString.html">SString</a> MimeType() <span class="keyword">const</span>;
    <span class="keywordtype">void</span> SetMimeType(<span class="keyword">const</span> <a class="code" href="classSString.html">SString</a>&amp; value);
</pre></div><h3><a class="anchor" name="InterfaceMethods">
Methods</a></h3>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__Core.html#ga0">status_t</a> Register(<a class="code" href="classSValue.html">SValue</a> <a class="code" href="TSD_8cpp.html#a1">key</a>, <a class="code" href="classIBinder.html">IBinder</a> binder);

    <a class="code" href="group__Core.html#ga0">status_t</a> Walk([inout]<a class="code" href="classSString.html">SString</a> path, uint32_t flags, [out]<a class="code" href="classSValue.html">SValue</a> node);
    <a class="code" href="group__Core.html#ga0">status_t</a> InvalidateChild(IView child, [inout]BUpdate update);
    <a class="code" href="group__Core.html#ga0">status_t</a> RemoveView(IView view, [optional]uint32_t execFlags);
    <a class="code" href="group__Core.html#ga0">status_t</a> GetStuff([out]<a class="code" href="classSValue.html">SValue</a> stuff, [optional out]<a class="code" href="classSString.html">SString</a> <a class="code" href="TSD_8cpp.html#a2">name</a>) <span class="keyword">const</span>;
</pre></div><p>
Methods should be MixedCase, with their first letter being upper-case.<p>
Output parameters can be used anywhere, though they should generally appear after input parameters. Optional parameters must be the last in the method.<h4><a class="anchor" name="InterfaceFactories">
Factories</a></h4>
<div class="fragment"><pre class="fragment">    <a class="code" href="classIIterator.html">IIterator</a> NewIterator(<a class="code" href="classSValue.html">SValue</a> args, [optional out]<a class="code" href="group__Core.html#ga0">status_t</a> outError);
</pre></div><p>
A factory method is one that generates a new instance of something each time it is called. Such methods should begin with the "New" prefix.<h3><a class="anchor" name="InterfaceEvents">
Events</a></h3>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> EntryModified(<a class="code" href="classINode.html">INode</a> who, <a class="code" href="classSString.html">SString</a> <a class="code" href="TSD_8cpp.html#a2">name</a>, <a class="code" href="classIBinder.html">IBinder</a> entry);
</pre></div><p>
Events should use the same naming convention as methods, MixedCase starting with an upper-case letter. They typically use a past-tense verb, since they are indicating that some action has happened.<h3><a class="anchor" name="InterfaceConstants">
Constants</a></h3>
<div class="fragment"><pre class="fragment">    <span class="keyword">enum</span>
    {
        CREATE_DATUM        = 0x0100,
        CREATE_CATALOG      = 0x0200,
        CREATE_MASK         = 0x0300
    };
</pre></div><p>
You can use enumerations to create integral constants. (Note that in our IDL syntax, enumerations must appear before any "properties:", "methods:", or "events:" sections.) Like constants in C classes, they should be UPPER_CASE with words separated by underscores, and not us a prefix (the interface name is the prefix).<h3><a class="anchor" name="InterfaceComments">
Comments</a></h3>
Place comments in IDL files like you would with C++, using Doxygen markup. Pidgen will automatically propagate these comments to the generated C++ header file, so that they can be incorporated into the overall documentation.<p>
<div class="fragment"><pre class="fragment">//!	Interface to a node in the Binder namespace
!	Nodes allow you to walk paths through the namespace
	and access meta-data.

interface INode
{
	enum
	{
		!	This flag can be supplied to various catalog
			functions, to indicate you would like them to
			return the contents of an IDatum instead of the
			object itself, if possible.
		
		REQUEST_DATA        = 0x1000
	};

properties:
	//!	Retrieve the meta-data catalog associated with this node, or NULL if it doesn't exist.
	[readonly]INode attributes;

methods:
	//!	Walk through the namespace based on the given path.
	!	This function decodes the first name of the path, and recursively
		calls Walk() on the entry it finds for that.
	
	status_t Walk([inout]SString path, uint32_t flags, [out]SValue node);

events:
    //! This event is sent when a new entry appears in the catalog.
    ! @param who the parent catalog in which this change occured.
        @param name the name of the entry that changed.
        @param entry the entry itself, either an INode or IDatum.
    
    void EntryCreated(INode who, SString name, IBinder entry);
}
</pre></div> <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
