<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder Shell Tutorial</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderShellTutorial">Binder Shell Tutorial</a></h1><div class="header"> <center>&lt; <a class="el" href="BinderRecipes.html">Binder Recipes</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="BinderShellData.html">Binder Shell Data</a> &gt;</center> <hr>
 </div><p>
The Binder Shell is a POSIX-compatible shell (though there are some missing features, such as pipes), which includes special extensions for interacting with the Binder. The shell serves as an example of another language that can work with the Binder runtime, and you can even write Binder components with the shell.<p>
Shell commands themselves are Binder components. That is, when executing a command, the shell finds and instantiates a Binder component that implements the specified command. This allows the shell and the commands to negotiate extensively about what process the command will run in  for example, a command can request that it run in a specific process next to an associated server, or the shell can allow some or all commands to run in its own process to improve performance.<p>
The vast majority of the Binder system is accessible through the shell, due to the underlying scripting protocol supported by the Binder. For example, you can access the persistent data store, running services, and Binder components. Because of this, the shell provides a useful way to introduce many of the Binder concepts. All of the operations described in this tutorial map directly to corresponding calls in the underlying C++ APIs.<p>
Note that the Binder Shell is not currently a replacement for a Linux command shell. In particular, it currently is not able to execute traditional Linux commands (via fork() and exec()), nor does it provide access to the underlying Linux filesystems. These are not design limitations of the shell, and we would like to add these facilities in the future.<p>
<ol type=1>
<li><a class="el" href="BinderShellTutorial.html#AccessingBinderShell">Accessing the Binder Shell</a><ol type=a>
<li><a class="el" href="BinderShellTutorial.html#ShellPrompt">The Shell Prompt</a></li></ol>
</li><li><a class="el" href="BinderShellTutorial.html#BinderNamespaceData">The Binder Namespace and Data</a><ol type=a>
<li><a class="el" href="BinderShellTutorial.html#SettingsCatalog">/settings: The Settings Catalog</a></li><li><a class="el" href="BinderShellTutorial.html#BinderData">Binder Data</a></li><li><a class="el" href="BinderShellTutorial.html#VariablesCommands">Variables and Commands</a></li></ol>
</li><li><a class="el" href="BinderShellTutorial.html#BinderObjects">Binder Objects</a><ol type=a>
<li><a class="el" href="BinderShellTutorial.html#ServicesCatalog">/services: The Services Catalog</a></li><li><a class="el" href="BinderShellTutorial.html#ExampleInformant">Example: Informant</a></li><li><a class="el" href="BinderShellTutorial.html#BinderInterfaces">Binder Interfaces</a></li><li><a class="el" href="BinderShellTutorial.html#DataModelInterfaces">Data Model Interfaces</a></li></ol>
</li><li><a class="el" href="BinderShellTutorial.html#ComponentsProcesses">Components and Processes</a><ol type=a>
<li><a class="el" href="BinderShellTutorial.html#BinderComponents">Binder Components</a></li><li><a class="el" href="BinderShellTutorial.html#ProcessesShell">/processes and new_process</a></li><li><a class="el" href="BinderShellTutorial.html#WorkingWithProcesses">Working With Processes</a></li><li><a class="el" href="BinderShellTutorial.html#ShellProcessLifetime">Process Lifetime</a></li><li><a class="el" href="BinderShellTutorial.html#ShellDynamicProcesses">Dynamic Processes</a></li><li><a class="el" href="BinderShellTutorial.html#BinderObjectIdentity">Binder Object Identity</a></li><li><a class="el" href="BinderShellTutorial.html#Contexts">/contexts: Multiple Contexts</a></li></ol>
</li><li><a class="el" href="BinderShellTutorial.html#PackageManager">The Package Manager</a><ol type=a>
<li><a class="el" href="BinderShellTutorial.html#Packages">/packages: Package Information</a></li><li><a class="el" href="BinderShellTutorial.html#PackageContents">Package Contents</a></li></ol>
</li><li><a class="el" href="BinderShellTutorial.html#ShellAdvancedTopics">Advanced Topics</a><ol type=a>
<li><a class="el" href="BinderShellTutorial.html#StrongWeakPointers">Strong and Weak Pointers</a></li><li><a class="el" href="BinderShellTutorial.html#ShellLinks">Links</a></li></ol>
</li></ol>
<h2><a class="anchor" name="ShellAdditionalMaterial">
Additional Material</a></h2>
<ul>
<li><a class="el" href="BinderShellData.html">Binder Shell Data</a> provides more detail on how to manipulate <a class="el" href="classSValue.html">SValue</a> data with the shell.</li><li><a class="el" href="BinderShellSyntax.html">Binder Shell Syntax</a> is a reference on the new syntax introduced by the shell.</li></ul>
<h2><a class="anchor" name="AccessingBinderShell">
Accessing the Binder Shell</a></h2>
From outside of the Binder system, there are two main ways you can access the shell:<p>
<ul>
<li>When starting smooved (the Binder root server), the -n or -s option will cause smooved to dump into an interactive Binder Shell session once it has finished with the boot process. This is what the build system's "make runshell" target uses.</li></ul>
<p>
<ul>
<li>When smooved is already running, the "bsh" Linux command will connect to the running smooved session and run a Binder Shell in the caller's environment. This is similar, for example, to using "bash" to start a new shell session with bash.</li></ul>
<p>
From within the Binder system, you have a number of programmatic options:<p>
<ul>
<li>The method <a class="el" href="classSContext.html#a20">SContext::RunScript()</a> will create a new shell that executes the string given to it, like the traditional POSIX system() call.</li></ul>
<p>
<ul>
<li>You can instantiate the Binder Shell component (org.openbinder.tools.BinderShell) yourself and have it execute whatever input you desire.</li></ul>
<p>
<ul>
<li>You can use the Binder Shell as a VM (called org.openbinder.tools.BinderShell.VM) to write Binder components in shell.</li></ul>
<p>
All of the examples here will assume you have gotten into the shell through the build system's "make runshell" command.<p>
Once you have the shell running, the first command you will want to know about is "help". This command can can be used in four different ways:<p>
<ul>
<li><b>help</b> by itself will display general information abiout the shell.</li><li><b>help commands</b> will display a list of all shell commands that are available and the component implementing them. This is done through a query on the <a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a>.</li><li><b>help &lt;<em>command</em>&gt;</b> will display the documentation specifically for <em>command</em>. This is provided through the standard command interface (<a class="el" href="classICommand.html">ICommand</a>), so the result depends on the what the command has implemented.</li><li><b>help examples</b> Shows some examples of things you can do with the shell. Note that some of these may not be relevant to the OpenBinder environment.</li></ul>
<h3><a class="anchor" name="ShellPrompt">
The Shell Prompt</a></h3>
When the shell is waiting for input, it will print at the begining of the line a prompt to indicate it is doing so. This prompt is usually one of three things, depending on what state the shell is in:<p>
<ul>
<li><b>CD/#</b> Indicates the shell is ready for the next command, and running on the system context. This is the usual the state when using smooved  or "make runshell"  to start the shell.</li><li><b>CD/$</b> Indicates the shell is ready for the next command, and running on the user context. This is the usual the state when using the "bsh" command or other mechanism to run the shell.</li><li><b>&gt;</b> Indicates the shell is waiting for more text for the current command.</li></ul>
<p>
The "CD" portion is the current directory of the shell, which usually starts out at the root of the namespace. As such, these are the exact shell prompts you will usually see.<p>
<div class="fragment"><pre class="fragment">/#
</pre></div><p>
<div class="fragment"><pre class="fragment">/$
</pre></div><p>
<div class="fragment"><pre class="fragment">&gt;
</pre></div><h2><a class="anchor" name="BinderNamespaceData">
The Binder Namespace and Data</a></h2>
The first command we are usually interested from a shell is "ls". There is such a command provided by the shell, but from its output you will start to notice that the Binder Shell is a little different:<p>
<div class="fragment"><pre class="fragment">/# ls
contexts/
packages/
processes/
services/
settings/
who_am_i
</pre></div><p>
What you are seeing here is the root of the <a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a>, called a "Binder Context". This is a global namespace of data and services, and all of the normal shell filesystem commands work on this namespace. The Binder Context is your connection to the rest of the Binder system  it gives access to the information needed to instantiate components, find running services, etc.<h3><a class="anchor" name="SettingsCatalog">
/settings: The Settings Catalog</a></h3>
The first directory in the namespace we will look at is <code>/settings</code>, the "settings catalog". This is a repository of persistent data  anything you place here will be put into persistent storage (currently as an XML file stored on the Linux filesystem), which is read back the next time smooved starts.<p>
For example, we can use the <code>publish</code> command to place a piece of data into the settings catalog:<p>
<div class="fragment"><pre class="fragment">/# publish /settings/vendor/foo bar
</pre></div><p>
And then later retrieve that data:<p>
<div class="fragment"><pre class="fragment">/# lookup /settings/vendor/foo
Result: "bar"
</pre></div><p>
If we were to now kill smooved and restart it, we would see that our data was still there:<p>
<div class="fragment"><pre class="fragment">/# ls -l /settings/vendor
foo -&gt; "bar"
</pre></div><p>
(Note that <code>ls -l</code> in the Binder Shell displays the data that is stored at each entry listed.)<h3><a class="anchor" name="BinderData">
Binder Data</a></h3>
Let's take a step back now and talk a little more about what we were seeing in the last examples.<p>
All data in the Binder must be language independent  that is, it must carry type as well as value information, have a consistent representation, and be able to express complex types. This facility is provided by a typed data API called <a class="el" href="classSValue.html">SValue</a>.<p>
An <a class="el" href="classSValue.html">SValue</a> is similar to a COM variant (or GLib GValue), in that it holds a typed piece of data, such as an integer, string, etc. In addition, <a class="el" href="classSValue.html">SValue</a> can also contain complex sets of mappings of any such data value (including other mappings). <a class="el" href="classSValue.html">SValue</a> also does not impose a fixed set of types, instead defining a generic representation of a type constant, length, and blob of data.<p>
Unlike a standard POSIX shell, all data that we work with in the Binder Shell is an <a class="el" href="classSValue.html">SValue</a>. This includes environment variables, command arguments, and command results. Thus when we executed this command:<p>
<div class="fragment"><pre class="fragment">/# lookup /settings/vendor/foo
Result: "bar"
</pre></div><p>
What we were seeing is that the lookup command returned the data it found under <code>/settings/vendor/foo</code>, which is an <a class="el" href="classSValue.html">SValue</a> containing the string "bar".<p>
The default data type that you create in the shell is a string, to match the standard POSIX semantics. To create types of other values, you can use a new <code>@{ }</code> shell syntax:<p>
<ul>
<li><code>@{ 10 }</code> is an integer.</li><li><code>@{ foo, bar }</code> is a set (here of strings).</li><li><code>@{ foo-&gt;bar }</code> is a mapping (here of strings).</li><li><code>@{ foo-&gt;10, 2-&gt;bar }</code> is a set of mappings (here of strings and integers).</li></ul>
<p>
Given that, we can use this with the <code>publish</code> command to place more complex data into the settings catalog:<p>
<div class="fragment"><pre class="fragment">/# publish /settings/map @{ 10 -&gt; "99" }

/# lookup /settings/map
Result: int32_t(10 or 0xa) -&gt; "99"
</pre></div><p>
<dl compact><dt><b>Note:</b></dt><dd>It is important to understand what we have done here: "settings" is a directory, and "map" is a data entry we have made in that directory. The "map" entry contains a <em>single</em> data item, containing the complex mapping <code>@{ 10 -&gt; "99" }</code></dd></dl>
The <code>@{ }</code> syntax is extremely rich. Here is a brief summary of common things you can do with it:<p>
<div class="fragment"><pre class="fragment">/# F=@{ 1.0 }              # Make a floating point number
/# I=@{ [abcd] }           # Make a 32 bit integer of ASCII chars
/# B=@{ true }             # Make a boolean
/# S=@{ "1" }              # Make a string
/# I64=@{ (int64_t)10 }    # Make a 64 bit integer
/# T=@{ (nsecs_t)123456 }  # Make a time
/# B=@{ (bool)$I64 }       # Convert to a boolean
/# I=@{ (int32_t)$S }      # Convert to an integer
/# S=@{ (string)$B }       # Convert to a string
/# M1=@{ a-&gt;$S }           # Make a mapping
/# M2=@{ a-&gt;$B, b-&gt;"foo" } # Make set of mappings
/# M=@{ $M1 + $M2 }        # Combine the mappings
/# V=@{ $M[a] }            # Look up a value in a mapping
</pre></div><p>
See <a class="el" href="BinderShellData.html">Binder Shell Data</a> for more details on the <code>@{ }</code> syntax and <a class="el" href="classSValue.html">SValue</a> data types.<h3><a class="anchor" name="VariablesCommands">
Variables and Commands</a></h3>
As mentioned, environment variables in the Binder Shell are typed:<p>
<div class="fragment"><pre class="fragment">/# VAR=something
Result: "something"
	
/# VAR=@{ 10 -&gt; "99" }
Result: int32_t(10 or 0xa) -&gt; "99"
</pre></div><p>
In addition, command results are typed and the Binder Shell introduces a new <code>$[ ]</code> syntax for easily retrieving the result of a command, much like the standard <code>$( )</code> syntax for retrieving a command's output:<p>
<div class="fragment"><pre class="fragment">/# VAR=$[lookup /settings/vendor/foo]
Result: "bar"

/# echo $VAR
bar
</pre></div><p>
This facility will be used extensively later as we look at new commands that generate complex data results.<h2><a class="anchor" name="BinderObjects">
Binder Objects</a></h2>
In addition to plain data, the type values you work with in the Binder Shell can be a more interesting kind of data  a <a class="el" href="BinderTerminology.html#BinderObjectDefn">Binder Object</a>. This facility allows the Binder Shell to deeply integrate with the rest of the Binder runtime.<h3><a class="anchor" name="ServicesCatalog">
/services: The Services Catalog</a></h3>
The next directory we will look at is <code>/services</code>, which is a standard catalog holding various active services:<p>
<div class="fragment"><pre class="fragment">/# ls /services
informant
memory_dealer
tokens/
</pre></div><p>
The data here is our new type of <a class="el" href="classSValue.html">SValue</a>, an object. For example, if we use the <code>lookup</code> command to retrieve an entry in this catalog, this is what we will see (when called from the same process as the object):<p>
<div class="fragment"><pre class="fragment">/# lookup /services/informant
Result: sptr&lt;IBinder&gt;(0x80966bc 9Informant)
</pre></div><p>
Such an object is an active entity, holding both state and the implementation for manipulating that state.<p>
Binder objects are reference counted  the object will be destroyed for you when all references on it go away. Unlike the data we saw before, objects are passed by reference, even when going across processes. For example, if you call a shell command with an object as an argument, that command will be operating on the same object as the one you gave it. Normal data, in contrast, is copied, so the command could not modify the data being held by the caller.<p>
Every Binder object provides a set of properties and methods that others can use. The Binder Shell commands <code>get</code> and <code>put</code> are used to retrieve and modify the properties on an object, respectively. The command <code>invoke</code> is used to call a method on an object. For all of these commands, the first argument is the object to operate on  either an actual object value, or a path in the namespace to an object.<h3><a class="anchor" name="ExampleInformant">
Example: Informant</a></h3>
As a demonstration, we can use the shell to invoke a method on the "informant" service. This is a Binder component that allows other objects to register for and broadcast arbitrary notifications. It has a method for broadcasting notifications that we can call like this:<p>
<div class="fragment"><pre class="fragment">/# invoke /services/informant Inform myMessage "This is some data"
</pre></div><p>
Well, okay, that wasn't very thrilling  when the system first starts up, nobody has registered to receive a notification, so there is not much we can do.<p>
Recall, however, that we mentioned earlier that Binder Shell commands are Binder components... and that includes the Binder Shell itself. In fact, there is a special shell variable called <code>$SELF</code> that provides the <a class="el" href="classIBinder.html">IBinder</a> object for the current shell. This gives us a more interesting opportunity.<p>
First, let's define a function in our current shell session:<p>
<div class="fragment"><pre class="fragment">/# function Receiver() { echo "Receiver: " $1 "," $2 "," $3; }
</pre></div><p>
We can now use the <code>$SELF</code> variable to register our shell with the informant, giving the name of our function as the method it should call:<p>
<div class="fragment"><pre class="fragment">/# invoke /services/informant RegisterForCallback "myMessage" $SELF "Receiver"
</pre></div><p>
And now let's try again the first method invocation:<p>
<div class="fragment"><pre class="fragment">/# invoke /services/informant Inform myMessage "This is some data"
/#
Receiver:  This is some data , myMessage ,
</pre></div><p>
What we see here is that after calling Inform on the informant and returning, the Informant has then called back on our shell to tell it the message that was broadcast.<p>
A look at this same kind of operation through the C++ APIs can be found in <a class="el" href="BinderRecipes.html">Binder Recipes</a>.<h3><a class="anchor" name="BinderInterfaces">
Binder Interfaces</a></h3>
Something we have glossed over so far is just how we know what methods and properties an object has. This information is provided by an "interface", a formal specification of a set of properties and methods. This specification is written in a language called IDL (Interface Description Language), like COM and CORBA. You can find all of the interfaces included with OpenBinder in the "interfaces" directory  for example, the <a class="el" href="classIInformant.html">IInformant</a> interface we have been playing with is defined in <code>interfaces/services/IInformant.idl</code>.<p>
If you are already familiar with COM or CORBA, one thing that is worth pointing out is that in the Binder these interfaces are not the core communication protocol. Instead, the standard Binder language (as defined by <a class="el" href="classIBinder.html">IBinder</a>) is a dynamically typed scripting protocol, which the Binder Shell sits directly on top of. Interfaces, then, are just formalized specifications of a scripting protocol that an <a class="el" href="classIBinder.html">IBinder</a> provides, but you do not need to know about a specific interface to operate on a Binder object.<p>
We can now look at the informant IDL file to see just what we were doing to that service:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>services {

interface <a class="code" href="classIInformant.html">IInformant</a>
{
methods:
    <span class="comment">// flags are the IBinder link flags</span>
    <a class="code" href="group__Core.html#ga0">status_t</a>    RegisterForCallback(<a class="code" href="classSValue.html">SValue</a> <a class="code" href="TSD_8cpp.html#a1">key</a>,
                                    <a class="code" href="classIBinder.html">IBinder</a> target,
                                    <a class="code" href="classSValue.html">SValue</a> method,
                                    [optional]uint32_t flags,
                                    [optional]<a class="code" href="classSValue.html">SValue</a> cookie);

    ...

    <a class="code" href="group__Core.html#ga0">status_t</a>    Inform(<a class="code" href="classSValue.html">SValue</a> <a class="code" href="TSD_8cpp.html#a1">key</a>, <a class="code" href="classSValue.html">SValue</a> information);
}

} } <span class="comment">// namespace palmos::services</span>
</pre></div><p>
You can use the <code>inspect</code> command in the shell to find out about the interfaces that an object implements. For example, we can look at our informant service:<p>
<div class="fragment"><pre class="fragment">/# inspect /services/informant
Result: "org.openbinder.services.IInformant" -&gt; sptr&lt;IBinder&gt;(0x8096794 9Informant)
</pre></div><p>
An interface can also implement multiple interfaces, in which case <code>inspect</code> will return all of them:<p>
<div class="fragment"><pre class="fragment">/# inspect /processes
Result: {
	"org.openbinder.support.INode" -&gt; sptr&lt;IBinder&gt;(0x808b5a4 14ProcessManager),
	"org.openbinder.support.ICatalog" -&gt; sptr&lt;IBinder&gt;(0x808b594 14ProcessManager),
	"org.openbinder.support.IIterable" -&gt; sptr&lt;IBinder&gt;(0x808b5b4 14ProcessManager),
	"org.openbinder.support.IProcessManager" -&gt; sptr&lt;IBinder&gt;(0x808b6b8 14ProcessManager)
}
</pre></div><p>
This brings us to another important use of <code>inspect</code>, interface selection. You can supply a second parameter to <code>inspect</code> that specifies an interface you would like; in this case inspect will return either the Binder object of that interface or <code>undefined</code> if the interface is not implemented.<p>
<div class="fragment"><pre class="fragment">/# inspect /processes org.openbinder.support.IProcessManager
Result: sptr&lt;IBinder&gt;(0x808b6b8 14ProcessManager)
</pre></div><p>
Note that like the <code>lookup</code> command, <code>inspect</code> returns its result as a typed value. You can use the <code>$[ ]</code> syntax we saw previously to retrieve that value.<h3><a class="anchor" name="DataModelInterfaces">
Data Model Interfaces</a></h3>
You may have noticed some interesting interfaces when we inspected /processes: <a class="el" href="classINode.html">INode</a>, <a class="el" href="classIIterable.html">IIterable</a>, and <a class="el" href="classICatalog.html">ICatalog</a>. These are standard interfaces for an object that contains a set of entries... that is, a directory. In fact, all of the shell commands we have been using that operate on the namespace (<code>ls</code>, <code>publish</code>, etc) are simply making calls on these standard interfaces.<p>
In other words, the entire Binder namespace is simply a hierarchy of active objects. Some of these are generic directories that we can place anything inside of (such as the <code>/services</code> directory), but often these are special implementations of the namespace interfaces. For example, the Settings Catalog that we looked at previously provides its own implementation that keeps track of all the data placed into it and saves that data out to an XML file.<p>
As an example, we can retrieve the <a class="el" href="classINode.html">INode</a> interface for the <code>/services</code> directory:<p>
<div class="fragment"><pre class="fragment">/# n=$[inspect /services org.openbinder.support.INode]
Result: sptr&lt;IBinder&gt;(0x8091d74 8BCatalog)
</pre></div><p>
One of the things that <a class="el" href="classINode.html">INode</a> does is provide access to meta-data about the namespace entries, which we can now retrieve through direct calls on the interface:<p>
<div class="fragment"><pre class="fragment">/# get $n mimeType
Result: "application/vnd.palm.catalog"

/# get $n modifiedDate
Result: nsecs_t(13107d 10h 59m 57s 746ms 551us or 0xfb7648f415af8d8)
</pre></div><p>
It is not uncommon for a service to implement both an API specific to that service, as well as the generic data model interfaces. This allows it to publish parts of itself in a standard way that is easily accessible through the shell and everything else that operates on the namespace, while at the same time providing a more specialized interface for more complicated interactions.<h2><a class="anchor" name="ComponentsProcesses">
Components and Processes</a></h2>
We are now going to look at where Binder objects come from and how they can be used to perform complicated system-level operations.<h3><a class="anchor" name="BinderComponents">
Binder Components</a></h3>
A <a class="el" href="BinderTerminology.html#ComponentDefn">Component</a> is the implementation (class) of a Binder object that has been bundled up in a <a class="el" href="BinderTerminology.html#PackageDefn">Package</a> so that the system knows about it. You identify a component by name, and we use a Java-style naming convention  the prefix being a domain name. For example, components that are part of the OpenBinder package start with <code>org.openbinder</code>. In addition, for historical reasons components that are a part of the Binder runtime itself use the prefix <code>palmos</code>.<p>
A new component instance is created with the <code>new</code> command, which takes the name of the component to instantiate and returns an <a class="el" href="classIBinder.html">IBinder</a> object of the new instance.<p>
<div class="fragment"><pre class="fragment">/# s=$[new org.openbinder.samples.Service]
Result: sptr&lt;IBinder&gt;(0x80a0194 13SampleService)

/# invoke $s Test
Result: int32_t(12 or 0xc)
</pre></div><p>
These shell commands have instantiated a sample service component that is included with OpenBinder and called a method on it.<p>
You can optionally supply a second argument to <code>new</code>, which is a set of mappings providing arguments to the component constructor.<p>
<div class="fragment"><pre class="fragment">/# s=$[new org.openbinder.samples.Service @{start-&gt;500}]
Result: sptr&lt;IBinder&gt;(0x80a19a4 13SampleService)

/# invoke $s Test
Result: int32_t(501 or 0x1f5)
</pre></div><p>
An alternative syntax for this allows you to bundle the component name with its arguments as a single complex data mapping.<p>
<div class="fragment"><pre class="fragment">/# s=$[new @{ org.openbinder.samples.Service-&gt;@{start-&gt;500} }]
Result: sptr&lt;IBinder&gt;(0x80a19a4 13SampleService)

/# invoke $s Test
Result: int32_t(501 or 0x1f5)
</pre></div><p>
This last form can be very useful when providing a component name to another entity that will instantiate it  it allows you to bundle any other additional data along with the component.<h3><a class="anchor" name="ProcessesShell">
/processes and new_process</a></h3>
Processes in the Binder are simply other objects. The main difference between a process object and a normal object is that instead of <code>new</code>, you use the special command <code>new_process</code> to create a new process object.<p>
<div class="fragment"><pre class="fragment">/# p=$[new_process my_process]
LOCK DEBUGGING ENABLED!  LOCK_DEBUG=15  LOCK_DEBUG_STACK_CRAWLS=1
START: binderproc #29572 my_process
Result: IBinder::shnd(0x2)
</pre></div><p>
The result we see here is a new kind of Binder object, a handle. Instead of being a pointer to an object in the local process, it is a descriptor to an object that lives in another process. Besides how it looks when printed, however, it operates and behaves just like the objects we have seen so far.<p>
In fact, we can use the <code>inspect</code> command to find out a little more about this process object we have:<p>
<div class="fragment"><pre class="fragment">/# inspect $p
Result: "org.openbinder.support.IProcess" -&gt; IBinder::shnd(0x2)
</pre></div><p>
If you want, you can go and look at the <a class="el" href="classIProcess.html">IProcess</a> IDL file. However, you generally won't use that interface directly, but rather use the process object with other APIs.<p>
The <code>/processes</code> catalog is used as a place where you can store references to processes that will be shared between components. The normal boot script included with OpenBinder uses this to publish a process called "background" that can be used for components that don't need a process of their own.<h3><a class="anchor" name="WorkingWithProcesses">
Working With Processes</a></h3>
A common way to work with Binder processes is to use <code>new_process</code> to create a new empty process (a sandbox) and then create components inside of it. You do this with the <code>-r</code> option on <code>new</code>, which tells <code>new</code> which process you want the object created in. Let's go back to our original example of creating a component and now create it in our process.<p>
<div class="fragment"><pre class="fragment">/# s=$[new -r $p org.openbinder.samples.Service]
Result: IBinder::shnd(0x3)

/# invoke $s Test
Result: int32_t(502 or 0x1f6)
</pre></div><p>
Notice that besides the kind of object returned, our service works just like it did when we had it running in the local process. This is a very important characteristic of the Binder  it completely hides the location of objects, making remote objects look and behave just like local objects. This gives us a lot of flexibility in deciding, even at run time, how objects will be distributed across processes.<p>
When looking at the overall system, you can see where IPC will happen simply by looking at which process objects are located in, and which objects call on to each other. Communication between objects is always 1:1  once you transfer an object reference from one process to another, that will set up a direct communication channel between them and your own process will no longer be involved. Even if your own process completely goes away, the connection you set up between the other two processes will remain undisturbed.<h3><a class="anchor" name="ShellProcessLifetime">
Process Lifetime</a></h3>
Normally a process will stay around "as long as it is needed." A process being needed is defined as there being remote references on any of its objects. (More specifically, remote <em>strong</em> references.) Thus, we can see that once we remove all references on the process we previously created, it will go away automatically:<p>
<div class="fragment"><pre class="fragment">/# p=
Result: ""

/# s=
Result: ""
/# EXIT: binderproc #29572 my_process
[SIGCHLD handler] child process 29572 exited normally with exit value 0
</pre></div><p>
The <code>stop_process</code> command gives you more control over this behavior. It takes a process object as an argument, and will have the process go away as soon as all remote reference on just that process object have been removed.<p>
<div class="fragment"><pre class="fragment">/# p=$[new_process my_process]
LOCK DEBUGGING ENABLED!  LOCK_DEBUG=15  LOCK_DEBUG_STACK_CRAWLS=1
START: binderproc #29607 my_process
Result: IBinder::shnd(0x2)

/# s=$[new -r $p org.openbinder.samples.Service]
Result: IBinder::shnd(0x3)

/# stop_process $p

/# p=
Result: ""
/# EXIT: binderproc #29607 my_process
[SIGCHLD handler] child process 29607 exited normally with exit value 0

/# invoke $s Test
Result: Unknown error (0x80004a03)
</pre></div><p>
In addition, if you use the <code>-f</code> flag with <code>stop_process</code> then the process will go away immediately, no matter what references there are on it.<p>
<div class="fragment"><pre class="fragment">/# stop_process -f $PROCESS
/# EXIT: binderproc #29568 background
hackbod@hackbod:~/lsrc/open-source/openbinder/main/dist$
</pre></div><p>
Here we used <code>stop_process</code> with our own process to make it exit. The line about the "background" process exiting is because this also causes us to drop our reference on the background process that the boot script had created.<h3><a class="anchor" name="ShellDynamicProcesses">
Dynamic Processes</a></h3>
Another way that processes can be started is because a component, in its manifest, specified that it would like to run in a particular process. The ServiceProcess sample is a demonstration of this, which we can see when instantiating the component:<p>
<div class="fragment"><pre class="fragment">/# s=$[new org.openbinder.samples.ServiceProcess]
LOCK DEBUGGING ENABLED!  LOCK_DEBUG=15  LOCK_DEBUG_STACK_CRAWLS=1
START: binderproc #29634 /home/hackbod/lsrc/open-source/openbinder/
	main/dist/build/packages/org.openbinder.samples.ServiceProcess
Result: IBinder::shnd(0x3)
</pre></div><p>
Here the component has asked that it be instantiated in a process that is dedicated to components in its package. When the first instance of the component (or other such components in this package) is created, that process is started and the component created inside of it. Additional instances of the component will be placed into the same process.<p>
We can now see this process in the <code>/process</code> catalog:<p>
<div class="fragment"><pre class="fragment">/# ls /processes
/home/hackbod/lsrc/open-source/openbinder/main/dist/build/
	packages/org.openbinder.samples.ServiceProcess
background
system
</pre></div><p>
Note that the current process manager uses the path to the component implementation as a unique name for the process, however the process manager itself is just a component that can be customized to provide whatever behavior you desire.<p>
If we make another instance of the service component, it will be created in the same process as the first one:<p>
<div class="fragment"><pre class="fragment">/# s2=$[new org.openbinder.samples.ServiceProcess]
Result: IBinder::shnd(0x4)
</pre></div><p>
Likewise other components in the package can also specify that they would like to run in the package's process:<p>
<div class="fragment"><pre class="fragment">/# s3=$[new org.openbinder.samples.ServiceProcess.Command]
Result: IBinder::shnd(0x5)
</pre></div><p>
Of course they don't need to do so, in which case they will be instantiated as normal, usually in the process of the caller.<p>
As we saw before in <a class="el" href="BinderShellTutorial.html#ShellProcessLifetime">Process Lifetime</a>, this process will continue to remain around only for as long as it is actually needed:<p>
<div class="fragment"><pre class="fragment">/# s=
Result: ""
/# s2=
Result: ""
/# s3=
Result: ""
/# EXIT: binderproc #21330 /home/hackbod/lsrc/open-source/openbinder/
	main/dist/build/packages/org.openbinder.samples.ServiceProcess
[SIGCHLD handler] child process 21330 exited normally with exit value 0
</pre></div><p>
For more on processes, see the <a class="el" href="BinderProcessModel.html">Binder Process Model</a>.<h3><a class="anchor" name="BinderObjectIdentity">
Binder Object Identity</a></h3>
Objects have a unique identity that is always maintained across processes. For example:<p>
<div class="fragment"><pre class="fragment">/# p=$[new_process secondary]
LOCK DEBUGGING ENABLED!  LOCK_DEBUG=15  LOCK_DEBUG_STACK_CRAWLS=1
START: binderproc #29658 secondary
Result: IBinder::shnd(0x4)

/# su -r $p
Starting sub-shell in system context...

/# v1=$[lookup /services/informant]
Result: IBinder::shnd(0x7)

/# v2=$[lookup /services/informant]
Result: IBinder::shnd(0x7)
</pre></div><p>
What we are seeing here is that when an object reference is transfered between processes (here from the smooved to the "secondary" process that we created), as long as the receiving process already knows about that object it will always get the same identity.<p>
However, that object will have different identities in different processes:<p>
<div class="fragment"><pre class="fragment">/# exit
/# v3=$[lookup /services/informant]
Result: sptr&lt;IBinder&gt;(0x8096744 9Informant)
</pre></div><p>
The <a class="el" href="BinderIPCMechanism.html">Binder IPC Mechanism</a> is responsible for correctly mapping between these identities as objects move between processes. In essence, this provides a capability-style security model for Binder objects  you can only perform operations for which you have been granted explicit access through a Binder object, and you can always validate the identity of an object (against an existing reference to it) when you receive it.<h3><a class="anchor" name="Contexts">
/contexts: Multiple Contexts</a></h3>
We say that a Binder object runs in a context. The context is the "global" namespace it can access, and has have been implicitly used with <code>ls</code>, <code>lookup</code>, and other commands. A component is "instantiated inside" of a context  that is, you use a context to instantiate a component, and that new component instance also uses your context.<p>
There can be more than one context. The default boot script that we have been using with smooved creates two contexts, which you can see by looking at the <code>/contexts</code> directory:<p>
<div class="fragment"><pre class="fragment">/# ls /contexts
system/
user/
</pre></div><p>
The <em>system context</em> is the one we have been in, and has complete access to all system resources. The <em>user context</em> is a more restricted environment, which is not able to do things like modify the contents of the <code>/services</code> directory.<p>
You can use the <code>su</code> command to switch between contexts (and processes, as we saw earlier):<p>
<div class="fragment"><pre class="fragment">/# lookup who_am_i
Result: "System Context"

/# su user
Starting sub-shell in new context...

/$ lookup who_am_i
Result: "User Context"

/$ exit
/# lookup who_am_i
Result: "System Context"
</pre></div><p>
The "who_am_i" entry is created by the boot script in each context, as a debugging aid.<h2><a class="anchor" name="PackageManager">
The Package Manager</a></h2>
The <a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a> is the entity responsible for keeping track of all available components and information about them. It is involved in the first step of the <code>new</code> command, providing the information about the component needed to find and instantiate it.<h3><a class="anchor" name="Packages">
/packages: Package Information</a></h3>
The <a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a> service is placed in the namespace at <code>/packages</code>, and under that directory provides a hierarchy of information associated with packages. One of the most important things here is the <code>components</code> sub-directory, which contains information about every component in the system:<p>
<div class="fragment"><pre class="fragment">/# ls /packages/components
org.openbinder.samples.Component
org.openbinder.samples.Service
org.openbinder.samples.ServiceProcess
org.openbinder.samples.ShellService
org.openbinder.kits.support.CatalogMirror
org.openbinder.services.MemoryDealer
org.openbinder.services.Settings
org.openbinder.services.TokenSource
org.openbinder.services.base.Informant
org.openbinder.tools.BinderShell
org.openbinder.tools.BinderShell.Cat
org.openbinder.tools.BinderShell.Clear
...
</pre></div><p>
Under each of these entries is a block of data describing everything about the component.<p>
<div class="fragment"><pre class="fragment">/# lookup /packages/components/org.openbinder.tools.BinderShell
Result: {
        "file" -&gt; "/home/hackbod/lsrc/open-source/openbinder/main/dist/build/packages/org.openbinder.tools.BinderShell/BinderShell.so",
        "package" -&gt; "org.openbinder.tools.BinderShell",
        "modified" -&gt; int32_t(1132535954 or 0x43812092),
        "interface" -&gt; "org.openbinder.tools.ICommand",
        "packagedir" -&gt; "/home/hackbod/lsrc/open-source/openbinder/main/dist/build/packages/org.openbinder.tools.BinderShell"
}
</pre></div><p>
When the Package Manager is started, a set of queries on the package data is also created and published in its directory. These allow you to find components for various purposes. For example, the Binder Shell itself uses the <code>/packages/bin</code> query to find the component that implements a particular shell command.<p>
<div class="fragment"><pre class="fragment">/# ls /packages/bin
[
atom
bperf
cat
clear
components
</pre></div><p>
<div class="fragment"><pre class="fragment">/# lookup /packages/bin/cat
Result: "org.openbinder.tools.BinderShell.Cat"
</pre></div><p>
You can also do queries for components implementing specific interfaces and other data in the manifest.<h3><a class="anchor" name="PackageContents">
Package Contents</a></h3>
On disk, a package is a filesystem directory containing at least a Manifest.xml file describing the contents of the package and one or more files (.so files for C++ code) containing the implementation of the components in the package. The system takes care of loading and unloading the component implementation as needed.<p>
The manifest is an XML file that provides all information to the package manager about the components in the package. Note that unlike COM, component information comes only from the static manifest file  there is no need to register a component with the package manager, and the package manager is free to reconstruct its component information from scratch at any time from the package manifests.<p>
A typical manifest file can be seen in the SampleComponent sample, which implements a Binder Shell command.<p>
<div class="fragment"><pre class="fragment">&lt;manifest&gt;
	&lt;component&gt;
		&lt;interface name="org.openbinder.app.ICommand" /&gt;
		&lt;property id="bin" type="string"&gt;sample_component&lt;/property&gt;
	&lt;/component&gt;
&lt;/manifest&gt;
</pre></div><p>
Here we can see that the package contains a single component, whose name is the same as the package name. That component implements the <a class="el" href="classICommand.html">ICommand</a> interface. The <code>&lt;property&gt;</code> tag here adds an additional property, called "bin". This is the property the Package Manager looks for to construct the <code>/packages/bin</code> query, and thus how you make the component visible to the Binder Shell.<p>
Here is a more complicated manifest, from the ServiceProcess sample. This contains two components, both of which would like to run in their own process for the entire package. The second component is a shell command.<p>
<div class="fragment"><pre class="fragment">&lt;manifest&gt;
	&lt;component&gt;
		&lt;process prefer="package" /&gt;
		&lt;interface name="org.openbinder.support.INode" /&gt;
		&lt;interface name="org.openbinder.support.IIterable" /&gt;
		&lt;interface name="org.openbinder.support.ICatalog" /&gt;
	&lt;/component&gt;
	&lt;component local="Command"&gt;
		&lt;process prefer="package" /&gt;
		&lt;interface name="org.openbinder.app.ICommand" /&gt;
		&lt;property id="bin" type="string"&gt;service_command&lt;/property&gt;
	&lt;/component&gt;
&lt;/manifest&gt;
</pre></div><h2><a class="anchor" name="ShellAdvancedTopics">
Advanced Topics</a></h2>
The remaining material in this document covers some advanced topics that you will not normally encounter in the shell itself, but are important in using the underlying C++ APIs. Just as with the other topics we have covered, the shell serves as a useful environment in which to illustrate these concepts.<h3><a class="anchor" name="StrongWeakPointers">
Strong and Weak Pointers</a></h3>
Recall that when we are working with objects in the shell, we are using a reference counting mechanism (based on <a class="el" href="classSAtom.html">SAtom</a>) so that the object will remain around as long as there are others using it.<p>
<div class="fragment"><pre class="fragment">/# s=$[new org.openbinder.samples.Service]
Result: sptr&lt;IBinder&gt;(0x809f86c 13SampleService)
</pre></div><p>
There are actually two kinds of object pointers. The one we have seen so far is a "strong pointer" or "sptr" because it ensures that the object will remain valid.<p>
The other type of reference is called a "weak pointer" or "wptr". You won't normally see these in the shell, however, we can use a cast to explicitly create a weak pointer:<p>
<div class="fragment"><pre class="fragment">/# w=@{(wptr)$s}
Result: wptr&lt;IBinder&gt;(0x809f86c 13SampleService)
</pre></div><p>
Unlike a strong pointer, an object is allowed to go away while others hold weak pointers to it. We can see this in action if we now clear the strong pointer:<p>
<div class="fragment"><pre class="fragment">/# s=
Result: ""
</pre></div><p>
What happens to our weak pointer in this case is a little subtle. If we try to invoke a method on that, it will fail, because the object is no longer valid:<p>
<div class="fragment"><pre class="fragment">/# invoke $w Test
invoke: invalid target object ''.  Not going to do an invoke.
Result: Unknown error (0x80000502)
</pre></div><p>
However, the weak pointer itself still needs to hold <em>something</em>, so if we print it we will see that it still has a valid pointer, even though the object is no longer usable:<p>
<div class="fragment"><pre class="fragment">/# echo $w
SValue(wptr&lt;IBinder&gt;(0x809f86c))
</pre></div><p>
Notice the subtle point that though we are still seeing a valid address printed, we no longer see the actual class name like we did before.<p>
If we now try to cast that weak pointer, we will see that this fails:<p>
<div class="fragment"><pre class="fragment">/# s=@{(sptr)$w}
Result: sptr&lt;IBinder&gt;((nil))
</pre></div><p>
This is, in fact, what happened when we tried to use <code>invoke</code>  it implicitly tries to convert its input to a strong pointer so it can call it, which fails. In the C++ APIs, this conversion is done explicitly through the <a class="el" href="classwptr.html#a8">wptr&lt;&gt;::promote()</a> method.<p>
Note that all of these rules for weak pointers hold for processes as well as objects. That is, a process's lifetime is determined by <em>strong</em> pointers on its objects  holding a weak pointer on an object, including the <a class="el" href="classIProcess.html">IProcess</a> object itself, will not prevent the process from going away.<h3><a class="anchor" name="ShellLinks">
Links</a></h3>
Links are a facility of the Binder object model that allows an object to send data and events out of itself, rather than passively relying on calls coming in. It is conceptually similar to, for example, signals in the Qt toolkit.<p>
There are two kinds of links an object can push: properties and methods. Properties can only be linked to other properties, and events can only be linked to methods. This restriction is because the scripting protocol for properties and methods is different.<p>
You will generally find out about what you can link to by looking at an interface's IDL file. As an example, let's look at the interface for <a class="el" href="classINode.html">INode</a>, one of the data model interfaces. It can be found in interfaces/support/INode.idl. The thing we are interested in is this event declared towards the end:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>support {

interface <a class="code" href="classINode.html">INode</a>
{
    ...

events:
    ...
    
    <span class="comment">// This event is sent when a new entry appears in the catalog.</span>
        <span class="stringliteral">"who"</span> is the parent node in which <span class="keyword">this</span> change occured.
        <span class="stringliteral">"name"</span> is the <a class="code" href="TSD_8cpp.html#a2">name</a> of the entry that changed.
        <span class="stringliteral">"entry"</span> is the entry itself, usually either an <a class="code" href="classINode.html">INode</a> or <a class="code" href="classIDatum.html">IDatum</a>.
    
    <span class="keywordtype">void</span> EntryCreated(<a class="code" href="classINode.html">INode</a> who, <a class="code" href="classSString.html">SString</a> <a class="code" href="TSD_8cpp.html#a2">name</a>, <a class="code" href="classIBinder.html">IBinder</a> entry);
    
    ...
}
</pre></div><p>
Given that, let's write a shell function that handles the same method signature:<p>
<div class="fragment"><pre class="fragment">/# function handleEntryCreated() {
	echo "Created: parent=" $1
	echo "Created: name=" $2
	echo "Created: entry=" $3
}
</pre></div><p>
We can now use the <code>link</code> shell command to set up a link from the <code>/services</code> directory to our new shell method.<p>
<div class="fragment"><pre class="fragment">/# n=$[inspect /services org.openbinder.support.INode]
Result: sptr&lt;IBinder&gt;(0x8091dc4 8BCatalog)

/# link $n $SELF @{EntryCreated-&gt;handleEntryCreated}
</pre></div><p>
This says "make a link from the object <code>$n</code> to the object <code>$SELF</code>, such that when <code>EntryCreated</code> is pushed from <code>$n</code> we will have the <code>handleEntryCreated</code> method called on <code>$SELF"</code>. And thus, upon adding a new entry to <code>/services</code>, we will see this:<p>
<div class="fragment"><pre class="fragment">/# publish /services/test linktest
Publishing: /services/test
/# Created: parent= SValue(sptr&lt;IBinder&gt;(0xb69063f4 8BCatalog))
Created: name= test
Created: entry= SValue(sptr&lt;IBinder&gt;(0x8081254 N18SDatumGeneratorInt12IndexedDatumE))
</pre></div><p>
Links are a very powerful mechanism, though not the only way to achieve the same result. Depending on your needs, you can just as well write your own notification mechanism for a specialized purpose, or use <a class="el" href="classIInformant.html">IInformant</a> for a more generalized implementation of broadcasting without using links. A plain link, however, has significant advantages in being clearly documented in IDL and a standard mechanism that many other things will be able to use without being written specifically to receive your event. <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
