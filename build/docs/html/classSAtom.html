<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: SAtom Class Reference</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1>SAtom Class Reference<br>
<small>
[<a class="el" href="group__CoreSupportUtilities.html">Utility Classes and Functions</a>]</small>
</h1><!-- doxytag: class="SAtom" --><code>#include &lt;<a class="el" href="Atom_8h-source.html">support/Atom.h</a>&gt;</code>
<p>
<p>Inheritance diagram for SAtom:
<p><center><img src="classSAtom.png" usemap="#SAtom_map" border="0" alt=""></center>
<map name="SAtom_map">
<area href="classBCreator.html" alt="BCreator" shape="rect" coords="135,56,260,80">
<area href="classBNamespaceMap.html" alt="BNamespaceMap" shape="rect" coords="135,112,260,136">
<area href="classBPackageManager_1_1Package.html" alt="BPackageManager::Package" shape="rect" coords="135,168,260,192">
<area href="classBpAtom.html" alt="BpAtom" shape="rect" coords="135,224,260,248">
<area href="classBSchemaTableNode_1_1CustomColumn.html" alt="BSchemaTableNode::CustomColumn" shape="rect" coords="135,280,260,304">
<area href="classBSchemaTableNode_1_1DataAccessor.html" alt="BSchemaTableNode::DataAccessor" shape="rect" coords="135,336,260,360">
<area href="classBSharedObject.html" alt="BSharedObject" shape="rect" coords="135,392,260,416">
<area href="classIBinder.html" alt="IBinder" shape="rect" coords="135,448,260,472">
<area href="classIInterface.html" alt="IInterface" shape="rect" coords="135,504,260,528">
<area href="classSConditionAtom.html" alt="SConditionAtom" shape="rect" coords="135,560,260,584">
<area href="classSDatumGeneratorInt.html" alt="SDatumGeneratorInt" shape="rect" coords="135,616,260,640">
<area href="classSDatumLord.html" alt="SDatumLord" shape="rect" coords="135,672,260,696">
<area href="classSHandler.html" alt="SHandler" shape="rect" coords="135,728,260,752">
<area href="classSKeyID.html" alt="SKeyID" shape="rect" coords="135,784,260,808">
<area href="classSSignalHandler.html" alt="SSignalHandler" shape="rect" coords="135,840,260,864">
<area href="classSThread.html" alt="SThread" shape="rect" coords="135,896,260,920">
</map>
<a href="classSAtom-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for a reference-counted object. 
<p>
SAtom is used with most objects that are reference counted. In particular, <a class="el" href="classIBinder.html">IBinder</a> and all Binder interfaces include SAtom, meaning all Binder objects are intrinsically reference counted using the SAtom facilities.<p>
The reference counting semantics are designed so that you will very rarely, if ever, have to directly deal with reference count management. Instead, you use the smart pointer classes <a class="el" href="classsptr.html">sptr&lt;T&gt; </a> and <a class="el" href="classwptr.html">wptr&lt;T&gt; </a> (for "strong pointer" and "weak pointer", respectively) to create pointers to SAtom objects, which will automatically manage the reference count for you. For example, the following function creates, assigns, and returns objects, in all cases maintaining proper reference counts: <div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt; MyClass &gt;</a> RefFunction(<a class="code" href="classsptr.html">sptr&lt; MyClass &gt;</a>* inOutClass)
{
    <a class="code" href="classsptr.html">sptr&lt; MyClass &gt;</a> old = *inOutClass;
    *inOutClass = <span class="keyword">new</span> MyClass;
    <span class="keywordflow">return</span> old;
}
</pre></div><p>
When deriving directly from SAtom to make your own reference counted object, you should usually use virtual inhertance so that your class can be properly mixed in with other SAtom-derived classes (ensuring there is only one SAtom object, with its single set of reference counts, for the entire final class): <div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classSAtom.html">SAtom</a>
{
};
</pre></div><p>
Weak pointers allow you to hold a reference on an SAtom object that does not prevent it from being destroyed. The only thing you can do with a weak pointer is compare its address against other weak or strong pointers (to check if they are the same object), and use the <a class="el" href="classwptr.html#a8">wptr::promote()</a> operation to attempt to obtain a strong pointer. The promotion will fail (by returning a sptr&lt;T&gt; containing NULL) if the object has already been destroyed (because all of its strong references have gone away). This mechanism is very useful to maintain parent/child relationships, where the child holds a weak pointer up to its parent: <div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classSAtom.html">SAtom</a>
{
<span class="keyword">private</span>:
    <span class="comment">// NOTE: Not thread safe!</span>
    <a class="code" href="classwptr.html">wptr&lt;MyClass&gt;</a> m_parent;
    <a class="code" href="classsptr.html">sptr&lt;MyClass&gt;</a> m_child;

<span class="keyword">public</span>:
    <span class="keywordtype">void</span> SetChild(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;MyClass&gt;</a>&amp; child)
    {
        m_child = child;
        child-&gt;SetParent(<span class="keyword">this</span>);
    }

    <span class="keywordtype">void</span> SetParent(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;MyClass&gt;</a>&amp; parent)
    {
        m_parent = parent;
    }

    <a class="code" href="classsptr.html">sptr&lt;MyClass&gt;</a> Parent()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> m_parent.promote();
    }
};
</pre></div><p>
The SAtom class includes a rich debugging facility for tracking down reference counting bugs, and especially leaks. See <a class="el" href="SAtomDebugging.html">SAtom Debugging</a> for more information on it.
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Reference Counting</h2></td></tr>
<tr><td colspan="2">Basic APIs for managing the reference count of an <a class="el" href="classSAtom.html">SAtom</a> object. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_0">Acquire</a> (const void *id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_1">AttachAtom</a> (<a class="el" href="classSAtom.html">SAtom</a> *target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tie the reference counts of two atoms together.  <a href="#z106_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_2">AttemptAcquire</a> (const void *id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_3">AttemptDecStrong</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a <a class="el" href="classSAtom.html#z106_11">DecStrong()</a> if there any strong pointers remaining.  <a href="#z106_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_4">AttemptIncStrong</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to acquire a strong pointer on this atom.  <a href="#z106_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_5">AttemptIncStrongFast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimized version of <a class="el" href="classSAtom.html#z106_4">AttemptIncStrong()</a> for release builds.  <a href="#z106_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_6">AttemptIncWeak</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to acquire a weak pointer on this atom.  <a href="#z106_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_7">AttemptIncWeakFast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimized version of <a class="el" href="classSAtom.html#z106_6">AttemptIncWeak()</a> for release builds.  <a href="#z106_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_8">AttemptRelease</a> (const void *id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structSAtom_1_1weak__atom__ptr.html">weak_atom_ptr</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_9">CreateWeak</a> (const void *cookie) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a weak reference to the atom.  <a href="#z106_9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_10">DecRefs</a> (const void *id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_11">DecStrong</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement the atom's strong pointer count.  <a href="#z106_11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_12">DecStrongFast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimized version of <a class="el" href="classSAtom.html#z106_11">DecStrong()</a> for release builds.  <a href="#z106_12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_13">DecWeak</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement the atom's weak pointer count.  <a href="#z106_13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_14">DecWeakFast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimized version of <a class="el" href="classSAtom.html#z106_13">DecWeak()</a> for release builds.  <a href="#z106_14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_15">ForceAcquire</a> (const void *id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_16">ForceIncStrong</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a strong pointer on the atom, even if it doesn't have one.  <a href="#z106_16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_17">ForceIncStrongFast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimized version of <a class="el" href="classSAtom.html#z106_16">ForceIncStrong()</a> for release builds.  <a href="#z106_17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_18">IncRefs</a> (const void *id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_19">IncStrong</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the atom's strong pointer count.  <a href="#z106_19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_20">IncStrongFast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimized version of <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> for release builds.  <a href="#z106_20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_21">IncWeak</a> (const void *id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the atom's weak pointer count.  <a href="#z106_21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_22">IncWeakFast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimized version of <a class="el" href="classSAtom.html#z106_21">IncWeak()</a> for release builds.  <a href="#z106_22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z106_23">Release</a> (const void *id) const </td></tr>

<tr><td colspan="2"><br><h2>Debugging</h2></td></tr>
<tr><td colspan="2">These methods allow you to work with the <a class="el" href="classSAtom.html">SAtom</a> reference count debugging and leak tracking mechanism as described in <a class="el" href="SAtomDebugging.html">SAtom Debugging</a>. They are only implemented on debug builds when the atom debugging facility is enabled. In other cases, they are a no-op. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_0">AtomObjectSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the size of the object. Sometimes useful to know.  <a href="#z109_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_1">Report</a> (const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classITextOutput.html">ITextOutput</a> &gt; &amp;io, uint32_t flags=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print information state and references on this atom to <em>io</em>.  <a href="#z109_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_2">StrongCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of strong pointers currently on the atom.  <a href="#z109_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_3">WeakCount</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of weak pointers currently on the atom.  <a href="#z109_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_4">ExistsAndIncStrong</a> (<a class="el" href="classSAtom.html">SAtom</a> *atom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for atom existance and acquire string reference.  <a href="#z109_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_5">ExistsAndIncWeak</a> (<a class="el" href="classSAtom.html">SAtom</a> *atom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for atom existance and acquire weak reference.  <a href="#z109_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_6">GetActiveTypeNames</a> (<a class="el" href="classSSortedVector.html">SSortedVector</a>&lt; <a class="el" href="classSString.html">SString</a> &gt; *outNames)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a set of the type names for all SAtom/SLightAtoms that currently exist.  <a href="#z109_6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_7">GetAllWithTypeName</a> (const char *typeName, <a class="el" href="classSVector.html">SVector</a>&lt; <a class="el" href="classwptr.html">wptr</a>&lt; <a class="el" href="classSAtom.html">SAtom</a> &gt; &gt; *outAtoms=NULL, <a class="el" href="classSVector.html">SVector</a>&lt; <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classSLightAtom.html">SLightAtom</a> &gt; &gt; *outLightAtoms=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return all existing atoms that are the given type name.  <a href="#z109_7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_8">LeakReport</a> (int32_t mark=0, int32_t last=-1, uint32_t flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print information about SAtom/SLightAtoms in a leak context to standard output.  <a href="#z109_8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_9">LeakReport</a> (const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classITextOutput.html">ITextOutput</a> &gt; &amp;io, int32_t mark=0, int32_t last=-1, uint32_t flags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print information about SAtom/SLightAtoms in a leak context to an output stream.  <a href="#z109_9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_10">MarkLeakReport</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a new SAtom/SLightAtom leak context and returns its identifier.  <a href="#z109_10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_11">StartWatching</a> (const B_SNS(std::) type_info *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a particular class type for watching SAtom/SLightAtom operations.  <a href="#z109_11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z109_12">StopWatching</a> (const B_SNS(std::) type_info *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a watching of a class type originally supplied to <a class="el" href="classSAtom.html#z109_11">StartWatching()</a>.  <a href="#z109_12"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Reference Count Access</h2></td></tr>
<tr><td colspan="2">Retrieve the current reference count on the object. Generally only used for debugging. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z107_0">HasManyStrongPointers</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this atom has more than one strong acquire on it.  <a href="#z107_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z107_1">HasManyWeakPointers</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this atom has more than one weak acquire on it.  <a href="#z107_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z107_2">HasStrongPointers</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this atom has any strong acquires on it.  <a href="#z107_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z107_3">HasWeakPointers</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if this atom has any weak acquires on it.  <a href="#z107_3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Custom New and Delete Operators</h2></td></tr>
<tr><td colspan="2"><a class="el" href="classSAtom.html">SAtom</a> must use its own new and delete operators to perform the bookkeeping necessary to support weak pointers. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z104_0">operator delete</a> (void *ptr, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z104_1">operator new</a> (size_t size, const B_SNS(std::) nothrow_t &amp;)  throw ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z104_2">operator new</a> (size_t size)</td></tr>

<tr><td colspan="2"><br><h2>Reference Count Owner</h2></td></tr>
<tr><td colspan="2"><a class="el" href="classSAtom.html">SAtom</a> provides a rich reference count debugging facility described in <a class="el" href="SAtomDebugging.html">SAtom Debugging</a>. For it to work, each reference on an <a class="el" href="classSAtom.html">SAtom</a> must have a unique object ID (usually a memory address) of the entity that "owns" that reference. You should use these APIs in situations where that object ID changes, so that when atom debugging is enabled others will be able to properly track their references. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z108_0">RenameOwnerID</a> (const void *newID, const void *oldID) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change an owner ID associated with this atom.  <a href="#z108_0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z108_1">MovePointersAfter</a> (<a class="el" href="classSAtom.html">SAtom</a> **newPtr, <a class="el" href="classSAtom.html">SAtom</a> **oldPtr, size_t num=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a memmove() of an array of SAtom*, updating owner IDs as needed.  <a href="#z108_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z108_2">MovePointersBefore</a> (<a class="el" href="classSAtom.html">SAtom</a> **newPtr, <a class="el" href="classSAtom.html">SAtom</a> **oldPtr, size_t num=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a memcpy() of an array of SAtom*, updating owner IDs as needed.  <a href="#z108_2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Bookkeeping</h2></td></tr>
<tr><td colspan="2">Object initialization, destruction, and lifetime management. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classSAtom.html#z105_0x0">FINISH_ATOM_ASYNC</a> =  0x0001
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z105_1">DeleteAtom</a> (const void *id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called after last <a class="el" href="classSAtom.html#z106_10">DecRefs()</a> when the life of an atom is extended.  <a href="#z105_1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z105_2">FinishAtom</a> (const void *id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Objects can optionally override this function to extend the lifetime of an atom (past the last strong reference).  <a href="#z105_2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__Core.html#ga0">status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z105_3">IncStrongAttempted</a> (uint32_t flags, const void *id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called during <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> after an atom has been released.  <a href="#z105_3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z105_4">InitAtom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called the first time a strong reference is acquired. All significant object initialization should go here.  <a href="#z105_4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z105_5">SAtom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new SAtom.  <a href="#z105_5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#z105_6">~SAtom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor called when it is time to destroy the object. Never call yourself!  <a href="#z105_6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#n0">AsyncDestructor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#n1">SAtomTracker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAtom.html#n2">SLightAtom</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAtom_1_1weak__atom__ptr.html">weak_atom_ptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a safe weak reference on an <a class="el" href="classSAtom.html">SAtom</a> object.  <a href="structSAtom_1_1weak__atom__ptr.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="z105_0"></a><!-- doxytag: member="SAtom::@2" ref="z105_0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">anonymous enum<code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="z105_0x0"></a><!-- doxytag: member="FINISH_ATOM_ASYNC" ref="z105_0x0" args="" -->FINISH_ATOM_ASYNC</em>&nbsp;</td><td>
Use with <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a> to perform asynchronous destruction. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="z105_5"></a><!-- doxytag: member="SAtom::SAtom" ref="z105_5" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAtom.html">SAtom</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a new SAtom. 
<p>
The reference counts start out at zero. You must call <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> (or create a sptr&lt;T&gt; to the SAtom) to acquire the first reference, at which point <a class="el" href="classSAtom.html#z105_4">InitAtom()</a> will be called.     </td>
  </tr>
</table>
<a class="anchor" name="z105_6"></a><!-- doxytag: member="SAtom::~SAtom" ref="z105_6" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">~<a class="el" href="classSAtom.html">SAtom</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor called when it is time to destroy the object. Never call yourself! 
<p>
Normally called inside of <a class="el" href="classSAtom.html#z106_11">DecStrong()</a> when the reference count goes to zero, but you can change that behavior with <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a>.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="z106_0"></a><!-- doxytag: member="SAtom::Acquire" ref="z106_0" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t Acquire           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Backwards compatibility. Do not use.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_0"></a><!-- doxytag: member="SAtom::AtomObjectSize" ref="z109_0" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">size_t AtomObjectSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prints the size of the object. Sometimes useful to know. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_1"></a><!-- doxytag: member="SAtom::AttachAtom" ref="z106_1" args="(SAtom *target)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> AttachAtom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAtom.html">SAtom</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>target</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tie the reference counts of two atoms together. 
<p>
After calling this function, both objects share the same reference counts and they will both be destroyed once that count goes to zero. The 'target' object must have only one strong reference on it -- the attach operation is not thread safe for that object (its current references will be transfered to the other atom). <dl compact><dt><b><a class="el" href="todo.html#_todo000051">Todo:</a></b></dt><dd>This method is not yet implemented! </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_2"></a><!-- doxytag: member="SAtom::AttemptAcquire" ref="z106_2" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AttemptAcquire           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Backwards compatibility. Do not use.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_3"></a><!-- doxytag: member="SAtom::AttemptDecStrong" ref="z106_3" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AttemptDecStrong           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform a <a class="el" href="classSAtom.html#z106_11">DecStrong()</a> if there any strong pointers remaining. 
<p>
If this atom has any outstanding strong references, this function will remove one of them and return true. Otherwise it leaves the atom as-is and returns false. Note that successful removal of the strong reference may result in the object being destroyed.<p>
Trust me, it is useful... though for very few things.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_11">DecStrong()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_4"></a><!-- doxytag: member="SAtom::AttemptIncStrong" ref="z106_4" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AttemptIncStrong           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try to acquire a strong pointer on this atom. 
<p>
You must already have a weak reference on the atom. This function will attempt to add a new strong reference to the atom. It returns true on success, in which case a new strong reference has been acquired which you must later remove with <a class="el" href="classSAtom.html#z106_11">DecStrong()</a>. Otherwise, the atom is left as-is. Failure only occurs after the atom has already had <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> called and then completely released. That is, <a class="el" href="classSAtom.html#z106_4">AttemptIncStrong()</a> will succeeded on a newly created SAtom that has never had <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> called on it. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_19">IncStrong()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_5"></a><!-- doxytag: member="SAtom::AttemptIncStrongFast" ref="z106_5" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AttemptIncStrongFast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimized version of <a class="el" href="classSAtom.html#z106_4">AttemptIncStrong()</a> for release builds. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_6"></a><!-- doxytag: member="SAtom::AttemptIncWeak" ref="z106_6" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AttemptIncWeak           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try to acquire a weak pointer on this atom. 
<p>
Attempt to acquire a weak reference on the atom. Unlike <a class="el" href="classSAtom.html#z106_4">AttemptIncStrong()</a>, you can <em>not</em> call this for the first weak reference -- it will fail in that case. Like <a class="el" href="classSAtom.html#z106_16">ForceIncStrong()</a>, if you think you need to use this you should think again. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_4">AttemptIncStrong()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_7"></a><!-- doxytag: member="SAtom::AttemptIncWeakFast" ref="z106_7" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AttemptIncWeakFast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimized version of <a class="el" href="classSAtom.html#z106_6">AttemptIncWeak()</a> for release builds. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_8"></a><!-- doxytag: member="SAtom::AttemptRelease" ref="z106_8" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool AttemptRelease           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Backwards compatibility. Do not use.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_9"></a><!-- doxytag: member="SAtom::CreateWeak" ref="z106_9" args="(const void *cookie) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structSAtom_1_1weak__atom__ptr.html">SAtom::weak_atom_ptr</a> * CreateWeak           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cookie</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a weak reference to the atom. 
<p>
Upon creation it does NOT hold a reference to the atom -- you must call <a class="el" href="structSAtom_1_1weak__atom__ptr.html#a1">SAtom::weak_atom_ptr::Increment()</a> on it first.    </td>
  </tr>
</table>
<a class="anchor" name="z106_10"></a><!-- doxytag: member="SAtom::DecRefs" ref="z106_10" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t DecRefs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Backwards compatibility. Do not use.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_11"></a><!-- doxytag: member="SAtom::DecStrong" ref="z106_11" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t DecStrong           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decrement the atom's strong pointer count. 
<p>
If this is the last strong pointer on it, <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a> will be called.    </td>
  </tr>
</table>
<a class="anchor" name="z106_12"></a><!-- doxytag: member="SAtom::DecStrongFast" ref="z106_12" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DecStrongFast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimized version of <a class="el" href="classSAtom.html#z106_11">DecStrong()</a> for release builds. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_13"></a><!-- doxytag: member="SAtom::DecWeak" ref="z106_13" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t DecWeak           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decrement the atom's weak pointer count. 
<p>
If this is the last weak pointer on it, the object will be completely deallocated. Usually this means simply freeing the remaining memory for the SAtom object instance, since the destructor was previously called when the last strong reference went away. Some SAtom objects may extend their lifetime with <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a>, in which case the object's destructor may be called at this point. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_21">IncWeak()</a>, <a class="el" href="classSAtom.html#z106_11">DecStrong()</a>, wptr&lt;&gt;</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_14"></a><!-- doxytag: member="SAtom::DecWeakFast" ref="z106_14" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void DecWeakFast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimized version of <a class="el" href="classSAtom.html#z106_13">DecWeak()</a> for release builds. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z105_1"></a><!-- doxytag: member="SAtom::DeleteAtom" ref="z105_1" args="(const void *id)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> DeleteAtom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called after last <a class="el" href="classSAtom.html#z106_10">DecRefs()</a> when the life of an atom is extended. 
<p>
If you override <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a> to not call into SAtom (and thus extend the life of your object), then this method will be called when its last reference goes away. The default implementation returns B_OK to have the object deleted. You can override this to return an error code so that the object is not destroyed.<p>
This is a very, very unusual feature and requires a lot of careful and specific management of objects and reference counts to make work. You probably want to leave it as-is.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_13">DecWeak()</a>, <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a></dd></dl>

<p>
Reimplemented in <a class="el" href="classBpAtom.html#b1">BpAtom</a>, <a class="el" href="classBpInterface.html#b3">BpInterface</a>, <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IStorage &gt;</a>, <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IMemoryDealer &gt;</a>, <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IXMLOStr &gt;</a>, <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IMemory &gt;</a>, <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IByteOutput &gt;</a>, <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IByteInput &gt;</a>, <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IMemoryHeap &gt;</a>, and <a class="el" href="classBpInterface.html#b3">BpInterface&lt; IByteSeekable &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z109_4"></a><!-- doxytag: member="SAtom::ExistsAndIncStrong" ref="z109_4" args="(SAtom *atom)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool ExistsAndIncStrong           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAtom.html">SAtom</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>atom</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check for atom existance and acquire string reference. 
<p>
Check whether the given atom currently exists, and acquire a strong pointer if so. These only work when the leak checker is turned on; otherwise, false is always returned. <dl compact><dt><b>Note:</b></dt><dd>Debugging only. Set the ATOM_DEBUG and ATOM_REPORT environment variables to use. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z109_5">ExistsAndIncWeak()</a> <p>
<a class="el" href="classSAtom.html#z109_1">Report()</a> <p>
<a class="el" href="classSAtom.html#z109_10">MarkLeakReport()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_5"></a><!-- doxytag: member="SAtom::ExistsAndIncWeak" ref="z109_5" args="(SAtom *atom)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool ExistsAndIncWeak           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAtom.html">SAtom</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>atom</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check for atom existance and acquire weak reference. 
<p>
Check whether the given atom currently exists, and acquire a weak pointer if so. These only work when the leak checker is turned on; otherwise, false is always returned. <dl compact><dt><b>Note:</b></dt><dd>Debugging only. Set the ATOM_DEBUG and ATOM_REPORT environment variables to use. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z109_4">ExistsAndIncStrong()</a> <p>
<a class="el" href="classSAtom.html#z109_1">Report()</a> <p>
<a class="el" href="classSAtom.html#z109_10">MarkLeakReport()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z105_2"></a><!-- doxytag: member="SAtom::FinishAtom" ref="z105_2" args="(const void *id)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> FinishAtom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Objects can optionally override this function to extend the lifetime of an atom (past the last strong reference). 
<p>
If you return FINISH_ATOM_ASYNC here, your object's destructor will be called asynchronously from the current thread. This is highly recommend if you must acquire a lock in the destructor, to avoid unexpected deadlocks due to things like sptr&lt;&gt; going out of scope while a lock is held.<p>
If you return an error code here, the object's destructor will not be called at this point.<p>
The default implementation will return B_OK, allowing the SAtom destruction to proceed as normal. Don't override this method unless you want some other behavior. Like <a class="el" href="classSAtom.html#z105_4">InitAtom()</a>, you do not need to call the SAtom implementation.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_11">DecStrong()</a></dd></dl>

<p>
Reimplemented in <a class="el" href="classBSchemaRowIDJoin_1_1RowNode.html#z13_5">BSchemaRowIDJoin::RowNode</a>, <a class="el" href="classBSchemaRowIDJoin_1_1JoinIterator.html#z15_0">BSchemaRowIDJoin::JoinIterator</a>, <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z29_4">BSchemaTableNode::RowNode</a>, <a class="el" href="classBSchemaTableNode_1_1QueryIterator.html#z32_0">BSchemaTableNode::QueryIterator</a>, <a class="el" href="classBInformant.html#b0">BInformant</a>, <a class="el" href="classSDatumGeneratorInt_1_1IndexedDatum.html#z42_3">SDatumGeneratorInt::IndexedDatum</a>, <a class="el" href="classBGenericIterable_1_1GenericIterator.html#z51_4">BGenericIterable::GenericIterator</a>, <a class="el" href="classBIndexedTableNode_1_1RowNode.html#z80_3">BIndexedTableNode::RowNode</a>, <a class="el" href="classBStreamDatum_1_1Stream.html#z94_2">BStreamDatum::Stream</a>, <a class="el" href="classBpAtom.html#b2">BpAtom</a>, <a class="el" href="classBpInterface.html#b4">BpInterface</a>, <a class="el" href="classBProcess_1_1ComponentImage.html#b0">BProcess::ComponentImage</a>, <a class="el" href="classBpBinder.html#b0">BpBinder</a>, <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IStorage &gt;</a>, <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IMemoryDealer &gt;</a>, <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IXMLOStr &gt;</a>, <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IMemory &gt;</a>, <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IByteOutput &gt;</a>, <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IByteInput &gt;</a>, <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IMemoryHeap &gt;</a>, and <a class="el" href="classBpInterface.html#b4">BpInterface&lt; IByteSeekable &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z106_15"></a><!-- doxytag: member="SAtom::ForceAcquire" ref="z106_15" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t ForceAcquire           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Backwards compatibility. Do not use.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_16"></a><!-- doxytag: member="SAtom::ForceIncStrong" ref="z106_16" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t ForceIncStrong           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire a strong pointer on the atom, even if it doesn't have one. 
<p>
This is just like <a class="el" href="classSAtom.html#z106_19">IncStrong()</a>, except that it is not an error to call on a SAtom that currently does not have a strong reference. If you think you need to use this, think again. <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_19">IncStrong&lt;&gt;</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_17"></a><!-- doxytag: member="SAtom::ForceIncStrongFast" ref="z106_17" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ForceIncStrongFast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimized version of <a class="el" href="classSAtom.html#z106_16">ForceIncStrong()</a> for release builds. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_6"></a><!-- doxytag: member="SAtom::GetActiveTypeNames" ref="z109_6" args="(SSortedVector&lt; SString &gt; *outNames)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GetActiveTypeNames           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSSortedVector.html">SSortedVector</a>&lt; <a class="el" href="classSString.html">SString</a> &gt; *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>outNames</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a set of the type names for all SAtom/SLightAtoms that currently exist. 
<p>
Return the type names for all atom objects that current exist.    </td>
  </tr>
</table>
<a class="anchor" name="z109_7"></a><!-- doxytag: member="SAtom::GetAllWithTypeName" ref="z109_7" args="(const char *typeName, SVector&lt; wptr&lt; SAtom &gt; &gt; *outAtoms=NULL, SVector&lt; sptr&lt; SLightAtom &gt; &gt; *outLightAtoms=NULL)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void GetAllWithTypeName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSVector.html">SVector</a>&lt; <a class="el" href="classwptr.html">wptr</a>&lt; <a class="el" href="classSAtom.html">SAtom</a> &gt; &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>outAtoms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSVector.html">SVector</a>&lt; <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classSLightAtom.html">SLightAtom</a> &gt; &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>outLightAtoms</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return all existing atoms that are the given type name. 
<p>
Retrieve all currently existing atoms that are the given type name. These are returned as an array of weak references to them, so as a side effect you will be acquiring weak references on these atoms as they are found.    </td>
  </tr>
</table>
<a class="anchor" name="z107_0"></a><!-- doxytag: member="SAtom::HasManyStrongPointers" ref="z107_0" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool HasManyStrongPointers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if this atom has more than one strong acquire on it. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Be careful how you use this information. You must already hold a strong pointer on the atom, and even then it can change from "true" to "false" before you get the result.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z107_1"></a><!-- doxytag: member="SAtom::HasManyWeakPointers" ref="z107_1" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool HasManyWeakPointers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if this atom has more than one weak acquire on it. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Be careful how you use this information. You must already hold a weak pointer on the atom, and even then it can change from "true" to "false" before you get the result.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z107_2"></a><!-- doxytag: member="SAtom::HasStrongPointers" ref="z107_2" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool HasStrongPointers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if this atom has any strong acquires on it. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Be careful how you use this information, as it can change from "true" to "false" even before you get the result.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z107_3"></a><!-- doxytag: member="SAtom::HasWeakPointers" ref="z107_3" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool HasWeakPointers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if this atom has any weak acquires on it. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Be careful how you use this information, as it can change from "true" to "false" even before you get the result.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_18"></a><!-- doxytag: member="SAtom::IncRefs" ref="z106_18" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t IncRefs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Backwards compatibility. Do not use.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_19"></a><!-- doxytag: member="SAtom::IncStrong" ref="z106_19" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t IncStrong           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increment the atom's strong pointer count. 
<p>
This is the standard reference count -- once it transitions to zero, the atom will become invalid. An atom starts with a reference count of zero, and gets invalidated the first time it transitions from one to zero. The optional <em>id</em> parameter is the memory address of the object holding this reference. It is only used for debugging.<p>
The first time you call <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> will result in <a class="el" href="classSAtom.html#z105_4">InitAtom()</a> being called.<p>
<dl compact><dt><b>See also:</b></dt><dd>sptr&lt;&gt;</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z105_3"></a><!-- doxytag: member="SAtom::IncStrongAttempted" ref="z105_3" args="(uint32_t flags, const void *id)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="group__Core.html#ga0">status_t</a> IncStrongAttempted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called during <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> after an atom has been released. 
<p>
The <em>flags</em> will be B_ATOM_FIRST_STRONG if this is the first strong reference ever acquired on the atom. The default implementation returns B_OK if B_ATOM_FIRST_STRONG is set, otherwise it returns B_NOT_ALLOWED to make the attempted <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> fail.<p>
You can override this to return B_OK when you would like an atom to continue allowing primary references. Note that this also requires overriding <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a> to return an error code, extending the lifetime of the object. Like <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a>, you do not need to call the SAtom implementation.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_4">AttemptIncStrong()</a>, <a class="el" href="classSAtom.html#z105_2">FinishAtom()</a></dd></dl>

<p>
Reimplemented in <a class="el" href="classBpAtom.html#b3">BpAtom</a>, <a class="el" href="classBpInterface.html#b5">BpInterface</a>, <a class="el" href="classBProcess_1_1ComponentImage.html#b1">BProcess::ComponentImage</a>, <a class="el" href="classBpBinder.html#b1">BpBinder</a>, <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IStorage &gt;</a>, <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IMemoryDealer &gt;</a>, <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IXMLOStr &gt;</a>, <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IMemory &gt;</a>, <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IByteOutput &gt;</a>, <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IByteInput &gt;</a>, <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IMemoryHeap &gt;</a>, and <a class="el" href="classBpInterface.html#b5">BpInterface&lt; IByteSeekable &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z106_20"></a><!-- doxytag: member="SAtom::IncStrongFast" ref="z106_20" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void IncStrongFast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimized version of <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> for release builds. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_21"></a><!-- doxytag: member="SAtom::IncWeak" ref="z106_21" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t IncWeak           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Increment the atom's weak pointer count. 
<p>
This keeps an atom from actually being freed after its last primary reference is removed. If you are only holding a weak reference on the object, you know that the memory it points to still exists, but don't know what state the object is in. The optional <em>id</em> parameter is the memory address of the object holding this reference. It is only used for debugging. <dl compact><dt><b>See also:</b></dt><dd>wptr&lt;&gt;</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z106_22"></a><!-- doxytag: member="SAtom::IncWeakFast" ref="z106_22" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void IncWeakFast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Optimized version of <a class="el" href="classSAtom.html#z106_21">IncWeak()</a> for release builds. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z105_4"></a><!-- doxytag: member="SAtom::InitAtom" ref="z105_4" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void InitAtom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called the first time a strong reference is acquired. All significant object initialization should go here. 
<p>
You can override it and do any setup you need. Note that you do not need to call the SAtom implementation. (So you can derive from two different SAtom implementations and safely call down to both of their <a class="el" href="classSAtom.html#z106_19">IncStrong()</a> methods.) <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z106_19">IncStrong()</a></dd></dl>

<p>
Reimplemented in <a class="el" href="classBSchemaDatabaseNode.html#z6_6">BSchemaDatabaseNode</a>, <a class="el" href="classBSchemaTableNode.html#z16_2">BSchemaTableNode</a>, <a class="el" href="classBSchemaTableNode_1_1DataAccessor.html#z26_2">BSchemaTableNode::DataAccessor</a>, <a class="el" href="classBSchemaTableNode_1_1RowNode.html#z29_6">BSchemaTableNode::RowNode</a>, <a class="el" href="classBSchemaTableNode_1_1QueryIterator.html#z32_1">BSchemaTableNode::QueryIterator</a>, <a class="el" href="classBPackageManager.html#a2">BPackageManager</a>, <a class="el" href="classBInformant.html#b2">BInformant</a>, <a class="el" href="classBGenericIterable_1_1GenericIterator.html#z51_5">BGenericIterable::GenericIterator</a>, <a class="el" href="classBStreamDatum_1_1Stream.html#z94_3">BStreamDatum::Stream</a>, <a class="el" href="classBpAtom.html#b4">BpAtom</a>, <a class="el" href="classBpInterface.html#b6">BpInterface</a>, <a class="el" href="classBCatalog.html#a8">BCatalog</a>, <a class="el" href="classSDatumLord.html#a0">SDatumLord</a>, <a class="el" href="classSDatumLord_1_1Datum.html#a1">SDatumLord::Datum</a>, <a class="el" href="classBRandomIterator.html#a2">BRandomIterator</a>, <a class="el" href="classBSerialObserver.html#b1">BSerialObserver</a>, <a class="el" href="classBSharedObject.html#b0">BSharedObject</a>, <a class="el" href="classBProcess_1_1ComponentImage.html#b2">BProcess::ComponentImage</a>, <a class="el" href="classBProcess.html#b0">BProcess</a>, <a class="el" href="classBTokenSource.html#a3">BTokenSource</a>, <a class="el" href="classBpBinder.html#b2">BpBinder</a>, <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IStorage &gt;</a>, <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IMemoryDealer &gt;</a>, <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IXMLOStr &gt;</a>, <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IMemory &gt;</a>, <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IByteOutput &gt;</a>, <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IByteInput &gt;</a>, <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IMemoryHeap &gt;</a>, and <a class="el" href="classBpInterface.html#b6">BpInterface&lt; IByteSeekable &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="z109_8"></a><!-- doxytag: member="SAtom::LeakReport" ref="z109_8" args="(int32_t mark=0, int32_t last=-1, uint32_t flags=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void LeakReport           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>mark</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print information about SAtom/SLightAtoms in a leak context to standard output. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_9"></a><!-- doxytag: member="SAtom::LeakReport" ref="z109_9" args="(const sptr&lt; ITextOutput &gt; &amp;io, int32_t mark=0, int32_t last=-1, uint32_t flags=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void LeakReport           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classITextOutput.html">ITextOutput</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>mark</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print information about SAtom/SLightAtoms in a leak context to an output stream. 
<p>
This function prints information about all of the currently active atoms created during the leak context <em>mark</em> up to and including the context <em>last</em>.<p>
A <em>mark</em> context of 0 is the first context; a <em>last</em> context of -1 means the current context.<p>
This is the API called by the "atom leaks" command described in <a class="el" href="SAtomDebugging.html">SAtom Debugging</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Debugging only. Set the ATOM_DEBUG and ATOM_REPORT environment variables (described in <a class="el" href="classSAtom.html#z109_1">Report()</a>) to use. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z109_1">Report()</a>, <a class="el" href="classSAtom.html#z109_10">MarkLeakReport()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_10"></a><!-- doxytag: member="SAtom::MarkLeakReport" ref="z109_10" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t MarkLeakReport           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start a new SAtom/SLightAtom leak context and returns its identifier. 
<p>
This is the API called by the "atom mark" command described in <a class="el" href="SAtomDebugging.html">SAtom Debugging</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Debugging only. Set the ATOM_DEBUG and ATOM_REPORT environment variables (described in <a class="el" href="classSAtom.html#z109_1">Report()</a>) to use. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z109_1">Report()</a>, <a class="el" href="classSAtom.html#z109_9">LeakReport()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z108_1"></a><!-- doxytag: member="SAtom::MovePointersAfter" ref="z108_1" args="(SAtom **newPtr, SAtom **oldPtr, size_t num=1)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void MovePointersAfter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAtom.html">SAtom</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>newPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSAtom.html">SAtom</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>oldPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num</em> = <code>1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform a memmove() of an array of SAtom*, updating owner IDs as needed. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z108_2"></a><!-- doxytag: member="SAtom::MovePointersBefore" ref="z108_2" args="(SAtom **newPtr, SAtom **oldPtr, size_t num=1)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void MovePointersBefore           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAtom.html">SAtom</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>newPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSAtom.html">SAtom</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>oldPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>num</em> = <code>1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform a memcpy() of an array of SAtom*, updating owner IDs as needed. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z104_0"></a><!-- doxytag: member="SAtom::operator delete" ref="z104_0" args="(void *ptr, size_t size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void operator delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z104_1"></a><!-- doxytag: member="SAtom::operator new" ref="z104_1" args="(size_t size, const B_SNS(std::) nothrow_t &amp;)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void * operator new           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const B_SNS(std::) nothrow_t &amp;&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2">  throw ()</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z104_2"></a><!-- doxytag: member="SAtom::operator new" ref="z104_2" args="(size_t size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void * operator new           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
SAtom overrides its new and delete operators for its implementation. You <em>must</em> use these operators and instantiating classes derived from SAtom. Thus a subclass can not implement its own new or delete operators, nor can you use inplace-new on a SAtom class.    </td>
  </tr>
</table>
<a class="anchor" name="z106_23"></a><!-- doxytag: member="SAtom::Release" ref="z106_23" args="(const void *id) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t Release           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Backwards compatibility. Do not use.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z108_0"></a><!-- doxytag: member="SAtom::RenameOwnerID" ref="z108_0" args="(const void *newID, const void *oldID) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void RenameOwnerID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>newID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>oldID</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change an owner ID associated with this atom. 
<p>
This is useful, for example, if you have a piece of memory with a pointer to an atom, whose memory address you have used for the reference ID. If you are moving your memory to a new location with memcpy(), you can use this function to change the ID stored in the atom for your reference.<p>
This function does nothing if atom debugging is not currently enabled.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z108_2">MovePointersBefore()</a>, <a class="el" href="classSAtom.html#z108_1">MovePointersAfter()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_1"></a><!-- doxytag: member="SAtom::Report" ref="z109_1" args="(const sptr&lt; ITextOutput &gt; &amp;io, uint32_t flags=0) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Report           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classsptr.html">sptr</a>&lt; <a class="el" href="classITextOutput.html">ITextOutput</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>io</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print information state and references on this atom to <em>io</em>. 
<p>
The <em>flags</em> may be one of B_ATOM_REPORT_FORCE_LONG, B_ATOM_REPORT_FORCE_SHORT, or B_ATOM_REPORT_FORCE_SUMMARY, as well as B_ATOM_REPORT_REMOVE_HEADER.<p>
This is the API called by the "atom report" command described in <a class="el" href="SAtomDebugging.html">SAtom Debugging</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Debugging only. Set the ATOM_DEBUG and ATOM_REPORT environment variables to use.</dd></dl>
This function only works if you are linking with a library that contains debugging code and have set the ATOM_DEBUG environment variable. Choices for ATOM_DEBUG are:<ul>
<li>&lt;= 0: Debugging disabled.</li><li>&lt;= 5: Simple debugging -- create/delete statistics only.</li><li>&lt;= 10: Full SAtom debugging enabled.</li></ul>
<p>
In addition, you can modify the default <a class="el" href="classSAtom.html#z109_1">Report()</a> format with the ATOM_REPORT environment variable:<ul>
<li>&lt;= 0: Short summary report.</li><li>&lt;= 5: One-line call stacks.</li><li>&lt;= 10: Call stacks with full symbols.</li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_11"></a><!-- doxytag: member="SAtom::StartWatching" ref="z109_11" args="(const B_SNS(std::) type_info *type)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void StartWatching           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const B_SNS(std::) type_info *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a particular class type for watching SAtom/SLightAtom operations. 
<p>
When a watch is in effect, SAtom will print to standard out whenever significant operations happen on an object of the watched type. Note that they must be <em>exactly</em> this type -- subclasses are not included. Use <a class="el" href="classSAtom.html#z109_12">StopWatching()</a> to remove a watched type. <dl compact><dt><b>Note:</b></dt><dd>Debugging only. Set the ATOM_DEBUG and ATOM_REPORT environment variables to use. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAtom.html#z109_1">Report()</a> <p>
<a class="el" href="classSAtom.html#z109_10">MarkLeakReport()</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_12"></a><!-- doxytag: member="SAtom::StopWatching" ref="z109_12" args="(const B_SNS(std::) type_info *type)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void StopWatching           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const B_SNS(std::) type_info *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a watching of a class type originally supplied to <a class="el" href="classSAtom.html#z109_11">StartWatching()</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_2"></a><!-- doxytag: member="SAtom::StrongCount" ref="z109_2" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t StrongCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of strong pointers currently on the atom. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Debugging only. The returned value is no longer valid as soon as you receive it. See <a class="el" href="classSAtom.html#z107_2">HasStrongPointers()</a> and <a class="el" href="classSAtom.html#z107_0">HasManyStrongPointers()</a> for safer APIs.</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="z109_3"></a><!-- doxytag: member="SAtom::WeakCount" ref="z109_3" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int32_t WeakCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of weak pointers currently on the atom. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Debugging only. The returned value is no longer valid as soon as you receive it. See <a class="el" href="classSAtom.html#z107_2">HasStrongPointers()</a> and <a class="el" href="classSAtom.html#z107_0">HasManyStrongPointers()</a> for safer APIs.</dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="n0"></a><!-- doxytag: member="SAtom::AsyncDestructor" ref="n0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class AsyncDestructor<code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n1"></a><!-- doxytag: member="SAtom::SAtomTracker" ref="n1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class <a class="el" href="classSAtomTracker.html">SAtomTracker</a><code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="n2"></a><!-- doxytag: member="SAtom::SLightAtom" ref="n2" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class <a class="el" href="classSLightAtom.html">SLightAtom</a><code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Atom_8h-source.html">Atom.h</a><li><a class="el" href="Atom_8cpp.html">Atom.cpp</a></ul>
<div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
