<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder IPC Mechanism</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderIPCMechanism">Binder IPC Mechanism</a></h1><div class="header"> <center>&lt; <a class="el" href="BinderProcessModel.html">Binder Process Model</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="pidgen.html">pidgen</a> &gt;</center> <hr>
 </div><p>
The Binder communicates between processes using a small custom kernel module. This is used instead of standard Linux IPC facilities so that we can efficiently model our IPC operations as "thread migration". That is, an IPC between processes looks as if the thread instigating the IPC has hopped over to the destination process to execute the code there, and then hopped back with the result.<p>
The Binder IPC mechanism itself, however, is not actually implemented using thread migration. Instead, the Binder's user-space code maintains a pool of available threads in each process, which are used to process incoming IPCs and execute local events in that process. The kernel module emulates a thread migration model by propagating thread priorities across processes as IPCs are dispatched and ensuring that, if an IPC recurses back into an originating process, the IPC is handled by its originating thread.<p>
In addition to IPC itself, the Binder's kernel module is also resposible for tracking object references across processes. This involves mapping from remote object references in one process to the real object in its host process, and making sure that objects are not destroyed as long as other processes hold references on them.<p>
The rest of this document will describe in detail how Binder IPC works. These details are not exposed to application developers, so they can be safely ignored.<h2><a class="anchor" name="GettingStarted">
Getting Started</a></h2>
When a user-space thread wants to participate in Binder IPC (either to send an IPC to another process or to receiving an incoming IPC), the first thing it must do is open the driver supplied by the Binder kernel module. This associates a file descriptor with that thread, which the kernel module uses to identify the initiators and recipients of Binder IPCs.<p>
It is through this file descriptor that all interaction with the IPC mechanism will happen, through a small set of ioctl() commands. The main commands are:<p>
<ul>
<li><b>BINDER_WRITE_READ</b> sends zero or more Binder operations, then blocks waiting to receive incoming operations and return with a result. (This is the same as doing a normal write() followed by a read() on the file descriptor, just a little more efficient.)</li><li><b>BINDER_SET_WAKEUP_TIME</b> sets the time at which the next user-space event is scheduled to happen in the calling process.</li><li><b>BINDER_SET_IDLE_TIMEOUT</b> sets the time threads will remain idle (waiting for a new incoming transaction) before they time out.</li><li><b>BINDER_SET_REPLY_TIMEOUT</b> sets the time threads will block waiting for a reply until they time out.</li><li><b>BINDER_SET_MAX_THREADS</b> sets the maximum number of threads that the driver is allowed to create for that process's thread pool.</li></ul>
<p>
The key command is BINDER_WRITE_READ, which is the basis for all IPC operations. Before going into detail about that, however, it should be mentioned that the driver expects the user code to maintain a pool of threads waiting for incoming transactions. You need to ensure that there is always a thread available (up to the maximum number of threads you would like) so that IPCs can be processed. The driver also takes care of waking up threads in the pool when it is time to process new asynchronous events (from <a class="el" href="classSHandler.html">SHandler</a>) in the local process.<h3><a class="anchor" name="BINDER_WRITE_READ">
BINDER_WRITE_READ</a></h3>
As mentioned, the core functionality of the driver is encapsulated in the BINDER_WRITE_READ operation. The ioctl's data is this structure:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span><a class="code" href="structbinder__write__read.html">binder_write_read</a>
{
    ssize_t     write_size;
    <span class="keyword">const</span> <span class="keywordtype">void</span>* write_buffer;
    ssize_t     read_size;
    <span class="keywordtype">void</span>*       read_buffer;
};
</pre></div><p>
Upon calling the driver, <em>write_buffer</em> contains a series of commands for it to perform, and upon return <em>read_buffer</em> is filled in with a series of responses for the thread to execute. In general the write buffer will consist of zero or more book-keeping commands (usually incrementing/decrementing object references) and ending with a command requiring a response (such as sending an IPC transaction or attempt to acquire a strong reference on a remote object). Likewise, the receive buffer will be filled with a series of book-keeping commands and end with either the result for the last written command, or a command to perform a new nested operation.<p>
Here is a list of the commands that can be sent by a process to the driver, with comments describing the data that follows each command in the buffer:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">enum</span> <a class="code" href="binder__module_8h.html#a70">BinderDriverCommandProtocol</a> {
    <a class="code" href="binder__module_8h.html#a70a46">bcNOOP</a> = 0,
        No parameters! 

    <a class="code" href="binder__module_8h.html#a70a47">bcTRANSACTION</a>,
    <a class="code" href="binder__module_8h.html#a70a48">bcREPLY</a>,
    
        <a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a>: the sent command.
    
    
    <a class="code" href="binder__module_8h.html#a70a49">bcACQUIRE_RESULT</a>,
    
        int32:  0 <span class="keywordflow">if</span> the last <a class="code" href="binder__module_8h.html#a69a41">brATTEMPT_ACQUIRE</a> was not successful.
        Else you have acquired a primary reference on the object.
    
    
    <a class="code" href="binder__module_8h.html#a70a50">bcFREE_BUFFER</a>,
    
        <span class="keywordtype">void</span> *: ptr to transaction data received on a read
    
    
    <a class="code" href="binder__module_8h.html#a70a52">bcINCREFS</a>,
    <a class="code" href="binder__module_8h.html#a70a53">bcACQUIRE</a>,
    <a class="code" href="binder__module_8h.html#a70a54">bcRELEASE</a>,
    <a class="code" href="binder__module_8h.html#a70a55">bcDECREFS</a>,
    
        int32:  descriptor
    
    
    <a class="code" href="binder__module_8h.html#a70a58">bcATTEMPT_ACQUIRE</a>,
    
        int32:  priority
        int32:  descriptor
    
    
    bcRESUME_THREAD,
    
        int32:  thread ID
    
    
    <a class="code" href="binder__module_8h.html#a70a60">bcSET_THREAD_ENTRY</a>,
    
        <span class="keywordtype">void</span> *: thread entry function <span class="keywordflow">for</span> <span class="keyword">new</span> threads created to handle tasks
        <span class="keywordtype">void</span> *: argument passed to those threads
    
    
    <a class="code" href="binder__module_8h.html#a70a61">bcREGISTER_LOOPER</a>,
    
        No parameters.
        Register a spawned looper thread with the device.  This must be
        called by the function that is supplied in bcSET_THREAD_ENTRY as
        part of its initialization with the binder.
    
    
    <a class="code" href="binder__module_8h.html#a70a62">bcENTER_LOOPER</a>,
    <a class="code" href="binder__module_8h.html#a70a63">bcEXIT_LOOPER</a>,
    
        No parameters.
        These two commands are sent as an application-level thread
        enters and exits the binder loop, respectively.  They are
        used so the binder can have an accurate count of the number
        of looping threads it has available.
    
    
    bcCATCH_ROOT_OBJECTS,
    
        No parameters.
        Call <span class="keyword">this</span> to have your team start catching root objects
        published by other teams that are spawned outside of the binder.
        When <span class="keyword">this</span> happens, you will receive a <a class="code" href="binder__module_8h.html#a69a32">brTRANSACTION</a> with the
        <a class="code" href="binder__module_8h.html#a68a26">tfRootObject</a> flag set.  (Note that <span class="keyword">this</span> is distinct from receiving
        normal root objects, which are a <a class="code" href="binder__module_8h.html#a69a33">brREPLY</a>.)
    
    
    bcKILL_TEAM
    
        No parameters.
        Simulate death of a kernel team.  For debugging only.
    
};
</pre></div><p>
The most interesting commands here are bcTRANSACTION and bcREPLY, which initiate an IPC transaction and return a reply for a transaction, respectively. The data structure following these commands is:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">enum</span> <a class="code" href="binder__module_8h.html#a68">transaction_flags</a> {
    <a class="code" href="binder__module_8h.html#a68a24">tfInline</a> = 0x01,            <span class="comment">// not yet implemented</span>
    <a class="code" href="binder__module_8h.html#a68a26">tfRootObject</a> = 0x04,        <span class="comment">// contents are the component's root object</span>
    <a class="code" href="binder__module_8h.html#a68a27">tfStatusCode</a> = 0x08         <span class="comment">// contents are a 32-bit status code</span>
};

<span class="keyword">struct </span><a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a>
{
    <span class="comment">// The first two are only used for bcTRANSACTION and brTRANSACTION,</span>
    <span class="comment">// identifying the target and contents of the transaction.</span>
    <span class="keyword">union </span>{
        size_t  handle;     <span class="comment">// target descriptor of command transaction</span>
        <span class="keywordtype">void</span>    *ptr;       <span class="comment">// target descriptor of return transaction</span>
    } target;
    uint32  code;           <span class="comment">// transaction command</span>
    
    <span class="comment">// General information about the transaction.</span>
    uint32  flags;
    int32   priority;       <span class="comment">// requested/current thread priority</span>
    size_t  data_size;      <span class="comment">// number of bytes of data</span>
    size_t  offsets_size;   <span class="comment">// number of bytes of object offsets</span>
    
    <span class="comment">// If this transaction is inline, the data immediately</span>
    <span class="comment">// follows here; otherwise, it ends with a pointer to</span>
    <span class="comment">// the data buffer.</span>
    <span class="keyword">union </span>{
        <span class="keyword">struct </span>{
            <span class="keyword">const</span> <span class="keywordtype">void</span>  *buffer;    <span class="comment">// transaction data</span>
            <span class="keyword">const</span> <span class="keywordtype">void</span>  *offsets;   <span class="comment">// binder object offsets</span>
        } ptr;
        uint8   buf[8];
    } data;
};
</pre></div><p>
Thus, to initiate an IPC transaction, you will essentially perform a BINDER_READ_WRITE ioctl with the write buffer containing bcTRANSACTION follewed by a <a class="el" href="structbinder__transaction__data.html">binder_transaction_data</a>. In this structure <em>target</em> is the handle of the object that should receive the transaction (we'll talk about handles later), <em>code</em> tells the object what to do when it receives the transaction, <em>priority</em> is the thread priority to run the IPC at, and there is a <em>data</em> buffer containing the transaction data, as well as an (optional) additional <em>offsets</em> buffer of meta-data.<p>
Given the <em>target</em> handle, the driver determines which process that object lives in and dispatches this transaction to one of the waiting threads in its thread pool (spawning a new thread if needed). That thread is waiting in a BINDER_WRITE_READ ioctl() to the driver, and so returns with its read buffer filled in with the commands it needs to execute. These commands a very similar to the write commands, for the most part corresponding to write operations on the other side:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">enum</span> <a class="code" href="binder__module_8h.html#a69">BinderDriverReturnProtocol</a> {
    <a class="code" href="binder__module_8h.html#a69a28">brERROR</a> = -1,
    
        int32: error code
    
    
    <a class="code" href="binder__module_8h.html#a69a29">brOK</a> = 0,
    <a class="code" href="binder__module_8h.html#a69a30">brTIMEOUT</a>,
    <a class="code" href="binder__module_8h.html#a69a31">brWAKEUP</a>,
        No parameters! 
    
    <a class="code" href="binder__module_8h.html#a69a32">brTRANSACTION</a>,
    <a class="code" href="binder__module_8h.html#a69a33">brREPLY</a>,
    
        <a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a>: the received command.
    
    
    <a class="code" href="binder__module_8h.html#a69a34">brACQUIRE_RESULT</a>,
    
        int32: 0 <span class="keywordflow">if</span> the last <a class="code" href="binder__module_8h.html#a70a58">bcATTEMPT_ACQUIRE</a> was not successful.
        Else the remote object has acquired a primary reference.
    
    
    <a class="code" href="binder__module_8h.html#a69a35">brDEAD_REPLY</a>,
    
        The target of the last transaction (either a <a class="code" href="binder__module_8h.html#a70a47">bcTRANSACTION</a> or
        a <a class="code" href="binder__module_8h.html#a70a58">bcATTEMPT_ACQUIRE</a>) is no longer with us.  No parameters.
    
    
    <a class="code" href="binder__module_8h.html#a69a36">brTRANSACTION_COMPLETE</a>,
    
        No parameters... always refers to the last transaction requested
        (including replies).  Note that <span class="keyword">this</span> will be sent even <span class="keywordflow">for</span> asynchronous
        transactions.
    
    
    <a class="code" href="binder__module_8h.html#a69a37">brINCREFS</a>,
    <a class="code" href="binder__module_8h.html#a69a38">brACQUIRE</a>,
    <a class="code" href="binder__module_8h.html#a69a39">brRELEASE</a>,
    <a class="code" href="binder__module_8h.html#a69a40">brDECREFS</a>,
    
        <span class="keywordtype">void</span> *: ptr to binder
    
    
    <a class="code" href="binder__module_8h.html#a69a41">brATTEMPT_ACQUIRE</a>,
    
        int32:  priority
        <span class="keywordtype">void</span> *: ptr to binder
    
    
    <a class="code" href="binder__module_8h.html#a69a42">brEVENT_OCCURRED</a>,
    
        This is returned when the bcSET_NEXT_EVENT_TIME has elapsed.
        At <span class="keyword">this</span> point the next event time is set to <a class="code" href="group__CoreSupportUtilities.html#ga116">B_INFINITE_TIMEOUT</a>,
        so you must send another bcSET_NEXT_EVENT_TIME command <span class="keywordflow">if</span> you
        have another event pending.
    
    
    <a class="code" href="binder__module_8h.html#a69a45">brFINISHED</a>
};
</pre></div><p>
Continuing our example, the receiving thread will come back with a brTRANSACTION command at the end of its buffer. This command uses the same <a class="el" href="structbinder__transaction__data.html">binder_transaction_data</a> structure that was used to send the data, basically containing the same information that was sent but now available in the local process space.<p>
The recipient, in user space will then hand this transaction over to the target object for it to execute and return its result. Upon getting the result, a new write buffer is created containing the bcREPLY reply command with a <a class="el" href="structbinder__transaction__data.html">binder_transaction_data</a> structure containing the resulting data. This is returned with a BINDER_WRITE_READ ioctl() on the driver, sending the reply back to the original process and leaving the thread waiting for the next transaction to perform.<p>
The original thread finally returns back from its own BINDER_WRITE_READ with a brREPLY command containing the reply data.<p>
Note that the original thread may also receive brTRANSACTION commands while it is waiting for a reply. This represents a recursion across processes  the receiving thread making a call on to an object back in the original process. It is the responsibility of the driver to keep track of all active transactions, so it can dispatch transactions to the correct thread when recursion happens.<h3><a class="anchor" name="ObjectMappingAndReferencing">
Object Mapping and Referencing</a></h3>
One of the important responsibilities of the driver is to perform mapping of objects from one process to another. This is key to both the communication mechanism (targetting and referencing objects) as well as the capability model (only allowing a particular process to perform operations on remote objects that it has been explicitly given knowledge about).<p>
There are two distinct forms of an object reference: as an address in a processes's memory space, or as an abstract 32-bit handle. These representations are mutually exclusive: <b>all</b> references in a process to objects local to that process are in the form of an address, while all references to objects in another process are always in the form of a handle.<p>
For example, note the <em>target</em> field of <a class="el" href="structbinder__transaction__data.html">binder_transaction_data</a>. When sending a transaction, this contains a handle to the destination object (because you always send transactions to other processes). The recipient of the transaction, however, sees this as a point to the object in its local address space. The driver maintains mappings of pointers and handles between processes so that it can perform this translation.<p>
We also must be able to send references to objects through transactions. This is done by placing the object reference (either a local pointer or remote handle) in to the transaction buffer. The driver must translate this reference to the corresponding reference in the receiving process, however, just like we do with the transaction target.<p>
In order to do reference translation, the driver needs to know where these references appear in the transaction data. This is where the additional <em>offsets</em> buffer comes in. It contains of a series of indicies into the data buffer, describing where objects appear. The driver can then rewrite the buffer data, translating each of those objects from the sending process reference to the correct reference in the receiving process.<p>
Note that the driver does not know anything about a particular Binder object until that object is sent through the driver to another process. At that point the driver adds the object's address to its mapping table and asks the owning process to hold a reference on it. When no other processes know about the object, it is removed from the mapping table and its owning process is told to release the driver's reference. This avoids maintaining the (relatively significant) driver state for an object as long as it is only used in its local process. <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:33 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
