<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: Binder Terminology</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="BinderTerminology">Binder Terminology</a></h1><center>&lt; <a class="el" href="BinderShellSyntax.html">Binder Shell Syntax</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="BinderProcessModel.html">Binder Process Model</a> &gt;</center> <hr>
<h2><a class="anchor" name="Alphabetical">
Alphabetical</a></h2>
<ul>
<li><a class="el" href="BinderTerminology.html#BinderDefn">Binder</a></li><li><a class="el" href="BinderTerminology.html#BinderObjectDefn">Binder Object</a></li><li><a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a></li><li><a class="el" href="BinderTerminology.html#ComponentDefn">Component</a></li><li><a class="el" href="BinderTerminology.html#ContextDefn">Context</a></li><li><a class="el" href="BinderTerminology.html#InspectDefn">Inspect</a></li><li><a class="el" href="BinderTerminology.html#InterfaceDefn">Interface</a></li><li><a class="el" href="BinderTerminology.html#LinkDefn">Link</a></li><li><a class="el" href="BinderTerminology.html#PackageDefn">Package</a></li><li><a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a></li><li><a class="el" href="BinderTerminology.html#ServiceDefn">Service</a></li></ul>
<h2><a class="anchor" name="Conceptual">
Conceptual</a></h2>
<h3><a class="anchor" name="BinderDefn">
Binder</a></h3>
We use this word in two ways: <em>The Binder</em> refers to the overall Binder architecture; <em>a Binder</em> is a particular implementation of a Binder interface. The name "Binder" comes from its ability to provide bindings to functions and data from one language or execution environment to another.<h3><a class="anchor" name="BinderObjectDefn">
Binder Object</a></h3>
Any entity that implements <a class="el" href="classIBinder.html">IBinder</a>, the core <a class="el" href="BinderTerminology.html#BinderDefn">Binder</a> interface. In practice, this generally means a class that derives from <a class="el" href="classBBinder.html">BBinder</a>, the standard base implementation of <a class="el" href="classIBinder.html">IBinder</a>. A Binder object is able to execute the core Binder operations: inspect, effect (a generalization of put/get/invoke), link, etc.<p>
"Binder Object" is a very general concept: it says nothing about the language used, how the object was created (through the Package Manager or just manually by calling C++ new), the process it lives in, etc. It is simply something that has implemented <a class="el" href="classIBinder.html">IBinder</a>, however that may be.<p>
What is the difference between "Binder object" and "a Binder"? Any class that implements <a class="el" href="classIBinder.html">IBinder</a> is a Binder object; that class may implement <a class="el" href="classIBinder.html">IBinder</a> multiple times for each of the interfaces it supports, and each of those is "a Binder". So a Binder object may have muliple Binders. For example, see <a class="el" href="classBIndexedDataNode.html">BIndexedDataNode</a>, a class that contains two Binders: one for its <a class="el" href="classINode.html">INode</a> interface, and one for its <a class="el" href="classIIterable.html">IIterable</a> interface.<h3><a class="anchor" name="ComponentDefn">
Component</a></h3>
A <a class="el" href="BinderTerminology.html#BinderObjectDefn">Binder Object</a> that has been published in the Package Manager. Components are instantiated with <a class="el" href="classSContext.html#a6">SContext::New()</a> or <a class="el" href="classSContext.html#a18">SContext::RemoteNew()</a>, allowing both late binding to the implementation and the instantiation of components in other languages and processes. This is in contrast to instantiating a Binder Object with the C++ operator new, where you must link to a specific C++ implementation and instantiate the object in your local process.<p>
Components use a Java-style naming scheme, such as com.palmsource.apps.AddressBook. Most system components are in the org.openbinder.* namespace.<h3><a class="anchor" name="PackageDefn">
Package</a></h3>
A Package contains one or more <a class="el" href="BinderTerminology.html#ComponentDefn">Component</a> implementations. The key elements of a package are (1) the executable code implementing those components, and (2) a "manifest file" that describes the components implemented by that code. The code of a package exports a function called InstantiateComponent(), which is the factory for the components it implements. The <a class="el" href="BinderTerminology.html#PackageManagerDefn">Package Manager</a> scans through all of the manifest files in the system to collect information about all of the available components, and returns the information associated with a component as needed.<p>
Note that unlike COM, component information is maintained statically. There is not a Registry-like entity that keeps track of information about the components; instead, a component's information is constructed as needed directly from the manifest file that is part of a package.<h3><a class="anchor" name="PackageManagerDefn">
Package Manager</a></h3>
The Package Manager is a sub-system of the Binder responsible for keeping track of the available components and implementing the dynamic component instantiation and management facilities.<p>
There are actually two distinct parts to the Package Manager:<p>
<ol type=1>
<li>The Package Manager service, published in /packages in the <a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a>, is responsible for collecting package information and providing access to it through the <a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a>. In particular, it presents under /packages/components all of the available components and information associated with them that is needed to load and instantiate them in a process.</li></ol>
<p>
<ol type=1>
<li>The <a class="el" href="classSPackage.html">SPackage</a>, <a class="el" href="classSPackageSptr.html">SPackageSptr</a>, SSharedObject, and <a class="el" href="classBProcess.html">BProcess</a> classes are responsible for loading package code into a process, managing its lifetime, providing access to resources in a package, and instantiating objects from it.</li></ol>
<p>
Finally, the <a class="el" href="classSContext.html#a6">SContext::New()</a> API brings these pieces together two provide the Binder's formal component instantiation facility: it queries the Package Manager service for information about the requested component, and then calls <a class="el" href="classIProcess.html#a2">IProcess::InstantiateComponent()</a> to have that component loaded and instantied in the desired process.<h3><a class="anchor" name="InterfaceDefn">
Interface</a></h3>
A well-defined set of methods, properties, and events that a <a class="el" href="BinderTerminology.html#BinderDefn">Binder</a> can implement. These are usually described in IDL (see <code>interfaces/...</code>), converted by the pidgen tool to a C++ header and implementation. In C++, instead of deriving directly from <a class="el" href="classBBinder.html">BBinder</a>, you will usually derive from some Bn* class generated by pidgen (such as <a class="el" href="classBnDatum.html">BnDatum</a>), which gives you a <a class="el" href="classBBinder.html">BBinder</a> that is configured to implement a particular interface.<h3><a class="anchor" name="InspectDefn">
Inspect</a></h3>
Every <a class="el" href="BinderTerminology.html#InterfaceDefn">Interface</a> has an associated <a class="el" href="BinderTerminology.html#BinderDefn">Binder</a>. A <a class="el" href="BinderTerminology.html#BinderObjectDefn">Binder Object</a> that implements multiple interfaces will thus have multiple Binders, one for each of its interfaces. You cast between these Binders/Interfaces using the <a class="el" href="classIBinder.html#a7">IBinder::Inspect()</a> call. <a class="el" href="BinderInspect.html">Binder Inspect() Details</a> has more details on this process.<h3><a class="anchor" name="BinderNamespaceDefn">
Binder Namespace</a></h3>
The Binder Namespace is a hierarchical orginization of <a class="el" href="BinderTerminology.html#BinderDefn">Binder</a> objects. It is constructed using the <a class="el" href="BinderDataModel.html">Binder Data Model</a> interfaces. Directories implement <a class="el" href="classINode.html">INode</a>, and may implement any other interfaces for additional capabilities (almost always <a class="el" href="classIIterable.html">IIterable</a>, very often <a class="el" href="classICatalog.html">ICatalog</a>). Leaf objects implement <a class="el" href="classIDatum.html">IDatum</a> if they contain a flat data stream (such as a file), but are not required to do so and often implement other interfaces.<h3><a class="anchor" name="ContextDefn">
Context</a></h3>
Each <a class="el" href="BinderTerminology.html#BinderObjectDefn">Binder Object</a> is created in a "context", represented by the <a class="el" href="classSContext.html">SContext</a> object. The context is the thing that holds all of the global state the object can access  services, settings, information about components it can instantiate, etc. The <a class="el" href="classSContext.html">SContext</a> you are running in is easily accessible through the <a class="el" href="classBBinder.html#a3">BBinder::Context()</a> method. For example, to find the Window Manager service, you would write code within your Binder Object along the lines of <em>Context().LookupService(<a class="el" href="classSString.html">SString</a>("window"))</em>.<p>
<a class="el" href="classSContext.html">SContext</a> is, in fact, just holding the root <a class="el" href="classINode.html">INode</a> of a <a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a>, providing convenience functions for doing common operations with the namespace. Components usually don't get an <a class="el" href="classSContext.html">SContext</a> of the <em>root</em> namespace  to enforce security, the system makes additional namespaces that are derived from the root namespace but with modifications such as "can not publish new services".<h3><a class="anchor" name="ServiceDefn">
Service</a></h3>
A previously instantiated <a class="el" href="BinderTerminology.html#BinderDefn">Binder</a> object that has been published under /services in the <a class="el" href="BinderTerminology.html#BinderNamespaceDefn">Binder Namespace</a>. These are usually instantiated by the boot script when the system starts up, and exist forever.<p>
You can basically think of them as singleton components, though the Binder does not currently provide any explicit way to define singletons. That is, there is no way to say "this component is a singleton" so that every attempt to instantiate the component returns the same object; instead, you must explicitly instantiate it and publish it in the namespace up front, for others to discover there.<h3><a class="anchor" name="LinkDefn">
Link</a></h3>
A Link is an active data/event connection from one <a class="el" href="BinderTerminology.html#BinderDefn">Binder</a> to another. It is created with the <a class="el" href="classIBinder.html#a12">IBinder::Link()</a> method, expressing a binding going from the Binder being called to the given target. The source Binder uses <a class="el" href="classBBinder.html#a13">BBinder::Push()</a> to send data through a link.<p>
There are two kinds of links, data and events. All <a class="el" href="BinderTerminology.html#InterfaceDefn">Interface</a> properties are also data links, providing a data-flow mechanism. This can be used, for example, to attach the current value of some property in one object to the value of some other propety in a differnt object; when the value of the former changes, that new value will be propagated to the later.<p>
Event links are created explicitly in IDL in the "event:" section. Events are linked to methods on a target, resulting in a method invocation when the event is pushed.<p>
See <a class="el" href="BinderShellTutorial.html#ShellLinks">Links</a> for an example of links using the Binder Shell. <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:32 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
