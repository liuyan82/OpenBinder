<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: pidgen</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="pidgen">pidgen</a></h1><div class="header"> <center>&lt; <a class="el" href="BinderIPCMechanism.html">Binder IPC Mechanism</a> | <a class="el" href="BinderKit.html">Binder Kit</a> | <a class="el" href="BinderInspect.html">Binder Inspect() Details</a> &gt;</center> <hr>
 </div><p>
The Palm Interface Definition Generator (pidgen) is a tool that makes it easier to generate Binder interfaces. Pidgen parses interface files written in Interface Definition Language (IDL) and generates the necessary code for objects declared in an interface to travel across processes. Pidgen does not write your code for you; you still have to write the actual implementation (that is, you have to write the BClass).<p>
Pidgen parses IDL, which is similar to COM and CORBA's IDL. IDL shares syntactical similarities with C++, but IDL is not the same as C++. The marshaling and unmarshaling code that pidgen generates is C++. Note that pidgen does not parse C++, it simply generates C++.<p>
Here is what is automatically generated when pidgen parses an IDL file:<p>
<ul>
<li>A <b></b>.h file containing declarations for the objects in an interface. Essentially, the .h file is a header in C++.</li><li>A <b></b>.cpp file containing no implementation code, only marshalling/unmarshalling code to help objects travel across processes. The code in the .cpp file generates hooks for methods and properties (to direct calls to the proper local entity), creates remote proxies so that non-local calls can be initiated, and generates some local transaction code (the BnClass, from which the BClass can be derived). In the .cpp file, SValues are used to package objects across processes.</li></ul>
<p>
<ol type=1>
<li><a class="el" href="pidgen.html#WritingIDLFiles">Writing IDL Files</a><ol type=a>
<li><a class="el" href="pidgen.html#Functions">Functions</a></li><li><a class="el" href="pidgen.html#Events">Events</a></li><li><a class="el" href="pidgen.html#Properties">Properties</a></li><li><a class="el" href="pidgen.html#Attributes">Attributes</a><ol type=i>
<li><a class="el" href="pidgen.html#InOutInout">in, out, inout</a></li><li><a class="el" href="pidgen.html#local">local</a></li><li><a class="el" href="pidgen.html#readonly">readonly</a></li><li><a class="el" href="pidgen.html#optional">optional</a></li><li><a class="el" href="pidgen.html#weak">weak</a></li><li><a class="el" href="pidgen.html#reserved">reserved</a></li></ol>
</li></ol>
</li><li><a class="el" href="pidgen.html#TypesInPidgen">Types in Pidgen</a></li><li><a class="el" href="pidgen.html#SequenceArtguments">Sequence Arguments</a></li><li><a class="el" href="pidgen.html#LinkConvenienceMethods">Link Convenience Methods</a></li><li><a class="el" href="pidgen.html#MorePidgenFeatures">More Pidgen Features</a></li><li><a class="el" href="pidgen.html#InvokingPidgen">Invoking Pidgen</a><ol type=a>
<li><a class="el" href="pidgen.html#PidgenCommandLine">Invoking Pidgen from the Command Line</a></li><li><a class="el" href="pidgen.html#PidgenJam">Letting Jam Invoke Pidgen Automatically</a></li></ol>
</li><li><a class="el" href="pidgen.html#ExampleIDLFiles">Example IDL Files</a><ol type=a>
<li><a class="el" href="pidgen.html#IDatumIDL">support/IDatum.idl</a></li><li><a class="el" href="pidgen.html#INodeIDL">support/INode.idl</a></li><li><a class="el" href="pidgen.html#IIteratorIDL">support/IIterator.idl</a></li></ol>
</li></ol>
<h2><a class="anchor" name="WritingIDLFiles">
Writing IDL Files</a></h2>
IDL files describe interfaces and the functions and properties associated with those interfaces.<p>
The concept of an interface is central to IDL. An interface file is a set of definitions that are abstract representations of the underlying system. Developers can use these definitions to safely send objects declared in the interface across processes, without having to know how the underlying system is implemented. It is the abstract representation of the parts of your system’s underlying implementation that is open to modification by third-party developers.<p>
The purpose of using pidgen is to produce safe, proven code that enables objects defined in an interface to be used across processes.<p>
To specify an interface, declare it in an IDL file as follows:<p>
<div class="fragment"><pre class="fragment">interface xyz
</pre></div><p>
You can declare multiple interfaces in one IDL file, but the convention is to declare at least interface IXyz in the IDL file named IXyz.idl. For example, you would declare interface IWidget in IWidget.idl.<p>
Usually, declarations of interfaces are enclosed in namespaces to help pidgen map its C++ code output to the correct locations. For example, an interface that lives in the app kit is declared like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>widget {
    interface IWidget {
        ...
    }
}}
</pre></div><p>
By convention, interfaces names begin with the letter I; for example, IRender or <a class="el" href="classICommand.html">ICommand</a>.<p>
Two kinds of interface declarations are possible in IDL:<p>
<ul>
<li>Regular interface declaration with functions, events, and properties.</li><li>Forward declared interface. Forward declared interfaces let pidgen know of the existence of an interface that is not specified in the current IDL file. To forward declare an interface, you declare an interface without functions and properties. For example: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>support {
    interface <a class="code" href="classIByteOutput.html">IByteOutput</a>
    interface <a class="code" href="classIByteInput.html">IByteInput</a>
}}
</pre></div></li></ul>
<p>
You can also import interfaces from other IDL files and make the imported interfaces visible to the current interface. Both regular and forward declared interfaces can be imported. Imports are a good way to tell pidgen about specific custom types needed by the current interface.<p>
To use imports, specify where the imported IDL file lives when pidgen is invoked with the -I flag. For example:<p>
<div class="fragment"><pre class="fragment">pidgen IWidget.idl -I C:\PDK\interfaces\widget
</pre></div><p>
For detailed information on invoking PIDGen, see <a class="el" href="pidgen.html#InvokingPidgen">Invoking Pidgen</a>.<p>
Then in IWidget.idl, include the following code:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">import</span> &lt;render/Font.idl&gt;
</pre></div><p>
When pidgen sees the import directive, it looks for Font.idl in the directory specified by the -I flag. More than one IDL can be specified, and pidgen will search all of them until it finds a match or exhausts all the directory options.<p>
Any interfaces declared in, or imported by, imported interfaces are then available for use by the interface you’re declaring.<p>
So far, you have the following code in Widget.idl:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">import</span> &lt;render/Font.idl&gt;
<span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>widget{
    interface IWidget {
        ...
    }
}}
</pre></div><p>
We can now populate IWidget with functions, events, and properties.<h3><a class="anchor" name="Functions">
Functions</a></h3>
Functions are declared C++ style, preceded by the word "methods".<p>
<div class="fragment"><pre class="fragment">interface IWidget
{
methods:
    <span class="keywordtype">void</span> RequestGestures(uint8_t gestures);
    <span class="keywordtype">void</span> DefaultFont(<a class="code" href="classSString.html">SString</a> font);
    <span class="keywordtype">void</span> Poked();
    <span class="keywordtype">void</span> Leaned();
    ...
}
</pre></div><h3><a class="anchor" name="Events">
Events</a></h3>
Events are declared C++ style as well, preceded by the word "events".<p>
<div class="fragment"><pre class="fragment">interface IWidget
{
    ...
events:
    <span class="keywordtype">void</span> WidgetPoked(IWidget widget);
    <span class="keywordtype">void</span> WidgetLeaned(IWidget widget);
    ...
}
</pre></div><p>
Events are methods that are called when specific things take place. For each event in your interface, pidgen generates a corresponding push method on its BnClass. For the example above, these would be BnWidget::PushPoked() and BnWidget::PushLeaned(). When implementing this interface, you can call these push functions whenever you would like to send out the event.<p>
Clients that are interested in being notified of the event link to the event.<p>
<div class="fragment"><pre class="fragment">widget-&gt;Link(watcher, <a class="code" href="SupportBuild_8h.html#a62">SValue</a>(<span class="stringliteral">"WidgetPoked"</span>, <span class="stringliteral">"HandleWidgetPoked"</span>);
</pre></div><p>
The client also provides the HandleWidgetPoked() method, which is then called whenever the WidgetPoked() method is called by the widget object.<p>
See <a class="el" href="pidgen.html#LinkConvenienceMethods">Link Convenience Methods</a> for more information about linking.<h3><a class="anchor" name="Properties">
Properties</a></h3>
Properties are similarly preceded by the word "properties" and declared in the style of member variable declaration for C++ classes.<p>
<div class="fragment"><pre class="fragment">interface IWidget
{
    ...
properties:
    [readonly]<a class="code" href="classSValue.html">SValue</a>    <a class="code" href="TSD_8cpp.html#a1">key</a>;
    <a class="code" href="classSString.html">SString</a>             label;
    <a class="code" href="classSValue.html">SValue</a>              fontDescription;
    [readonly]BFont     font;
    <span class="keywordtype">bool</span>                enabled;
    <span class="keywordtype">bool</span>                hasFocus;
    int32_t             interactionState;
    [readonly]uint8_t   gestureFlags;
    <a class="code" href="classSValue.html">SValue</a>              value;
    ...
}
</pre></div><p>
Pidgen also generates a Push function for all properties on an interface, very much like it does for <a class="el" href="pidgen.html#Events">Events</a>. You should use these to tell others when your object's state changes, so they can link to your properties to monitor their value. This is an intrinsic part of the Binder's data-flow mechanism.<h3><a class="anchor" name="Attributes">
Attributes</a></h3>
There are several attributes available that provide additional information when describing a function, property, or event.<h4><a class="anchor" name="InOutInout">
in, out, inout</a></h4>
The <em>in</em> attribute identifies a parameter to a function or event as an input, while the <em>out</em> attribute identifies a parameter as an output.<p>
The <em>inout</em> attribute indicates that a parameter to a function or event is both an input and an output.<p>
Here is an example of using attributes when declaring a method.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classSValue.html">SValue</a> SetProperty([in]<a class="code" href="classSValue.html">SValue</a> <a class="code" href="TSD_8cpp.html#a1">key</a>, [inout]<a class="code" href="classSValue.html">SValue</a> value);
</pre></div><p>
If <em>in</em> or <em>out</em> is not specified for a parameter, its direction is assumed to be <em>in</em>.<h4><a class="anchor" name="local">
local</a></h4>
The <em>local</em> attribute can be used if you want to create an interface that uses the Binder object model, but doesn’t care about crossprocess or multi-language support.<p>
You can specify the local attribute on either the entire interface or on specific methods within the interface.<p>
Here is an example of defining an interface that is entirely local.<p>
<div class="fragment"><pre class="fragment">[local] interface IColor
{
    ...
}
</pre></div><p>
Here is an example of defining a specific method that is local.<p>
<div class="fragment"><pre class="fragment">interface IColorModel
{
methods:
    ...
    [local] int32_t LocalLookupColor(int32_t rgb);
    ...
}
</pre></div><p>
Local interfaces or methods generate less code, but have restrictions on how they can be used:<p>
<ul>
<li>Local interfaces or methods cannot be called from a different process.</li><li>Local interfaces or methods cannot be called from a different language.</li><li>Local interfaces or methods cannot be the target of Binder linking.</li></ul>
<h4><a class="anchor" name="readonly">
readonly</a></h4>
The <em>readonly</em> attribute specifies that a given property is read-only.<h4><a class="anchor" name="optional">
optional</a></h4>
The <em>optional</em> attribute specifies that a method argument is not required. If that argument is not supplied, a default value for the argument's type will be used. For numeric types (integers and floats), the default value is zero; for <a class="el" href="classSValue.html">SValue</a> it is B_UNDEFINED_VALUE; for strings it is ""; for interfaces it is NULL.<h4><a class="anchor" name="weak">
weak</a></h4>
The weak attribute is used when declaring a property, or a method or event that needs to accept a weak reference to an object as a parameter. The IDL to implement this is demonstrated here.<p>
<div class="fragment"><pre class="fragment">properties:
    IView view;
    [weak] IViewParent parent;
methods:
    <span class="keywordtype">void</span> GiveAView([in] IView view);
    <span class="keywordtype">void</span> GiveAParent([in weak] IViewParent parent);
</pre></div><p>
The resulting C++ code is shown below.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">virtual</span> <a class="code" href="classsptr.html">sptr&lt;IView&gt;</a> View() <span class="keyword">const</span>;
<span class="keyword">virtual</span> <span class="keywordtype">void</span> SetView(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IView&gt;</a>&amp; value);
<span class="keyword">virtual</span> <a class="code" href="classwptr.html">wptr&lt;IViewParent&gt;</a> Parent() <span class="keyword">const</span>;
<span class="keyword">virtual</span> <span class="keywordtype">void</span> SetParent(<span class="keyword">const</span> <a class="code" href="classwptr.html">wptr&lt;IViewParent&gt;</a>&amp; value);

<span class="keyword">virtual</span> <span class="keywordtype">void</span> GiveAView(<span class="keyword">const</span> <a class="code" href="classsptr.html">sptr&lt;IView&gt;</a>&amp; value);
<span class="keyword">virtual</span> <span class="keywordtype">void</span> GiveAParent(<span class="keyword">const</span> <a class="code" href="classwptr.html">wptr&lt;IViewParent&gt;</a>&amp; value);
</pre></div><p>
The C++ binding passes all interfaces as smart pointers; the default is to use a strong reference, so if you need to use a weak reference, be sure to specify the weak attribute.<h4><a class="anchor" name="reserved">
reserved</a></h4>
The <em>reserved</em> attribute can be applied to either functions or properties. It provides the ability to create reserved slots in the implementation so that future versions of the interface can add new methods or properties without forcing clients to be recompiled. Using the reserved attribute requires some planning—you need to estimate how much future growth to expect. If the interface has a limited number of properties and methods, and little potential for growth, then you may only need a handful of reserved properties and methods. More complex interfaces may benefit from a larger number of reserved slots.<p>
<dl compact><dt><b>Note:</b></dt><dd>The reserved slot feature has not been fully tested.</dd></dl>
To add reserved slots to your interface, you must first decide how many reserved methods and properties you need. Then, all you need to do is add code similar to that seen here.<p>
<div class="fragment"><pre class="fragment">[reserved] int32_t _reservedProperty1;
...
[reserved] int32_t _reservedPropertyN;

[reserved] <a class="code" href="group__Core.html#ga0">status_t</a> _ReservedMethod1;
...
[reserved] <a class="code" href="group__Core.html#ga0">status_t</a> _ReservedMethodM;
</pre></div><p>
Reserved properties and functions use the same syntax as normal properties and functions, but simply include the reserved attribute. There are no rules for the actual signatures of the reserved properties and methods, but the convention is to follow the example shown above.<p>
When you decide to add a new method or property to your interface, you do so by replacing one of the reserved items with your new property or method.<p>
An important thing to note: if the new property you’re creating is a readonly property, there’s an extra step to take. That’s because reserved properties get slots automatically reserved for their getter and setter methods, and read-only properties don’t need a setter method. So, to maintain binary compatibility, you need to do something like what’s shown here.<p>
<div class="fragment"><pre class="fragment">[readonly] IFoo myFooProperty;
[reserved readonly] int32_t _reservedProperty1;
</pre></div><p>
Since the reserved property is read-only, it saves one method slot, thereby restoring binary compatibility.<h2><a class="anchor" name="TypesInPidgen">
Types in Pidgen</a></h2>
Pidgen recognizes and marshals several standard types:<p>
<div class="fragment"><pre class="fragment">bool   char    string
short  long    double   float
int8   int16   int32    int64
uint8  uint16  uint32   uint64
size_t ssize_t status_t bigtime_t off_t
SValue SString
</pre></div><p>
In addition, interface types are converted to sptr&lt;&gt; and wptr&lt;&gt; smart pointers, as described in the <a class="el" href="pidgen.html#weak">weak</a> attribute.<p>
If you want to marshal types other the ones listed, the available options are:<p>
<ul>
<li><b>typedefs</b> – Typedefs can be declared the way they are declared in C++, but only in the interface where they are needed. <div class="fragment"><pre class="fragment">interface ISurface
{
    <span class="keyword">typedef</span> uint64 pixel_format;
properties:
    [readonly]pixel_format arg
    ...
}
</pre></div></li></ul>
<p>
<ul>
<li><b>type</b> – Pidgen doesn’t have to understand a custom type in order to marshal it, because SValues are used to send things cross-process. If the type you need has translators to <a class="el" href="classSValue.html">SValue</a> (specifically, type.ASValue() converts a type it into an <a class="el" href="classSValue.html">SValue</a>, and type.SetTo(SValue) converts a type from an <a class="el" href="classSValue.html">SValue</a>) pidgen can marshal type across processes. <dl compact><dt><b></b></dt><dd>The way to declare type is <div class="fragment"><pre class="fragment">type <a class="code" href="classSMessage.html">SMessage</a> {
methods:
    <a class="code" href="classSValue.html">SValue</a> ASValue();
    <a class="code" href="classSMessage.html">SMessage</a> <a class="code" href="SupportBuild_8h.html#a43">SMessage</a>(<a class="code" href="classSValue.html">SValue</a> o);
}
</pre></div></dd></dl>
</li></ul>
<h2><a class="anchor" name="SequenceArtguments">
Sequence Arguments</a></h2>
Pidgen supports sequence arguments to methods. A sequence is a one-dimensional array; the term comes from CORBA IDL. A sequence is mapped to an <a class="el" href="classSVector.html">SVector</a> in C++.<p>
An <em>out</em> sequence will be completely overwritten by the method, while an <em>inout</em> sequence can be modified as desired by the method. Sequences specified as an <em>in</em> parameter are passed by reference, such as "&lt;CODE&gt;const SVector&lt;&gt; &amp;&lt;/CODE&gt;"). Sequences may also be returned, however, returning a sequence requires a copy constructor, so using an <em>out</em> parameter is more efficient.<p>
A sequence must be named by a typedef before it can be used, as demonstrated here.<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> sequence&lt;int32_t&gt; CategoryList;
method:
    <span class="keywordtype">void</span> GetCategories([out] CategoryList list);
</pre></div><p>
The above IDL creates a typedef and member function in the resulting interface class as seen here.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="classSVector.html">SVector&lt;int32_t&gt;</a> CategoryList;
<span class="keywordtype">void</span> GetCategories(CategoryList *list);
</pre></div><p>
The typedef is scoped within the interface class, so any external usage of the typedef must be qualified, using syntax such as <code>ClassName::CategoryList</code>.<p>
When using a sequence, <code><a class="el" href="classSVector.html#a9">SVector::AsValue()</a></code> and <code><a class="el" href="classSVector.html#a27">SVector::SetFromValue()</a></code> are called. These methods, in turn, call two helper functions. The helper functions are specialized for all the basic types. However, for custom types, you can use one of three helper macros to define the needed functions:<p>
<ul>
<li>Use B_IMPLEMENT_SIMPLE_TYPE_FLATTEN_FUNCS if your type is of fixed size and you can treat it as a simple stream of bits.</li><li>Use B_IMPLEMENT_SFLATTENABLE_FLATTEN_FUNCS if your type is derived from <a class="el" href="classSFlattenable.html">SFlattenable</a>.</li><li>Use B_IMPLEMENT_FLATTEN_FUNCS if your type implements <code>TYPE::AsValue()</code> and <code>TYPE(const SValue &amp;)</code>.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>At this time, the <a class="el" href="classSFlattenable.html">SFlattenable</a> class is not available for licensee use.</dd></dl>
<h2><a class="anchor" name="LinkConvenienceMethods">
Link Convenience Methods</a></h2>
Pidgen generates convenience methods to make linking easier. Much of the time, when you create a link, it’s necessary to perform casting to get to the right Binder object. The link convenience methods do this for you. For example, you can replace the following two lines:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classsptr.html">sptr&lt;IBinder&gt;</a> menuBinder = m_menu-&gt;IMenu::AsBinder();
menuBinder-&gt;Link(this-&gt;AsBinder(), ...);
</pre></div><p>
with the single link convenience method call shown below.<p>
<div class="fragment"><pre class="fragment">m_menu-&gt;LinkMenu(this-&gt;AsBinder(), ...);
</pre></div><h2><a class="anchor" name="MorePidgenFeatures">
More Pidgen Features</a></h2>
Other PIDGen features include:<p>
<ul>
<li><b>Using directives</b>. If necessary, you can declare usage of additional namespaces within interfaces: <div class="fragment"><pre class="fragment">interface ISurface
{
    <span class="keyword">using</span> <span class="keyword">namespace </span>palmos::render;
    ...
}
</pre></div></li></ul>
<p>
<ul>
<li><b>Enums and structs</b>. Pidgen cannot understand enumerated types or structs, unless translators are provided to and from SValues (specifically, <code>type.ASValue()</code> converts a type it into an <a class="el" href="classSValue.html">SValue</a>, and <code>type.SetTo(SValue)</code> converts a type from an <a class="el" href="classSValue.html">SValue</a>). However, pidgen can include your enums or structs in the generated header if they are declared within the IDL file.</li></ul>
<h2><a class="anchor" name="InvokingPidgen">
Invoking Pidgen</a></h2>
You can invoke pidgen manually from the command line, or set up your Palm OS Cobalt integrated build environment so that the Jam build tool invokes PIDGen automatically.<h3><a class="anchor" name="PidgenCommandLine">
Invoking Pidgen from the Command Line</a></h3>
To invoke pidgen from the command line, go to /PDK/tools, where you will find pidgen.exe. Call pidgen as follows:<p>
<div class="fragment"><pre class="fragment">pidgen idlfilename
</pre></div><p>
where <em>idlfilename</em> is the name of your IDL file.<p>
You can type -h to see the list of flags available. Flags include:<ul>
<li><code>import path | -I path</code><br>
 Adds <em>path</em> to the list of import directories. This flag is required when using imports in an interface.</li><li><code>output-dir path | -O path</code><br>
 Specifies output directory for generated files. The default is the directory where the IDL file is located.</li><li><code>output-header-dir path | -S path</code><br>
 The output directory for generated header files. When used in conjunction with -O, header files go in the output-header directory and .cpp files go in the -O directory. The default directory is the directory where the IDL file is located.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>If pidgen is called with more than one IDL file specified, files will run in sequence, all using the same set of flags.</dd></dl>
<h3><a class="anchor" name="PidgenJam">
Letting Jam Invoke Pidgen Automatically</a></h3>
You can set up the Palm OS Cobalt build system to invoke pidgen automatically. To do this, edit or create the appropriate Jamfile. For detailed information on creating Jamfiles, see Inside Palm OS Cobalt: Building a ROM Image.<p>
For example, the Jamfile for PDK/interfaces/app might start like this: <div class="fragment"><pre class="fragment"><span class="preprocessor"># Jamfile to build app interface files</span>
<span class="preprocessor"></span>SubDir TOP platform interfaces PDK app ;
<span class="preprocessor"># Build IDL-generated files</span>
<span class="preprocessor"></span>InterfaceIdl IApplication.cpp : IApplication.idl : libbinder ;
InterfaceIdl <a class="code" href="classICommand.html">ICommand</a>.cpp : <a class="code" href="classICommand.html">ICommand</a>.idl : libbinder ;
...
</pre></div><p>
Make sure the generated files work before you specify them in the Jamfile.<h2><a class="anchor" name="ExampleIDLFiles">
Example IDL Files</a></h2>
Here are some complete examples of what IDL files look like. To see more IDL files, look in PDK/interfaces.<h3><a class="anchor" name="IDatumIDL">
support/IDatum.idl</a></h3>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>support {

interface <a class="code" href="classIDatum.html">IDatum</a>
{
    <span class="keyword">enum</span>
    {
        READ_ONLY           = 0x0000,
        WRITE_ONLY          = 0x0001,
        READ_WRITE          = 0x0002,
        READ_WRITE_MASK     = 0x0003,

        ERASE_DATUM         = 0x0200,
        OPEN_AT_END         = 0x0400
    };

    <span class="keyword">enum</span>
    {   
        NO_COPY_REDIRECTION     = 0x0001
    };

properties:
    uint32_t valueType;
    off_t size;
    <a class="code" href="classSValue.html">SValue</a> value;
    
methods:
    <a class="code" href="classIBinder.html">IBinder</a> Open(uint32_t mode, [optional]<a class="code" href="classIBinder.html">IBinder</a> editor, [optional]uint32_t newType);
    <a class="code" href="group__Core.html#ga0">status_t</a> CopyTo(<a class="code" href="classIDatum.html">IDatum</a> dest, [optional]uint32_t flags);
    <a class="code" href="group__Core.html#ga0">status_t</a> CopyFrom(<a class="code" href="classIDatum.html">IDatum</a> src, [optional]uint32_t flags);

events:
    <span class="keywordtype">void</span> DatumChanged(<a class="code" href="classIDatum.html">IDatum</a> who, <a class="code" href="classIBinder.html">IBinder</a> editor, off_t start, off_t length);
}

} } <span class="comment">// namespace palmos::support</span>
</pre></div><h3><a class="anchor" name="INodeIDL">
support/INode.idl</a></h3>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>support {

interface <a class="code" href="classINode.html">INode</a>
{
    <span class="keyword">enum</span>
    {
        REQUEST_DATA        = 0x1000,
        COLLAPSE_NODE       = 0x2000,
        IGNORE_PROJECTION   = 0x4000
    };

    <span class="keyword">enum</span>
    {
        CREATE_DATUM        = 0x0100,
        CREATE_NODE         = 0x0200,
        CREATE_MASK         = 0x0300
    };

    <span class="keyword">enum</span>
    {
        CHANGE_DETAILS_SENT = 0x0001
    };

properties:
    [readonly]<a class="code" href="classINode.html">INode</a> attributes;

    <a class="code" href="classSString.html">SString</a> mimeType;
    <a class="code" href="group__Core.html#ga1">nsecs_t</a> creationDate;
    <a class="code" href="group__Core.html#ga1">nsecs_t</a> modifiedDate;

methods:
    <a class="code" href="group__Core.html#ga0">status_t</a> Walk([inout]<a class="code" href="classSString.html">SString</a> path, uint32_t flags, [out]<a class="code" href="classSValue.html">SValue</a> node);

events:
    <span class="keywordtype">void</span> NodeChanged(<a class="code" href="classINode.html">INode</a> who, uint32_t flags, <a class="code" href="classSValue.html">SValue</a> hints);
    <span class="keywordtype">void</span> EntryCreated(<a class="code" href="classINode.html">INode</a> who, <a class="code" href="classSString.html">SString</a> <a class="code" href="TSD_8cpp.html#a2">name</a>, <a class="code" href="classIBinder.html">IBinder</a> entry);
    <span class="keywordtype">void</span> EntryModified(<a class="code" href="classINode.html">INode</a> who, <a class="code" href="classSString.html">SString</a> <a class="code" href="TSD_8cpp.html#a2">name</a>, <a class="code" href="classIBinder.html">IBinder</a> entry);
    <span class="keywordtype">void</span> EntryRemoved(<a class="code" href="classINode.html">INode</a> who, <a class="code" href="classSString.html">SString</a> <a class="code" href="TSD_8cpp.html#a2">name</a>);
    <span class="keywordtype">void</span> EntryRenamed(<a class="code" href="classINode.html">INode</a> who, <a class="code" href="classSString.html">SString</a> old_name, <a class="code" href="classSString.html">SString</a> new_name, <a class="code" href="classIBinder.html">IBinder</a> entry);
}
</pre></div><h3><a class="anchor" name="IIteratorIDL">
support/IIterator.idl</a></h3>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>palmos {
<span class="keyword">namespace </span>support {

interface <a class="code" href="classIIterator.html">IIterator</a>
{
    <span class="keyword">enum</span>
    {
        BINDER_IPC_LIMIT = 0x05
    };

    <span class="keyword">enum</span>
    {
        REQUEST_DATA        = 0x1000,
        COLLAPSE_NODE       = 0x2000,
        IGNORE_PROJECTION   = 0x4000
    };

    <span class="keyword">typedef</span> sequence&lt;SValue&gt; ValueList;

properties:
    [readonly]<a class="code" href="classSValue.html">SValue</a> options;

methods:
    <a class="code" href="group__Core.html#ga0">status_t</a> Next([out]ValueList keys, [out]ValueList values, uint32_t flags, [optional]size_t count);

events:
    <span class="keywordtype">void</span> IteratorChanged(<a class="code" href="classIIterator.html">IIterator</a> it);
}
</pre></div> <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:33 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
