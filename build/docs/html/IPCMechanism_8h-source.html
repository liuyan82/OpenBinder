<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: IPCMechanism.h Source File</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="nav">
<a class="el" href="dir_000000.html">libraries</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000001.html">libbinder</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_000002.html">docs</a></div>
<h1>IPCMechanism.h</h1><a href="IPCMechanism_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00106"></a>00106     <a class="code" href="binder__module_8h.html#a70a47">bcTRANSACTION</a>,
<a name="l00107"></a>00107     <a class="code" href="binder__module_8h.html#a70a48">bcREPLY</a>,
<a name="l00108"></a>00108     <span class="comment">/*</span>
<a name="l00109"></a>00109 <span class="comment">        binder_transaction_data: the sent command.</span>
<a name="l00110"></a>00110 <span class="comment">    */</span>
<a name="l00111"></a>00111     
<a name="l00112"></a>00112     <a class="code" href="binder__module_8h.html#a70a49">bcACQUIRE_RESULT</a>,
<a name="l00113"></a>00113     <span class="comment">/*</span>
<a name="l00114"></a>00114 <span class="comment">        int32:  0 if the last brATTEMPT_ACQUIRE was not successful.</span>
<a name="l00115"></a>00115 <span class="comment">        Else you have acquired a primary reference on the object.</span>
<a name="l00116"></a>00116 <span class="comment">    */</span>
<a name="l00117"></a>00117     
<a name="l00118"></a>00118     <a class="code" href="binder__module_8h.html#a70a50">bcFREE_BUFFER</a>,
<a name="l00119"></a>00119     <span class="comment">/*</span>
<a name="l00120"></a>00120 <span class="comment">        void *: ptr to transaction data received on a read</span>
<a name="l00121"></a>00121 <span class="comment">    */</span>
<a name="l00122"></a>00122     
<a name="l00123"></a>00123     <a class="code" href="binder__module_8h.html#a70a52">bcINCREFS</a>,
<a name="l00124"></a>00124     <a class="code" href="binder__module_8h.html#a70a53">bcACQUIRE</a>,
<a name="l00125"></a>00125     <a class="code" href="binder__module_8h.html#a70a54">bcRELEASE</a>,
<a name="l00126"></a>00126     <a class="code" href="binder__module_8h.html#a70a55">bcDECREFS</a>,
<a name="l00127"></a>00127     <span class="comment">/*</span>
<a name="l00128"></a>00128 <span class="comment">        int32:  descriptor</span>
<a name="l00129"></a>00129 <span class="comment">    */</span>
<a name="l00130"></a>00130     
<a name="l00131"></a>00131     <a class="code" href="binder__module_8h.html#a70a58">bcATTEMPT_ACQUIRE</a>,
<a name="l00132"></a>00132     <span class="comment">/*</span>
<a name="l00133"></a>00133 <span class="comment">        int32:  priority</span>
<a name="l00134"></a>00134 <span class="comment">        int32:  descriptor</span>
<a name="l00135"></a>00135 <span class="comment">    */</span>
<a name="l00136"></a>00136     
<a name="l00137"></a>00137     bcRESUME_THREAD,
<a name="l00138"></a>00138     <span class="comment">/*</span>
<a name="l00139"></a>00139 <span class="comment">        int32:  thread ID</span>
<a name="l00140"></a>00140 <span class="comment">    */</span>
<a name="l00141"></a>00141     
<a name="l00142"></a>00142     <a class="code" href="binder__module_8h.html#a70a60">bcSET_THREAD_ENTRY</a>,
<a name="l00143"></a>00143     <span class="comment">/*</span>
<a name="l00144"></a>00144 <span class="comment">        void *: thread entry function for new threads created to handle tasks</span>
<a name="l00145"></a>00145 <span class="comment">        void *: argument passed to those threads</span>
<a name="l00146"></a>00146 <span class="comment">    */</span>
<a name="l00147"></a>00147     
<a name="l00148"></a>00148     <a class="code" href="binder__module_8h.html#a70a61">bcREGISTER_LOOPER</a>,
<a name="l00149"></a>00149     <span class="comment">/*</span>
<a name="l00150"></a>00150 <span class="comment">        No parameters.</span>
<a name="l00151"></a>00151 <span class="comment">        Register a spawned looper thread with the device.  This must be</span>
<a name="l00152"></a>00152 <span class="comment">        called by the function that is supplied in bcSET_THREAD_ENTRY as</span>
<a name="l00153"></a>00153 <span class="comment">        part of its initialization with the binder.</span>
<a name="l00154"></a>00154 <span class="comment">    */</span>
<a name="l00155"></a>00155     
<a name="l00156"></a>00156     <a class="code" href="binder__module_8h.html#a70a62">bcENTER_LOOPER</a>,
<a name="l00157"></a>00157     <a class="code" href="binder__module_8h.html#a70a63">bcEXIT_LOOPER</a>,
<a name="l00158"></a>00158     <span class="comment">/*</span>
<a name="l00159"></a>00159 <span class="comment">        No parameters.</span>
<a name="l00160"></a>00160 <span class="comment">        These two commands are sent as an application-level thread</span>
<a name="l00161"></a>00161 <span class="comment">        enters and exits the binder loop, respectively.  They are</span>
<a name="l00162"></a>00162 <span class="comment">        used so the binder can have an accurate count of the number</span>
<a name="l00163"></a>00163 <span class="comment">        of looping threads it has available.</span>
<a name="l00164"></a>00164 <span class="comment">    */</span>
<a name="l00165"></a>00165     
<a name="l00166"></a>00166     bcCATCH_ROOT_OBJECTS,
<a name="l00167"></a>00167     <span class="comment">/*</span>
<a name="l00168"></a>00168 <span class="comment">        No parameters.</span>
<a name="l00169"></a>00169 <span class="comment">        Call this to have your team start catching root objects</span>
<a name="l00170"></a>00170 <span class="comment">        published by other teams that are spawned outside of the binder.</span>
<a name="l00171"></a>00171 <span class="comment">        When this happens, you will receive a brTRANSACTION with the</span>
<a name="l00172"></a>00172 <span class="comment">        tfRootObject flag set.  (Note that this is distinct from receiving</span>
<a name="l00173"></a>00173 <span class="comment">        normal root objects, which are a brREPLY.)</span>
<a name="l00174"></a>00174 <span class="comment">    */</span>
<a name="l00175"></a>00175     
<a name="l00176"></a>00176     bcKILL_TEAM
<a name="l00177"></a>00177     <span class="comment">/*</span>
<a name="l00178"></a>00178 <span class="comment">        No parameters.</span>
<a name="l00179"></a>00179 <span class="comment">        Simulate death of a kernel team.  For debugging only.</span>
<a name="l00180"></a>00180 <span class="comment">    */</span>
<a name="l00181"></a>00181 };
<a name="l00182"></a>00182 <span class="keyword">@end</span>code
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 The most interesting commands here are <a class="code" href="binder__module_8h.html#a70a47">bcTRANSACTION</a> and <a class="code" href="binder__module_8h.html#a70a48">bcREPLY</a>, which
<a name="l00185"></a>00185 initiate an IPC transaction and <span class="keywordflow">return</span> a reply <span class="keywordflow">for</span> a transaction,
<a name="l00186"></a>00186 respectively.  The data structure following these commands is:
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 @code
<a name="l00189"></a>00189 <span class="keyword">enum</span> <a class="code" href="binder__module_8h.html#a68">transaction_flags</a> {
<a name="l00190"></a>00190     <a class="code" href="binder__module_8h.html#a68a24">tfInline</a> = 0x01,            <span class="comment">// not yet implemented</span>
<a name="l00191"></a>00191     <a class="code" href="binder__module_8h.html#a68a26">tfRootObject</a> = 0x04,        <span class="comment">// contents are the component's root object</span>
<a name="l00192"></a>00192     <a class="code" href="binder__module_8h.html#a68a27">tfStatusCode</a> = 0x08         <span class="comment">// contents are a 32-bit status code</span>
<a name="l00193"></a>00193 };
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="keyword">struct </span><a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a>
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197     <span class="comment">// The first two are only used for bcTRANSACTION and brTRANSACTION,</span>
<a name="l00198"></a>00198     <span class="comment">// identifying the target and contents of the transaction.</span>
<a name="l00199"></a>00199     <span class="keyword">union </span>{
<a name="l00200"></a>00200         size_t  <a class="code" href="structbinder__transaction__data.html#o6">handle</a>;     <span class="comment">// target descriptor of command transaction</span>
<a name="l00201"></a>00201         <span class="keywordtype">void</span>    *<a class="code" href="structbinder__transaction__data.html#o11">ptr</a>;       <span class="comment">// target descriptor of return transaction</span>
<a name="l00202"></a>00202     } <a class="code" href="structbinder__transaction__data.html#o12">target</a>;
<a name="l00203"></a>00203     uint32  <a class="code" href="structbinder__transaction__data.html#o2">code</a>;           <span class="comment">// transaction command</span>
<a name="l00204"></a>00204     
<a name="l00205"></a>00205     <span class="comment">// General information about the transaction.</span>
<a name="l00206"></a>00206     uint32  <a class="code" href="structbinder__transaction__data.html#o5">flags</a>;
<a name="l00207"></a>00207     int32   <a class="code" href="structbinder__transaction__data.html#o9">priority</a>;       <span class="comment">// requested/current thread priority</span>
<a name="l00208"></a>00208     size_t  <a class="code" href="structbinder__transaction__data.html#o4">data_size</a>;      <span class="comment">// number of bytes of data</span>
<a name="l00209"></a>00209     size_t  <a class="code" href="structbinder__transaction__data.html#o8">offsets_size</a>;   <span class="comment">// number of bytes of object offsets</span>
<a name="l00210"></a>00210     
<a name="l00211"></a>00211     <span class="comment">// If this transaction is inline, the data immediately</span>
<a name="l00212"></a>00212     <span class="comment">// follows here; otherwise, it ends with a pointer to</span>
<a name="l00213"></a>00213     <span class="comment">// the data buffer.</span>
<a name="l00214"></a>00214     <span class="keyword">union </span>{
<a name="l00215"></a>00215         <span class="keyword">struct </span>{
<a name="l00216"></a>00216             <span class="keyword">const</span> <span class="keywordtype">void</span>  *<a class="code" href="structbinder__transaction__data.html#o1">buffer</a>;    <span class="comment">// transaction data</span>
<a name="l00217"></a>00217             <span class="keyword">const</span> <span class="keywordtype">void</span>  *<a class="code" href="structbinder__transaction__data.html#o7">offsets</a>;   <span class="comment">// binder object offsets</span>
<a name="l00218"></a>00218         } <a class="code" href="structbinder__transaction__data.html#o11">ptr</a>;
<a name="l00219"></a>00219         uint8   <a class="code" href="structbinder__transaction__data.html#o0">buf</a>[8];
<a name="l00220"></a>00220     } <a class="code" href="structbinder__transaction__data.html#o3">data</a>;
<a name="l00221"></a>00221 };
<a name="l00222"></a>00222 <span class="keyword">@end</span>code
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 Thus, to initiate an IPC transaction, you will essentially perform a
<a name="l00225"></a>00225 BINDER_READ_WRITE ioctl with the write buffer containing <a class="code" href="binder__module_8h.html#a70a47">bcTRANSACTION</a>
<a name="l00226"></a>00226 follewed by a <a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a>.  In <span class="keyword">this</span> structure @e target is
<a name="l00227"></a>00227 the handle of the object that should receive the transaction (we'll talk
<a name="l00228"></a>00228 about handles later), @e code tells the object what to <span class="keywordflow">do</span> when it
<a name="l00229"></a>00229 receives the transaction, @e priority is the thread priority to run the
<a name="l00230"></a>00230 IPC at, and there is a @e data buffer containing the transaction data,
<a name="l00231"></a>00231 as well as an (optional) additional @e offsets buffer of meta-data.
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 Given the @e target handle, the driver determines which process that
<a name="l00234"></a>00234 object lives in and dispatches this transaction to one of the waiting
<a name="l00235"></a>00235 threads in its thread pool (spawning a new thread if needed).  That
<a name="l00236"></a>00236 thread is waiting in a <a class="code" href="binder__module_8h.html#a2">BINDER_WRITE_READ</a> ioctl() to the driver, and so
<a name="l00237"></a>00237 returns with its read buffer filled in with the commands it needs to
<a name="l00238"></a>00238 execute.  These commands a very similar to the write commands, for the
<a name="l00239"></a>00239 most part corresponding to write operations on the other side:
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 @code
<a name="l00242"></a>00242 enum <a class="code" href="binder__module_8h.html#a69">BinderDriverReturnProtocol</a> {
<a name="l00243"></a>00243     <a class="code" href="binder__module_8h.html#a69a28">brERROR</a> = -1,
<a name="l00244"></a>00244     <span class="comment">/*</span>
<a name="l00245"></a>00245 <span class="comment">        int32: error code</span>
<a name="l00246"></a>00246 <span class="comment">    */</span>
<a name="l00247"></a>00247     
<a name="l00248"></a>00248     <a class="code" href="binder__module_8h.html#a69a29">brOK</a> = 0,
<a name="l00249"></a>00249     <a class="code" href="binder__module_8h.html#a69a30">brTIMEOUT</a>,
<a name="l00250"></a>00250     <a class="code" href="binder__module_8h.html#a69a31">brWAKEUP</a>,
<a name="l00251"></a>00251     <span class="comment">/*  No parameters! */</span>
<a name="l00252"></a>00252     
<a name="l00253"></a>00253     <a class="code" href="binder__module_8h.html#a69a32">brTRANSACTION</a>,
<a name="l00254"></a>00254     <a class="code" href="binder__module_8h.html#a69a33">brREPLY</a>,
<a name="l00255"></a>00255     <span class="comment">/*</span>
<a name="l00256"></a>00256 <span class="comment">        binder_transaction_data: the received command.</span>
<a name="l00257"></a>00257 <span class="comment">    */</span>
<a name="l00258"></a>00258     
<a name="l00259"></a>00259     <a class="code" href="binder__module_8h.html#a69a34">brACQUIRE_RESULT</a>,
<a name="l00260"></a>00260     <span class="comment">/*</span>
<a name="l00261"></a>00261 <span class="comment">        int32: 0 if the last bcATTEMPT_ACQUIRE was not successful.</span>
<a name="l00262"></a>00262 <span class="comment">        Else the remote object has acquired a primary reference.</span>
<a name="l00263"></a>00263 <span class="comment">    */</span>
<a name="l00264"></a>00264     
<a name="l00265"></a>00265     <a class="code" href="binder__module_8h.html#a69a35">brDEAD_REPLY</a>,
<a name="l00266"></a>00266     <span class="comment">/*</span>
<a name="l00267"></a>00267 <span class="comment">        The target of the last transaction (either a bcTRANSACTION or</span>
<a name="l00268"></a>00268 <span class="comment">        a bcATTEMPT_ACQUIRE) is no longer with us.  No parameters.</span>
<a name="l00269"></a>00269 <span class="comment">    */</span>
<a name="l00270"></a>00270     
<a name="l00271"></a>00271     <a class="code" href="binder__module_8h.html#a69a36">brTRANSACTION_COMPLETE</a>,
<a name="l00272"></a>00272     <span class="comment">/*</span>
<a name="l00273"></a>00273 <span class="comment">        No parameters... always refers to the last transaction requested</span>
<a name="l00274"></a>00274 <span class="comment">        (including replies).  Note that this will be sent even for asynchronous</span>
<a name="l00275"></a>00275 <span class="comment">        transactions.</span>
<a name="l00276"></a>00276 <span class="comment">    */</span>
<a name="l00277"></a>00277     
<a name="l00278"></a>00278     <a class="code" href="binder__module_8h.html#a69a37">brINCREFS</a>,
<a name="l00279"></a>00279     <a class="code" href="binder__module_8h.html#a69a38">brACQUIRE</a>,
<a name="l00280"></a>00280     <a class="code" href="binder__module_8h.html#a69a39">brRELEASE</a>,
<a name="l00281"></a>00281     <a class="code" href="binder__module_8h.html#a69a40">brDECREFS</a>,
<a name="l00282"></a>00282     <span class="comment">/*</span>
<a name="l00283"></a>00283 <span class="comment">        void *: ptr to binder</span>
<a name="l00284"></a>00284 <span class="comment">    */</span>
<a name="l00285"></a>00285     
<a name="l00286"></a>00286     <a class="code" href="binder__module_8h.html#a69a41">brATTEMPT_ACQUIRE</a>,
<a name="l00287"></a>00287     <span class="comment">/*</span>
<a name="l00288"></a>00288 <span class="comment">        int32:  priority</span>
<a name="l00289"></a>00289 <span class="comment">        void *: ptr to binder</span>
<a name="l00290"></a>00290 <span class="comment">    */</span>
<a name="l00291"></a>00291     
<a name="l00292"></a>00292     <a class="code" href="binder__module_8h.html#a69a42">brEVENT_OCCURRED</a>,
<a name="l00293"></a>00293     <span class="comment">/*</span>
<a name="l00294"></a>00294 <span class="comment">        This is returned when the bcSET_NEXT_EVENT_TIME has elapsed.</span>
<a name="l00295"></a>00295 <span class="comment">        At this point the next event time is set to B_INFINITE_TIMEOUT,</span>
<a name="l00296"></a>00296 <span class="comment">        so you must send another bcSET_NEXT_EVENT_TIME command if you</span>
<a name="l00297"></a>00297 <span class="comment">        have another event pending.</span>
<a name="l00298"></a>00298 <span class="comment">    */</span>
<a name="l00299"></a>00299     
<a name="l00300"></a>00300     <a class="code" href="binder__module_8h.html#a69a45">brFINISHED</a>
<a name="l00301"></a>00301 };
<a name="l00302"></a>00302 <span class="keyword">@end</span>code
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 Continuing our example, the receiving thread will come back with a
<a name="l00305"></a>00305 <a class="code" href="binder__module_8h.html#a69a32">brTRANSACTION</a> command at the end of its buffer.  This command uses the
<a name="l00306"></a>00306 same <a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a> structure that was used to send the data,
<a name="l00307"></a>00307 basically containing the same information that was sent but now available
<a name="l00308"></a>00308 in the local process space.
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 The recipient, in user space will then hand <span class="keyword">this</span> transaction over to the
<a name="l00311"></a>00311 target object <span class="keywordflow">for</span> it to execute and <span class="keywordflow">return</span> its result.  Upon getting the
<a name="l00312"></a>00312 result, a <span class="keyword">new</span> write buffer is created containing the <a class="code" href="binder__module_8h.html#a70a48">bcREPLY</a> reply
<a name="l00313"></a>00313 command with a <a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a> structure containing the resulting
<a name="l00314"></a>00314 data.  This is returned with a <a class="code" href="binder__module_8h.html#a2">BINDER_WRITE_READ</a> ioctl() on the driver,
<a name="l00315"></a>00315 sending the reply back to the original process and leaving the thread
<a name="l00316"></a>00316 waiting for the next transaction to perform.
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 The original thread finally returns back from its own <a class="code" href="binder__module_8h.html#a2">BINDER_WRITE_READ</a>
<a name="l00319"></a>00319 with a <a class="code" href="binder__module_8h.html#a69a33">brREPLY</a> command containing the reply data.
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 Note that the original thread may also receive <a class="code" href="binder__module_8h.html#a69a32">brTRANSACTION</a> commands while
<a name="l00322"></a>00322 it is waiting for a reply.  This represents a recursion across processes &amp;mdash;
<a name="l00323"></a>00323 the receiving thread making a call on to an object back in the original
<a name="l00324"></a>00324 process.  It is the responsibility of the driver to keep track of all
<a name="l00325"></a>00325 active transactions, so it can dispatch transactions to the correct thread
<a name="l00326"></a>00326 when recursion happens.
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 @subsection ObjectMappingAndReferencing Object Mapping and Referencing
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 One of the important responsibilities of the driver is to perform mapping
<a name="l00331"></a>00331 of objects from one process to another.  This is <a class="code" href="TSD_8cpp.html#a1">key</a> to both the
<a name="l00332"></a>00332 communication mechanism (targetting and referencing objects) as well as
<a name="l00333"></a>00333 the capability model (only allowing a particular process to perform
<a name="l00334"></a>00334 operations on remote objects that it has been explicitly given knowledge
<a name="l00335"></a>00335 about).
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 There are two distinct forms of an object reference: as an address in a
<a name="l00338"></a>00338 processes's memory space, or as an abstract 32-bit handle.  These
<a name="l00339"></a>00339 representations are mutually exclusive: @b all references in a process
<a name="l00340"></a>00340 to objects local to that process are in the form of an address, while
<a name="l00341"></a>00341 all references to objects in another process are always in the form of
<a name="l00342"></a>00342 a handle.
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 For example, note the @e target field of <a class="code" href="structbinder__transaction__data.html">binder_transaction_data</a>.  When
<a name="l00345"></a>00345 sending a transaction, this contains a handle to the destination object
<a name="l00346"></a>00346 (because you always send transactions to other processes).  The recipient
<a name="l00347"></a>00347 of the transaction, however, sees this as a point to the object in its
<a name="l00348"></a>00348 local address space.  The driver maintains mappings of pointers and
<a name="l00349"></a>00349 handles between processes so that it can perform this translation.
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 We also must be able to send references to objects through transactions.
<a name="l00352"></a>00352 This is done by placing the object reference (either a local pointer or
<a name="l00353"></a>00353 remote handle) in to the transaction buffer.  The driver must translate
<a name="l00354"></a>00354 this reference to the corresponding reference in the receiving process,
<a name="l00355"></a>00355 however, just like we do with the transaction target.
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 In order to do reference translation, the driver needs to know where these
<a name="l00358"></a>00358 references appear in the transaction data.  This is where the additional
<a name="l00359"></a>00359 @e offsets buffer comes in.  It contains of a series of indicies into the
<a name="l00360"></a>00360 data buffer, describing where objects appear.  The driver can then rewrite
<a name="l00361"></a>00361 the buffer data, translating each of those objects from the sending
<a name="l00362"></a>00362 process reference to the correct reference in the receiving process.
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 Note that the driver does not know anything about a particular Binder
<a name="l00365"></a>00365 object until that object is sent through the driver to another process.
<a name="l00366"></a>00366 At that point the driver adds the object's address to its mapping table
<a name="l00367"></a>00367 and asks the owning process to hold a reference on it.  When no other
<a name="l00368"></a>00368 processes know about the object, it is removed from the mapping table
<a name="l00369"></a>00369 and its owning process is told to release the driver's reference.  This
<a name="l00370"></a>00370 avoids maintaining the (relatively significant) driver state for an
<a name="l00371"></a>00371 object as <span class="keywordtype">long</span> as it is only used in its local process.
<a name="l00372"></a>00372 */
</pre></div><div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:27 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
