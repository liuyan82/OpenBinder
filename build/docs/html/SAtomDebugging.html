<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenBinder: SAtom Debugging</title>
<link href="doxygenPSI.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="SAtomDebugging">SAtom Debugging</a></h1><div class="header"> <center>&lt; <a class="el" href="SupportKit.html">Support Kit</a> | <a class="el" href="SupportKit.html">Support Kit</a> | <a class="el" href="SHandlerPatterns.html">SHandler Patterns</a> &gt;</center> <hr>
 </div><p>
The Atom Debug facilities in Palm OS can be extremely useful when trying to track down reference count leaks. Generally a normal malloc leak tracking tool is useless for these, because the code that originally allocated the object no longer owns it  instead there can be any number of other references on it that are causing it to leak.<p>
Using Atom Debug, you can find out about what objects are leaking and get information about who in the system is holding references on those objects. This tool works for both <a class="el" href="classSAtom.html">SAtom</a> and <a class="el" href="classSLightAtom.html">SLightAtom</a> objects. It is currently only useful in the Simulator, since it relies on being able to get stack crawls.<p>
<ol type=1>
<li><a class="el" href="SAtomDebugging.html#GettingStarting">Getting Started</a></li><li><a class="el" href="SAtomDebugging.html#FindingLeaks">Finding Leaks</a><ol type=a>
<li><a class="el" href="SAtomDebugging.html#Processes">Processes</a></li><li><a class="el" href="SAtomDebugging.html#DebuggingSteps">Debugging Steps</a></li><li><a class="el" href="SAtomDebugging.html#DebuggingALeak">Debugging a Leak</a></li></ol>
</li><li><a class="el" href="SAtomDebugging.html#ExaminingObjects">Examining Objects</a></li></ol>
<h2><a class="anchor" name="GettingStarting">
Getting Started</a></h2>
To debug <a class="el" href="classSAtom.html">SAtom</a> leaks, you will first need to enable the debugging facility before running the system.<p>
Before running a process, you will need to set the ATOM_DEBUG and ATOM_REPORT environment variables as desired.<p>
ATOM_DEBUG is used to control the amount of debugging that is enabled, and can be one of:<p>
<ul>
<li>"5" does simple validation of <a class="el" href="classSAtom.html">SAtom</a> reference counts (checking for releasing more times and than acquires for example) and a count of the total number of objects created and destroyed in a process.</li><li>"10" enables the full <a class="el" href="classSAtom.html">SAtom</a> debugging infrastructure. This is what you will normally use.</li></ul>
<p>
ATOM_REPORT is used to control how much information is collected and reported about references held on an <a class="el" href="classSAtom.html">SAtom</a>. The two values you will want to use are:<p>
<ul>
<li>"5" collects stack crawls, but only displays their addresses.</li><li>"10" displays full symbolic information (function names) for each line in a stack crawl when it is printed.</li></ul>
<p>
Note that the ATOM_DEBUG variable is examined by each process as it starts up, so you will need to set it for any processes to be debugged. In particular, if leaks are happening in the system process, you will need to set this variable when starting smooved.<p>
When using atom debugging, you will probably want to turn off lock debugging by setting LOCK_DEBUG=0. Both of these facilities are quite heavy-weight, so together they can slow down the system significantly.<p>
Your interaction with the atom debugger will often be through the "atom" Binder Shell command, though there are also APIs on <a class="el" href="classSAtom.html">SAtom</a> that you work with the debugging facilities programmatically. (In fact, the atom command is just a tool to call these APIs from the shell.) You might need to add atom.prc to your extra packages if it is not in the default build.<h2><a class="anchor" name="FindingLeaks">
Finding Leaks</a></h2>
Usually when debugging atom leaks you will use the atom command's "mark" and "leaks" options. The idea here is that when an atom object is allocated, it is placed in to a bin. An "atom mark" increments the bin number, returning the new bin. The "atom leaks" command gives you a list of existing atom object  including stack crawls of all references on them  which can be filtered by bin.<h3><a class="anchor" name="Processes">
Processes</a></h3>
The atom "mark" and "leaks" commands require that you specify the process they are to operate on. In a debug build, these processes are easily available from any Binder Shell session:<p>
<div class="fragment"><pre class="fragment">/$ su

/# ls /processes
background
system
top_ui
ui
</pre></div><p>
You can also use the Binder Shell environment variable $PROCESS to access the process that the shell is running in.<h3><a class="anchor" name="DebuggingSteps">
Debugging Steps</a></h3>
Here is a sketch of how a typical atom debugging session will go, assuming we are debugging a leak in the background process.<h4><a class="anchor" name="FlowStep1">
1. Start the process to be debugged.</a></h4>
Debugging output will go to whatever terminal the process was started in.<h4><a class="anchor" name="FlowStep2">
2. Start a debug terminal.</a></h4>
Use whatever approach you want to start a Binder Shell session.<h4><a class="anchor" name="FlowStep3">
3. Perform the operation that is leaking</a></h4>
For example, opening and then closing a slip. You do it here to get the code to load in any data that it caches, so that won't get mixed in with the real leak.<h4><a class="anchor" name="FlowStep4">
4. Mark the current state</a></h4>
<div class="fragment"><pre class="fragment">$ atom mark /processes/background
Result: int32_t(2 or 0x2)
</pre></div><h4><a class="anchor" name="FlowStep5">
5. Perform the operation that is leaking</a></h4>
All objects created will go into bin that you just marked.<h4><a class="anchor" name="FlowStep6">
6. Mark the next state</a></h4>
<div class="fragment"><pre class="fragment">$ atom mark /processes/background
Result: int32_t(3 or 0x3)
</pre></div><h4><a class="anchor" name="FlowStep7">
7. Perform the operation that is leaking</a></h4>
You'll want to do it one more time, to make sure your code has had a chance to release all of the references it is going to.<h4><a class="anchor" name="FlowStep8">
8. Get a leak report for the first mark</a></h4>
<div class="fragment"><pre class="fragment">$ atom leaks /processes/background 2 2
</pre></div><p>
This will print out all of the <a class="el" href="classSAtom.html">SAtom</a> and <a class="el" href="classSLightAtom.html">SLightAtom</a> objects that were created in the first mark (whose returned ID was 2) and that still exist.<h3><a class="anchor" name="DebuggingALeak">
Debugging a Leak</a></h3>
Let's simulate a leak, with the following code. Pretend that the shell code to instantiate a component is actually some code that is happening when we do something with the UI that is leaking.<p>
<div class="fragment"><pre class="fragment">### Perform our leaking operation for the first time.
$ C=$[new -r /processes/background org.openbinder.services.StatusBar.ClockSlipView]
Result: IBinder::shnd(0x132)
$ invoke /services/window AddView $C
Result: int32_t(0 or 0x0)

### Start a new SAtom bin.
$ atom mark /processes/background
Result: int32_t(2 or 0x2)

### Perform our leaking operation for the second time.
### (Everything done here are the objects for which we will be tracking leaks.)
$ C=$[new -r /processes/background org.openbinder.services.StatusBar.ClockSlipView]
Result: IBinder::shnd(0x132)
$ invoke /services/window AddView $C
Result: int32_t(0 or 0x0)

### Start a new SAtom bin; all operations between this and the
### last mark were placed in bin 2, and at this point nothing else
### will go in that bin.
$ atom mark /processes/background
Result: int32_t(3 or 0x3)

### Perform our leaking operations for the last time.
### (Flush out any temporary references held from the previous run.)
$ C=$[new -r /processes/background org.openbinder.services.StatusBar.ClockSlipView]
Result: IBinder::shnd(0x100)
$ invoke /services/window AddView $C
Result: int32_t(0 or 0x0)

### Print all of the leaks objects.
$ atom leaks /processes/background 2 2
</pre></div><p>
Upon executing the last command, we will get a dump of the leaked objects. The first thing you will notice is that there are a lot more objects listed here than just the one we actually leaked! Here is the list with most of the details removed:<p>
<div class="fragment"><pre class="fragment">Active atoms from mark 2 to 2:
	Report for atom 0x6b156d90 (class BpBinder) at mark #2:
	...
	Report for atom 0x6b14ff70 (class BpViewParent) at mark #2:
	...
	Report for atom 0x6b1502f0 (class ClockSlipView) at mark #2:
	...
	Report for atom 0x6b14fc48 (class BpCatalog) at mark #2:
	...
Result: int32_t(0 or 0x0)
</pre></div><p>
Usually, because of references between objects, when one object is leaked a whole host of related objects will be leaked as well. Your main task in debugging leaks is dealing with these dependencies: finding the one reference amongst these that actually caused the leak.<p>
In our example here, we know that the second object listed (class ClockSlipView) is the one being leaked because we created it. But how would we otherwise focus on that particular object?<p>
Let's look at all of the details of the last object in the list, line by line:<p>
<div class="fragment"><pre class="fragment">	Report for atom 0x6b14fc48 (class BpCatalog) at mark #2:
</pre></div><p>
This tells you that an <a class="el" href="classSAtom.html">SAtom</a> object at address 0x6b10ce48 has been leaked. C++ RTTI information says it is "class BpBinder", and it was allocated in mark bin 2.<p>
<div class="fragment"><pre class="fragment">	2 IncStrong Remain:
</pre></div><p>
There are two strong pointers on this object that are keeping it from being destroyed.<p>
<div class="fragment"><pre class="fragment">		0x6b150194 107 4043971000000us --
		0x6b150174 107 4043970000000us --
</pre></div><p>
These are the strong pointers. The first three numbers tell us, respectively, the owner ID (the void* passed to IncStrong() that identifies the owner of the reference), the thread ID that acquired the reference, and the time it was acquired. The remaining numbers (not shown here) are the stack crawl when the reference of the acquired, starting at the leaf.<p>
<div class="fragment"><pre class="fragment">	2 IncWeak Remain:
		0x6b150194 107 4043971000000us --
		0x6b150174 107 4043970000000us --
</pre></div><p>
There are 2 weak pointers on the object. Weak pointers generally don't keep an object from being destroyed, so for the purpose of debugging a leak you can generally ignore these. They give the same information about each reference as the strong pointers. Note that you will always have at least the same number of weak pointers as strong pointers, since acquiring a strong pointer also implicitly acquires a weak pointer.<p>
<div class="fragment"><pre class="fragment">	DecStrong:
	DecWeak:
</pre></div><p>
These tell you about any strong or weak pointer decrements that do not have a matching increment. They should generally be empty. The atom debugging code keeps track of references by their owner ID  when a reference is removed, it looks for the given owner ID in the list of current references and, if found, removes that reference from the object. If the owner ID isn't found, then the decrement operation will show up in one of the lists here.<p>
So is this object the one that is being leaked? You generally figure this out by looking at the stack crawls of its strong references, and determining if any of the other objects in the list are holding that reference. If they are all held by other leaked objects, then you can assume this one is being leaked as a side-effect of the real leak.<p>
If you are running Windows XP, you can quickly eliminate many of the objects by just looking at the stack crawl. If you aren't that fortunate  or need to look more in-depth at a particular stack crawl, you can run PalmSim in the debugger and, after pausing it, set a breakpoint at the address in the stack crawl to find out exactly where that is. (The console is still active even when the Simulator is stopped in the debugger.)<p>
Here is the full first stack crawl:<p>
<div class="fragment"><pre class="fragment">SAtom::add_incstrong(const void *, long)
SAtom::IncStrong(const void *)
sptr&lt;ICatalog&gt;::sptr&lt;ICatalog&gt;(const sptr&lt;ICatalog&gt; &amp;)
SContext::SContext(const SContext &amp;)
BBinder::BBinder(const SContext &amp;)
BnView::BnView(const SContext &amp;)
BView::BView(const SContext &amp;, const SValue &amp;)
ClockSlipView::ClockSlipView(const SContext &amp;, const SValue &amp;)
</pre></div><p>
And there is no need to go any further, because we see ClockSlipView involved in this leak and that it is itself being leaked, so we know where this reference came from.<p>
Likewise the second reference on the BpCatalog is this:<p>
<div class="fragment"><pre class="fragment">SAtom::add_incstrong(const void *, long)
SAtom::IncStrong(const void *)
sptr&lt;ICatalog&gt;::sptr&lt;ICatalog&gt;(const sptr&lt;ICatalog&gt; &amp;)
SContext::SContext(const SContext &amp;)
BBinder::BBinder(const SContext &amp;)
BnStatusBarSlip::BnStatusBarSlip(const SContext &amp;)
BStatusBarSlip::BStatusBarSlip(const SContext &amp;, const SValue &amp;)
ClockSlipView::ClockSlipView(const SContext &amp;, const SValue &amp;)
</pre></div><p>
And thus it is not the leak we are looking for.<p>
We can also immediately discount the first two objects, since there are no strong pointers to them:<p>
<div class="fragment"><pre class="fragment">	Report for atom 0x6b156d90 (class BpBinder) at mark #2:
	0 IncStrong Remain:
	1 IncWeak Remain:
		0x6b14ff5c 109 4056701000000us --
	DecStrong:
	DecWeak:
	Report for atom 0x6b14ff70 (class BpViewParent) at mark #2:
	0 IncStrong Remain:
	2 IncWeak Remain:
		0x6b112b98 109 4056702000000us --
		0x6b15020c 109 4056702000000us --
</pre></div><p>
That brings us to our culprit, "class ClockSlipView". But why did it leak? Let's look at its references.<p>
<div class="fragment"><pre class="fragment">	Report for atom 0x6b1502f0 (class ClockSlipView) at mark #2:
	2 IncStrong Remain:
		0x00000003 107 4043980000000us --
		0x6b1017cc 94 4043976000000us --
</pre></div><p>
The first reference is:<p>
<div class="fragment"><pre class="fragment">SAtom::add_incstrong(const void *, long)
SAtom::IncStrong(const void *)
BProcess::_IncrementReferenceCounts(unsigned int, bool, bool)
BProcess::PackBinderArgs(unsigned short, unsigned long, const SParcel &amp;, KALBinderIPCArgsType *)
SLooper::_HandleResponse(KALBinderIPCArgsType *, unsigned char *, SParcel *, bool)
SLooper::_LoopTransactionSelf(void)
SLooper::_EnterTransactionLoop(BProcess *)
SysThreadWrapper(long)
</pre></div><p>
The second reference is:<p>
<div class="fragment"><pre class="fragment">SAtom::add_incstrong(const void *, long)
SAtom::attempt_inc_strong(const void *, bool)
SAtom::AttemptIncStrong(const void *)
SAtom::AttemptAcquire(const void *)
BProcess::DispatchMessage(SLooper *)
SLooper::_HandleResponse(KALBinderIPCArgsType *, unsigned char *, SParcel *, bool)
SLooper::_LoopTransactionSelf(void)
SLooper::_EnterTransactionLoop(BProcess *)
SysThreadWrapper(long)
</pre></div><p>
The second stack crawl can probably be ignored  what we are seeing is a message in the process of being dispatched to the ClockSlipView (it includes a BHandler). Messages are transient, and you can rely on that reference being removed once the message processing is complete.<p>
The first reference, however, gives us a complication: it is coming from another process. In fact what we are seeing here is the reference the window manager (in the system process) holds on the ClockSlipView (in the background process). If this doesn't give you enough information to figure out the leak, you will need to broaden your scope and look for leaks in other processes. In fact, if we were to do this same thing in the system process, we would see a leak of the BpView proxy for our ClockSlipView, the window manager's WindowDecor view, and various other objects.<h2><a class="anchor" name="ExaminingObjects">
Examining Objects</a></h2>
You can use the atom command's find/report to get a report on a specific object. (If you use the mark option, <code>$PROCESS</code> is your current process.)<p>
For example: <div class="fragment"><pre class="fragment">atom report @{$[atom find "class CountryList"][0] }
</pre></div><p>
With symbols turned on, this gives you something like this: <div class="fragment"><pre class="fragment">Report for atom 0x4e7b4f08 (class CountryList) at mark #1:
1 IncStrong Remain:
	ID: 0x4e91c4fc, Thread: 91, When:128496000000
		0x50e7c651: &lt;SAtom::add_incstrong&gt;+0x00000021
		0x50e7b08f: &lt;SAtom::IncStrong&gt;+0x000000ff
		0x55d7dac9: &lt;sptr&lt;IActivity&gt;::operator=&gt;+0x00000039
		0x55d985ed: &lt;BActivityContainer::BActivityContainer&gt;+0x0000016d
		0x55d98871: &lt;BMainActivityContainer::BMainActivityContainer&gt;+0x000000b1
		0x55d917c5: &lt;BInteractiveActivity::CreateContainer&gt;+0x000000a5
		0x55d90f3f: &lt;BInteractiveActivity::GenerateView&gt;+0x0000001f
		0x55d95454: &lt;BVisualActivity::OnStart&gt;+0x00000024
		0x50e632b9: &lt;BActivity::HandleMessage&gt;+0x00000089
		0x55d91716: &lt;BInteractiveActivity::HandleMessage&gt;+0x000000d6
		0x50e9860c: &lt;BHandler::DispatchMessage&gt;+0x0000006c
		0x50ebb39b: &lt;BProcess::DispatchMessage&gt;+0x0000014b
		0x50eaba93: &lt;SLooper::_HandleResponse&gt;+0x00000333
		0x50eab542: &lt;SLooper::_LoopTransactionSelf&gt;+0x00000062
		0x50eaae00: &lt;SLooper::_EnterTransactionLoop&gt;+0x00000050
		0x00fb8f37: &lt;SysThreadWrapper&gt;+0x00000067
		0x00458a87: &lt;kHAL_ThreadWrapper_continuation&gt;+0x00000087
		0x00458631: &lt;kHAL_ThreadWrapper_switch_stack&gt;+0x00000011
		0x004588b8: &lt;kHAL_ThreadWrapper&gt;+0x00000108
		0x0045faa6: &lt;_threadstartex&gt;+0x000000b6
		0x77e7d28e: &lt;RegisterWaitForInputIdle&gt;+0x00000043
</pre></div> <div class="footer">
<hr>
<!--address style="align: right;"-->
<I>
<small>
<a href="http://www.palmsource.com/"><img name="ps_logo" src="../ps_logo.gif" width="96" height="54" align="left" border="0" alt=""></a>  Generated on Wed Dec 28 22:33:33 2005 by Doxygen 1.4.4 for OpenBinder Documentation Version 1.0
<P>
<a href="http://www.palmsource.com/">PalmSource, Inc.</A> &copy; 2005 &nbsp;
</small>
<!--/address-->
</I>
</div>
</body>
</html>
